AstarPath.AstarDistribution	astarpath.html#AstarDistribution	Information about where the package was downloaded.
AstarPath.Branch	astarpath.html#Branch	Which branch of the A* Pathfinding Project is this release. \n\nUsed when checking for updates so that users of the development versions can get notifications of development updates.
AstarPath.DestroyGraphPromise.graph	destroygraphpromise.html#graph	
AstarPath.Distribution	astarpath.html#Distribution	Used by the editor to guide the user to the correct place to download updates.
AstarPath.IsAnyGraphUpdateInProgress	astarpath.html#IsAnyGraphUpdateInProgress	Returns if any graph updates are being calculated right now. \n\n[more in online documentation]
AstarPath.IsAnyGraphUpdateQueued	astarpath.html#IsAnyGraphUpdateQueued	Returns if any graph updates are waiting to be applied. \n\n[more in online documentation]
AstarPath.IsAnyWorkItemInProgress	astarpath.html#IsAnyWorkItemInProgress	Returns if any work items are in progress right now. \n\n[more in online documentation]
AstarPath.IsInsideWorkItem	astarpath.html#IsInsideWorkItem	Returns if this code is currently being exectuted inside a work item. \n\n[more in online documentation]\nIn contrast to IsAnyWorkItemInProgress this is only true when work item code is being executed, it is not true in-between the updates to a work item that takes several frames to complete.
AstarPath.IsUsingMultithreading	astarpath.html#IsUsingMultithreading	Returns whether or not multithreading is used. \n\n\n[more in online documentation]
AstarPath.NNConstraintClosestAsSeenFromAbove	astarpath.html#NNConstraintClosestAsSeenFromAbove	Cached NNConstraint to avoid unnecessary allocations. \n\nThis should ideally be fixed by making NNConstraint an immutable class/struct.
AstarPath.NumParallelThreads	astarpath.html#NumParallelThreads	Number of parallel pathfinders. \n\nReturns the number of concurrent processes which can calculate paths at once. When using multithreading, this will be the number of threads, if not using multithreading it is always 1 (since only 1 coroutine is used). \n\n[more in online documentation]
AstarPath.On65KOverflow	astarpath.html#On65KOverflow	Called when <b>pathID</b> overflows 65536 and resets back to zero. \n\n[more in online documentation]
AstarPath.OnAwakeSettings	astarpath.html#OnAwakeSettings	Called on Awake before anything else is done. \n\nThis is called at the start of the Awake call, right after active has been set, but this is the only thing that has been done.\n\nUse this when you want to set up default settings for an AstarPath component created during runtime since some settings can only be changed in Awake (such as multithreading related stuff) <b>[code in online documentation]</b>
AstarPath.OnGraphPostScan	astarpath.html#OnGraphPostScan	Called for each graph after they have been scanned. \n\nAll other graphs might not have been scanned yet. In most cases it is recommended to create a custom class which inherits from Pathfinding.GraphModifier instead.
AstarPath.OnGraphPreScan	astarpath.html#OnGraphPreScan	Called for each graph before they are scanned. \n\nIn most cases it is recommended to create a custom class which inherits from Pathfinding.GraphModifier instead.
AstarPath.OnGraphsUpdated	astarpath.html#OnGraphsUpdated	Called when any graphs are updated. \n\nRegister to for example recalculate the path whenever a graph changes. In most cases it is recommended to create a custom class which inherits from Pathfinding.GraphModifier instead.
AstarPath.OnLatePostScan	astarpath.html#OnLatePostScan	Called after scanning has completed fully. \n\nThis is called as the last thing in the Scan function. In most cases it is recommended to create a custom class which inherits from Pathfinding.GraphModifier instead.
AstarPath.OnPathPostSearch	astarpath.html#OnPathPostSearch	Called for each path after searching. \n\nBe careful when using multithreading since this will be called from a different thread.
AstarPath.OnPathPreSearch	astarpath.html#OnPathPreSearch	Called for each path before searching. \n\nBe careful when using multithreading since this will be called from a different thread.
AstarPath.OnPathsCalculated	astarpath.html#OnPathsCalculated	Called right after callbacks on paths have been called. \n\nA path's callback function runs on the main thread when the path has been calculated. This is done in batches for all paths that have finished their calculation since the last frame. This event will trigger right after a batch of callbacks have been called.\n\nIf you do not want to use individual path callbacks, you can use this instead to poll all pending paths and see which ones have completed. This is better than doing it in e.g. the Update loop, because here you will have a guarantee that all calculated paths are still valid. Immediately after this callback has finished, other things may invalidate calculated paths, like for example graph updates.\n\nThis is used by the ECS integration to update all entities' pending paths, without having to store a callback for each agent, and also to avoid the ECS synchronization overhead that having individual callbacks would entail.
AstarPath.OnPostScan	astarpath.html#OnPostScan	Called after scanning. \n\nThis is called before applying links, flood-filling the graphs and other post processing. In most cases it is recommended to create a custom class which inherits from Pathfinding.GraphModifier instead.
AstarPath.OnPreScan	astarpath.html#OnPreScan	Called before starting the scanning. \n\nIn most cases it is recommended to create a custom class which inherits from Pathfinding.GraphModifier instead.
AstarPath.Version	astarpath.html#Version	The version number for the A* Pathfinding Project.
AstarPath.active	astarpath.html#active	Returns the active AstarPath object in the scene. \n\n[more in online documentation]
AstarPath.asyncScanTask	astarpath.html#asyncScanTask	If an async scan is running, this will be set to the coroutine. \n\nThis primarily used to be able to force the async scan to complete immediately, if the AstarPath component should happen to be destroyed while an async scan is running.
AstarPath.batchGraphUpdates	astarpath.html#batchGraphUpdates	Throttle graph updates and batch them to improve performance. \n\nIf toggled, graph updates will batched and executed less often (specified by graphUpdateBatchingInterval).\n\nThis can have a positive impact on pathfinding throughput since the pathfinding threads do not need to be stopped as often, and it reduces the overhead per graph update. All graph updates are still applied, they are just batched together so that more of them are applied at the same time.\n\nDo not use this if you want minimal latency between a graph update being requested and it being applied.\n\nThis only applies to graph updates requested using the UpdateGraphs method. Not those requested using AddWorkItem.\n\nIf you want to apply graph updates immediately at some point, you can call FlushGraphUpdates.\n\n[more in online documentation]
AstarPath.colorSettings	astarpath.html#colorSettings	Reference to the color settings for this AstarPath object. \n\nColor settings include for example which color the nodes should be in, in the sceneview.
AstarPath.data	astarpath.html#data	Holds all graph data.
AstarPath.debugFloor	astarpath.html#debugFloor	Low value to use for certain debugMode modes. \n\nFor example if debugMode is set to G, this value will determine when the node will be completely red.\n\n[more in online documentation]
AstarPath.debugMode	astarpath.html#debugMode	The mode to use for drawing nodes in the sceneview. \n\n[more in online documentation]
AstarPath.debugPathData	astarpath.html#debugPathData	The path to debug using gizmos. \n\nThis is the path handler used to calculate the last path. It is used in the editor to draw debug information using gizmos.
AstarPath.debugPathID	astarpath.html#debugPathID	The path ID to debug using gizmos.
AstarPath.debugRoof	astarpath.html#debugRoof	High value to use for certain debugMode modes. \n\nFor example if debugMode is set to G, this value will determine when the node will be completely green.\n\nFor the penalty debug mode, the nodes will be colored green when they have a penalty less than debugFloor and red when their penalty is greater or equal to this value and something between red and green otherwise.\n\n[more in online documentation]
AstarPath.euclideanEmbedding	astarpath.html#euclideanEmbedding	Holds settings for heuristic optimization. \n\n[more in online documentation]\n  [more in online documentation]
AstarPath.fullGetNearestSearch	astarpath.html#fullGetNearestSearch	Do a full GetNearest search for all graphs. \n\nAdditional searches will normally only be done on the graph which in the first fast search seemed to have the closest node. With this setting on, additional searches will be done on all graphs since the first check is not always completely accurate.\n\nMore technically: GetNearestForce on all graphs will be called if true, otherwise only on the one graph which's GetNearest search returned the best node.\n\nUsually faster when disabled, but higher quality searches when enabled. \n\n[more in online documentation]
AstarPath.graphDataLock	astarpath.html#graphDataLock	Global read-write lock for graph data. \n\nGraph data is always consistent from the main-thread's perspective, but if you are using jobs to read from graph data, you may need this.\n\nA write lock is held automatically...\n- During graph updates. During async graph updates, the lock is only held once per frame while the graph update is actually running, not for the whole duration.\n\n- During work items. Async work items work similarly to graph updates, the lock is only held once per frame while the work item is actually running.\n\n- When GraphModifier events run.\n\n- When graph related callbacks, such as OnGraphsUpdated, run.\n\n- During the last step of a graph's scanning process. See ScanningStage.\n\n\nTo use e.g. AstarPath.active.GetNearest from an ECS job, you'll need to acquire a read lock first, and make sure the lock is only released when the job is finished.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
AstarPath.graphUpdateBatchingInterval	astarpath.html#graphUpdateBatchingInterval	Minimum number of seconds between each batch of graph updates. \n\nIf batchGraphUpdates is true, this defines the minimum number of seconds between each batch of graph updates.\n\nThis can have a positive impact on pathfinding throughput since the pathfinding threads do not need to be stopped as often, and it reduces the overhead per graph update. All graph updates are still applied however, they are just batched together so that more of them are applied at the same time.\n\nDo not use this if you want minimal latency between a graph update being requested and it being applied.\n\nThis only applies to graph updates requested using the UpdateGraphs method. Not those requested using AddWorkItem.\n\n[more in online documentation]
AstarPath.graphUpdateRoutineRunning	astarpath.html#graphUpdateRoutineRunning	
AstarPath.graphUpdates	astarpath.html#graphUpdates	Processes graph updates.
AstarPath.graphUpdatesWorkItemAdded	astarpath.html#graphUpdatesWorkItemAdded	Makes sure QueueGraphUpdates will not queue multiple graph update orders.
AstarPath.graphs	astarpath.html#graphs	Shortcut to AstarData.graphs.
AstarPath.hasScannedGraphAtStartup	astarpath.html#hasScannedGraphAtStartup	
AstarPath.heuristic	astarpath.html#heuristic	The distance function to use as a heuristic. \n\nThe heuristic, often referred to as just 'H' is the estimated cost from a node to the target. Different heuristics affect how the path picks which one to follow from multiple possible with the same length \n\n[more in online documentation]
AstarPath.heuristicScale	astarpath.html#heuristicScale	The scale of the heuristic. \n\nIf a value lower than 1 is used, the pathfinder will search more nodes (slower). If 0 is used, the pathfinding algorithm will be reduced to dijkstra's algorithm. This is equivalent to setting heuristic to None. If a value larger than 1 is used the pathfinding will (usually) be faster because it expands fewer nodes, but the paths may no longer be the optimal (i.e the shortest possible paths).\n\nUsually you should leave this to the default value of 1.\n\n[more in online documentation]
AstarPath.hierarchicalGraph	astarpath.html#hierarchicalGraph	Holds a hierarchical graph to speed up some queries like if there is a path between two nodes.
AstarPath.inGameDebugPath	astarpath.html#inGameDebugPath	Debug string from the last completed path. \n\nWill be updated if logPathResults == PathLog.InGame
AstarPath.isScanning	astarpath.html#isScanning	True while any graphs are being scanned. \n\nThis is primarily relevant when scanning graph asynchronously.\n\n[more in online documentation]
AstarPath.lastGraphUpdate	astarpath.html#lastGraphUpdate	Time the last graph update was done. \n\nUsed to group together frequent graph updates to batches
AstarPath.lastScanTime	astarpath.html#lastScanTime	The time it took for the last call to Scan to complete.
AstarPath.logPathResults	astarpath.html#logPathResults	The amount of debugging messages. \n\nUse less debugging to improve performance (a bit) or just to get rid of the Console spamming. Use more debugging (heavy) if you want more information about what the pathfinding scripts are doing. The InGame option will display the latest path log using in-game GUI.\n\n <b>[image in online documentation]</b>
AstarPath.manualDebugFloorRoof	astarpath.html#manualDebugFloorRoof	If set, the debugFloor and debugRoof values will not be automatically recalculated. \n\n[more in online documentation]
AstarPath.maxFrameTime	astarpath.html#maxFrameTime	Max number of milliseconds to spend on pathfinding during each frame. \n\nAt least 500 nodes will be searched each frame (if there are that many to search). When using multithreading this value is irrelevant.
AstarPath.maxNearestNodeDistance	astarpath.html#maxNearestNodeDistance	Maximum distance to search for nodes. \n\nWhen searching for the nearest node to a point, this is the limit (in world units) for how far away it is allowed to be.\n\nThis is relevant if you try to request a path to a point that cannot be reached and it thus has to search for the closest node to that point which can be reached (which might be far away). If it cannot find a node within this distance then the path will fail.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
AstarPath.maxNearestNodeDistanceSqr	astarpath.html#maxNearestNodeDistanceSqr	Max Nearest Node Distance Squared. \n\n[more in online documentation]
AstarPath.navmeshUpdates	astarpath.html#navmeshUpdates	Handles navmesh cuts. \n\n[more in online documentation]
AstarPath.nextFreePathID	astarpath.html#nextFreePathID	The next unused Path ID. \n\nIncremented for every call to GetNextPathID
AstarPath.nodeStorage	astarpath.html#nodeStorage	Holds global node data that cannot be stored in individual graphs.
AstarPath.offMeshLinks	astarpath.html#offMeshLinks	Holds all active off-mesh links.
AstarPath.pathProcessor	astarpath.html#pathProcessor	Holds all paths waiting to be calculated and calculates them.
AstarPath.pathReturnQueue	astarpath.html#pathReturnQueue	Holds all completed paths waiting to be returned to where they were requested.
AstarPath.prioritizeGraphs	astarpath.html#prioritizeGraphs	Prioritize graphs. \n\nGraphs will be prioritized based on their order in the inspector. The first graph which has a node closer than prioritizeGraphsLimit will be chosen instead of searching all graphs.\n\n[more in online documentation]
AstarPath.prioritizeGraphsLimit	astarpath.html#prioritizeGraphsLimit	Distance limit for prioritizeGraphs. \n\n[more in online documentation]
AstarPath.redrawScope	astarpath.html#redrawScope	
AstarPath.scanOnStartup	astarpath.html#scanOnStartup	If true, all graphs will be scanned when the game starts, during OnEnable. \n\nIf you disable this, you will have to call AstarPath.active.Scan yourself to enable pathfinding. Alternatively you could load a saved graph from a file.\n\nIf a startup cache has been generated (see Saving and Loading Graphs), it always takes priority, and the graphs will be loaded from the cache instead of scanned.\n\nThis can be useful to disable if you want to scan your graphs asynchronously, or if you have a procedural world which has not been created yet at the start of the game.\n\n[more in online documentation]
AstarPath.showGraphs	astarpath.html#showGraphs	Shows or hides graph inspectors. \n\nUsed internally by the editor
AstarPath.showNavGraphs	astarpath.html#showNavGraphs	Visualize graphs in the scene view (editor only). \n\n <b>[image in online documentation]</b>
AstarPath.showSearchTree	astarpath.html#showSearchTree	If enabled, nodes will draw a line to their 'parent'. \n\nThis will show the search tree for the latest path.\n\n[more in online documentation]
AstarPath.showUnwalkableNodes	astarpath.html#showUnwalkableNodes	Toggle to show unwalkable nodes. \n\n[more in online documentation]
AstarPath.tagNames	astarpath.html#tagNames	Stored tag names. \n\n[more in online documentation]
AstarPath.threadCount	astarpath.html#threadCount	Number of pathfinding threads to use. \n\nMultithreading puts pathfinding in another thread, this is great for performance on 2+ core computers since the framerate will barely be affected by the pathfinding at all.\n- None indicates that the pathfinding is run in the Unity thread as a coroutine\n\n- Automatic will try to adjust the number of threads to the number of cores and memory on the computer. Less than 512mb of memory or a single core computer will make it revert to using no multithreading.\n\n\nIt is recommended that you use one of the "Auto" settings that are available. The reason is that even if your computer might be beefy and have 8 cores. Other computers might only be quad core or dual core in which case they will not benefit from more than 1 or 3 threads respectively (you usually want to leave one core for the unity thread). If you use more threads than the number of cores on the computer it is mostly just wasting memory, it will not run any faster. The extra memory usage is not trivially small. Each thread needs to keep a small amount of data for each node in all the graphs. It is not the full graph data but it is proportional to the number of nodes. The automatic settings will inspect the machine it is running on and use that to determine the number of threads so that no memory is wasted.\n\nThe exception is if you only have one (or maybe two characters) active at time. Then you should probably just go with one thread always since it is very unlikely that you will need the extra throughput given by more threads. Keep in mind that more threads primarily increases throughput by calculating different paths on different threads, it will not calculate individual paths any faster.\n\n[more in online documentation]\n\n\n\n[more in online documentation]\n  [more in online documentation]
AstarPath.unwalkableNodeDebugSize	astarpath.html#unwalkableNodeDebugSize	Size of the red cubes shown in place of unwalkable nodes. \n\n[more in online documentation]
AstarPath.waitForPathDepth	astarpath.html#waitForPathDepth	
AstarPath.workItemLock	astarpath.html#workItemLock	Held if any work items are currently queued.
AstarPath.workItems	astarpath.html#workItems	Processes work items.
Pathfinding.ABPath.NNConstraintNone	abpath.html#NNConstraintNone	Cached NNConstraint.None to reduce allocations.
Pathfinding.ABPath.calculatePartial	abpath.html#calculatePartial	Calculate partial path if the target node cannot be reached. \n\nIf the target node cannot be reached, the node which was closest (given by heuristic) will be chosen as target node and a partial path will be returned. This only works if a heuristic is used (which is the default). If a partial path is found, CompleteState is set to Partial. \n\n[more in online documentation]\nThe endNode and endPoint will be modified and be set to the node which ends up being closest to the target.\n\n[more in online documentation]
Pathfinding.ABPath.cost	abpath.html#cost	Total cost of this path as used by the pathfinding algorithm. \n\nThe cost is influenced by both the length of the path, as well as any tags or penalties on the nodes. By default, the cost to move 1 world unit is Int3.Precision.\n\nIf the path failed, the cost will be set to zero.\n\n[more in online documentation]
Pathfinding.ABPath.endNode	abpath.html#endNode	End node of the path.
Pathfinding.ABPath.endPoint	abpath.html#endPoint	End point of the path. \n\nThis is the closest point on the endNode to originalEndPoint
Pathfinding.ABPath.endPointKnownBeforeCalculation	abpath.html#endPointKnownBeforeCalculation	True if this path type has a well defined end point, even before calculation starts. \n\nThis is for example true for the ABPath type, but false for the RandomPath type.
Pathfinding.ABPath.endingCondition	abpath.html#endingCondition	Optional ending condition for the path. \n\nThe ending condition determines when the path has been completed. Can be used to for example mark a path as complete when it is within a specific distance from the target.\n\nIf ending conditions are used that are not centered around the endpoint of the path, then you should also set the heuristic to None to ensure the path is still optimal. The performance impact of setting the heuristic to None is quite large, so you might want to try to run it with the default heuristic to see if the path is good enough for your use case anyway.\n\nIf null, no custom ending condition will be used. This means that the path will end when the target node has been reached.\n\n[more in online documentation]
Pathfinding.ABPath.hasEndPoint	abpath.html#hasEndPoint	Determines if a search for an end node should be done. \n\nSet by different path types. \n\n[more in online documentation]
Pathfinding.ABPath.originalEndPoint	abpath.html#originalEndPoint	End Point exactly as in the path request.
Pathfinding.ABPath.originalStartPoint	abpath.html#originalStartPoint	Start Point exactly as in the path request.
Pathfinding.ABPath.partialBestTargetGScore	abpath.html#partialBestTargetGScore	
Pathfinding.ABPath.partialBestTargetHScore	abpath.html#partialBestTargetHScore	
Pathfinding.ABPath.partialBestTargetPathNodeIndex	abpath.html#partialBestTargetPathNodeIndex	Current best target for the partial path. \n\nThis is the node with the lowest H score.
Pathfinding.ABPath.startNode	abpath.html#startNode	Start node of the path.
Pathfinding.ABPath.startPoint	abpath.html#startPoint	Start point of the path. \n\nThis is the closest point on the startNode to originalStartPoint
Pathfinding.ABPathEndingCondition.abPath	abpathendingcondition.html#abPath	Path which this ending condition is used on. \n\nSame as path but downcasted to ABPath
Pathfinding.AIBase.ShapeGizmoColor	aibase.html#ShapeGizmoColor	
Pathfinding.AIBase.accumulatedMovementDelta	aibase.html#accumulatedMovementDelta	Accumulated movement deltas from the Move method.
Pathfinding.AIBase.autoRepath	aibase.html#autoRepath	Determines how the agent recalculates its path automatically. \n\nThis corresponds to the settings under the "Recalculate Paths Automatically" field in the inspector.
Pathfinding.AIBase.canMove	aibase.html#canMove	Enables or disables movement completely. \n\nIf you want the agent to stand still, but still react to local avoidance and use gravity: use isStopped instead.\n\nThis is also useful if you want to have full control over when the movement calculations run. Take a look at MovementUpdate\n\n[more in online documentation]
Pathfinding.AIBase.canSearch	aibase.html#canSearch	Enables or disables recalculating the path at regular intervals. \n\nSetting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.\n\nNote that this only disables automatic path recalculations. If you call the SearchPath() method a path will still be calculated.\n\n[more in online documentation]
Pathfinding.AIBase.canSearchCompability	aibase.html#canSearchCompability	
Pathfinding.AIBase.controller	aibase.html#controller	Cached CharacterController component.
Pathfinding.AIBase.desiredVelocity	aibase.html#desiredVelocity	Velocity that this agent wants to move with. \n\nIncludes gravity and local avoidance if applicable. In world units per second.\n\n[more in online documentation]
Pathfinding.AIBase.desiredVelocityWithoutLocalAvoidance	aibase.html#desiredVelocityWithoutLocalAvoidance	Velocity that this agent wants to move with before taking local avoidance into account. \n\nIncludes gravity. In world units per second.\n\nSetting this property will set the current velocity that the agent is trying to move with, including gravity. This can be useful if you want to make the agent come to a complete stop in a single frame or if you want to modify the velocity in some way.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]\n\n\nIf you are not using local avoidance then this property will in almost all cases be identical to desiredVelocity plus some noise due to floating point math.\n\n[more in online documentation]
Pathfinding.AIBase.destination	aibase.html#destination	Position in the world that this agent should move to. \n\nIf no destination has been set yet, then (+infinity, +infinity, +infinity) will be returned.\n\nNote that setting this property does not immediately cause the agent to recalculate its path. So it may take some time before the agent starts to move towards this point. Most movement scripts have a <b>repathRate</b> field which indicates how often the agent looks for a new path. You can also call the SearchPath method to immediately start to search for a new path. Paths are calculated asynchronously so when an agent starts to search for path it may take a few frames (usually 1 or 2) until the result is available. During this time the pathPending property will return true.\n\nIf you are setting a destination and then want to know when the agent has reached that destination then you could either use reachedDestination (recommended) or check both pathPending and reachedEndOfPath. Check the documentation for the respective fields to learn about their differences.\n\n<b>[code in online documentation]</b><b>[code in online documentation]</b>
Pathfinding.AIBase.destinationBackingField	aibase.html#destinationBackingField	Backing field for destination.
Pathfinding.AIBase.enableRotation	aibase.html#enableRotation	If true, the AI will rotate to face the movement direction. \n\n[more in online documentation]
Pathfinding.AIBase.endOfPath	aibase.html#endOfPath	End point of path the agent is currently following. \n\nIf the agent has no path (or it might not be calculated yet), this will return the destination instead. If the agent has no destination it will return the agent's current position.\n\nThe end of the path is usually identical or very close to the destination, but it may differ if the path for example was blocked by a wall so that the agent couldn't get any closer.\n\nThis is only updated when the path is recalculated.
Pathfinding.AIBase.endReachedDistance	aibase.html#endReachedDistance	Distance to the end point to consider the end of path to be reached. \n\nWhen the end of the path is within this distance then IAstarAI.reachedEndOfPath will return true. When the destination is within this distance then IAstarAI.reachedDestination will return true.\n\nNote that the destination may not be reached just because the end of the path was reached. The destination may not be reachable at all.\n\n[more in online documentation]
Pathfinding.AIBase.gravity	aibase.html#gravity	Gravity to use. \n\nIf set to (NaN,NaN,NaN) then Physics.Gravity (configured in the Unity project settings) will be used. If set to (0,0,0) then no gravity will be used and no raycast to check for ground penetration will be performed.
Pathfinding.AIBase.groundMask	aibase.html#groundMask	Layer mask to use for ground placement. \n\nMake sure this does not include the layer of any colliders attached to this gameobject.\n\n[more in online documentation]
Pathfinding.AIBase.height	aibase.html#height	Height of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nThis value is currently only used if an RVOController is attached to the same GameObject, otherwise it is only used for drawing nice gizmos in the scene view. However since the height value is used for some things, the radius field is always visible for consistency and easier visualization of the character. That said, it may be used for something in a future release.\n\n[more in online documentation]
Pathfinding.AIBase.isStopped	aibase.html#isStopped	Gets or sets if the agent should stop moving. \n\nIf this is set to true the agent will immediately start to slow down as quickly as it can to come to a full stop. The agent will still react to local avoidance and gravity (if applicable), but it will not try to move in any particular direction.\n\nThe current path of the agent will not be cleared, so when this is set to false again the agent will continue moving along the previous path.\n\nThis is a purely user-controlled parameter, so for example it is not set automatically when the agent stops moving because it has reached the target. Use reachedEndOfPath for that.\n\nIf this property is set to true while the agent is traversing an off-mesh link (RichAI script only), then the agent will continue traversing the link and stop once it has completed it.\n\n[more in online documentation]\nThe steeringTarget property will continue to indicate the point which the agent would move towards if it would not be stopped.
Pathfinding.AIBase.lastDeltaPosition	aibase.html#lastDeltaPosition	Amount which the character wants or tried to move with during the last frame.
Pathfinding.AIBase.lastDeltaTime	aibase.html#lastDeltaTime	Delta time used for movement during the last frame.
Pathfinding.AIBase.lastRaycastHit	aibase.html#lastRaycastHit	Hit info from the last raycast done for ground placement. \n\nWill not update unless gravity is used (if no gravity is used, then raycasts are disabled).\n\n[more in online documentation]
Pathfinding.AIBase.lastRepath	aibase.html#lastRepath	Time when the last path request was started.
Pathfinding.AIBase.maxSpeed	aibase.html#maxSpeed	Max speed in world units per second.
Pathfinding.AIBase.movementPlane	aibase.html#movementPlane	Plane which this agent is moving in. \n\nThis is used to convert between world space and a movement plane to make it possible to use this script in both 2D games and 3D games.
Pathfinding.AIBase.onPathComplete	aibase.html#onPathComplete	Cached delegate for the OnPathComplete method. \n\nCaching this avoids allocating a new one every time a path is calculated, which reduces GC pressure.
Pathfinding.AIBase.onSearchPath	aibase.html#onSearchPath	Called when the agent recalculates its path. \n\nThis is called both for automatic path recalculations (see canSearch) and manual ones (see SearchPath).\n\n[more in online documentation]
Pathfinding.AIBase.orientation	aibase.html#orientation	Determines which direction the agent moves in. \n\nFor 3D games you most likely want the ZAxisIsForward option as that is the convention for 3D games. For 2D games you most likely want the YAxisIsForward option as that is the convention for 2D games.\n\nUsing the YAxisForward option will also allow the agent to assume that the movement will happen in the 2D (XY) plane instead of the XZ plane if it does not know. This is important only for the point graph which does not have a well defined up direction. The other built-in graphs (e.g the grid graph) will all tell the agent which movement plane it is supposed to use.\n\n <b>[image in online documentation]</b>
Pathfinding.AIBase.position	aibase.html#position	Position of the agent. \n\nIn world space. If updatePosition is true then this value is idential to transform.position. \n\n[more in online documentation]
Pathfinding.AIBase.prevPosition1	aibase.html#prevPosition1	Position of the character at the end of the last frame.
Pathfinding.AIBase.prevPosition2	aibase.html#prevPosition2	Position of the character at the end of the frame before the last frame.
Pathfinding.AIBase.radius	aibase.html#radius	Radius of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nNote that this does not affect pathfinding in any way. The graph used completely determines where the agent can move.\n\n[more in online documentation]
Pathfinding.AIBase.reachedDestination	aibase.html#reachedDestination	True if the ai has reached the destination. \n\nThis is a best effort calculation to see if the destination has been reached. For the AIPath/RichAI scripts, this is when the character is within AIPath.endReachedDistance world units from the destination. For the AILerp script it is when the character is at the destination (±a very small margin).\n\nThis value will be updated immediately when the destination is changed (in contrast to reachedEndOfPath), however since path requests are asynchronous it will use an approximation until it sees the real path result. What this property does is to check the distance to the end of the current path, and add to that the distance from the end of the path to the destination (i.e. is assumes it is possible to move in a straight line between the end of the current path to the destination) and then checks if that total distance is less than AIPath.endReachedDistance. This property is therefore only a best effort, but it will work well for almost all use cases.\n\nFurthermore it will not report that the destination is reached if the destination is above the head of the character or more than half the height of the character below its feet (so if you have a multilevel building, it is important that you configure the height of the character correctly).\n\nThe cases which could be problematic are if an agent is standing next to a very thin wall and the destination suddenly changes to the other side of that thin wall. During the time that it takes for the path to be calculated the agent may see itself as alredy having reached the destination because the destination only moved a very small distance (the wall was thin), even though it may actually be quite a long way around the wall to the other side.\n\nIn contrast to reachedEndOfPath, this property is immediately updated when the destination is changed.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.AIBase.repathRate	aibase.html#repathRate	Determines how often the agent will search for new paths (in seconds). \n\nThe agent will plan a new path to the target every N seconds.\n\nIf you have fast moving targets or AIs, you might want to set it to a lower value.\n\n[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.AIBase.repathRateCompatibility	aibase.html#repathRateCompatibility	
Pathfinding.AIBase.rigid	aibase.html#rigid	Cached Rigidbody component.
Pathfinding.AIBase.rigid2D	aibase.html#rigid2D	Cached Rigidbody component.
Pathfinding.AIBase.rotation	aibase.html#rotation	Rotation of the agent. \n\nIf updateRotation is true then this value is identical to transform.rotation.
Pathfinding.AIBase.rvoController	aibase.html#rvoController	Cached RVOController component.
Pathfinding.AIBase.rvoDensityBehavior	aibase.html#rvoDensityBehavior	Controls if the agent slows down to a stop if the area around the destination is crowded. \n\nUsing this module requires that local avoidance is used: i.e. that an RVOController is attached to the GameObject.\n\n[more in online documentation]\n  [more in online documentation]
Pathfinding.AIBase.seeker	aibase.html#seeker	Cached Seeker component.
Pathfinding.AIBase.shouldRecalculatePath	aibase.html#shouldRecalculatePath	True if the path should be automatically recalculated as soon as possible.
Pathfinding.AIBase.simulatedPosition	aibase.html#simulatedPosition	Position of the agent. \n\nIf updatePosition is true then this value will be synchronized every frame with Transform.position.
Pathfinding.AIBase.simulatedRotation	aibase.html#simulatedRotation	Rotation of the agent. \n\nIf updateRotation is true then this value will be synchronized every frame with Transform.rotation.
Pathfinding.AIBase.startHasRun	aibase.html#startHasRun	True if the Start method has been executed. \n\nUsed to test if coroutines should be started in OnEnable to prevent calculating paths in the awake stage (or rather before start on frame 0).
Pathfinding.AIBase.tr	aibase.html#tr	Cached Transform component.
Pathfinding.AIBase.updatePosition	aibase.html#updatePosition	Determines if the character's position should be coupled to the Transform's position. \n\nIf false then all movement calculations will happen as usual, but the object that this component is attached to will not move instead only the position property will change.\n\nThis is useful if you want to control the movement of the character using some other means such as for example root motion but still want the AI to move freely. \n\n[more in online documentation]
Pathfinding.AIBase.updateRotation	aibase.html#updateRotation	Determines if the character's rotation should be coupled to the Transform's rotation. \n\nIf false then all movement calculations will happen as usual, but the object that this component is attached to will not rotate instead only the rotation property will change.\n\n[more in online documentation]
Pathfinding.AIBase.usingGravity	aibase.html#usingGravity	Indicates if gravity is used during this frame.
Pathfinding.AIBase.velocity	aibase.html#velocity	Actual velocity that the agent is moving with. \n\nIn world units per second.\n\n[more in online documentation]
Pathfinding.AIBase.velocity2D	aibase.html#velocity2D	Current desired velocity of the agent (does not include local avoidance and physics). \n\nLies in the movement plane.
Pathfinding.AIBase.verticalVelocity	aibase.html#verticalVelocity	Velocity due to gravity. \n\nPerpendicular to the movement plane.\n\nWhen the agent is grounded this may not accurately reflect the velocity of the agent. It may be non-zero even though the agent is not moving.
Pathfinding.AIBase.waitingForPathCalculation	aibase.html#waitingForPathCalculation	Only when the previous path has been calculated should the script consider searching for a new path.
Pathfinding.AIBase.whenCloseToDestination	aibase.html#whenCloseToDestination	What to do when within endReachedDistance units from the destination. \n\nThe character can either stop immediately when it comes within that distance, which is useful for e.g archers or other ranged units that want to fire on a target. Or the character can continue to try to reach the exact destination point and come to a full stop there. This is useful if you want the character to reach the exact point that you specified.\n\n[more in online documentation]
Pathfinding.AIDestinationSetter.ai	aidestinationsetter.html#ai	
Pathfinding.AIDestinationSetter.entity	aidestinationsetter.html#entity	
Pathfinding.AIDestinationSetter.target	aidestinationsetter.html#target	The object that the AI should move to.
Pathfinding.AIDestinationSetter.useRotation	aidestinationsetter.html#useRotation	If true, the agent will try to align itself with the rotation of the target. \n\nThis can only be used together with the FollowerEntity movement script. Other movement scripts will ignore it.\n\n <b>[video in online documentation]</b>\n\n[more in online documentation]
Pathfinding.AIDestinationSetter.world	aidestinationsetter.html#world	
Pathfinding.AILerp.autoRepath	ailerp.html#autoRepath	Determines how the agent recalculates its path automatically. \n\nThis corresponds to the settings under the "Recalculate Paths Automatically" field in the inspector.
Pathfinding.AILerp.canMove	ailerp.html#canMove	Enables or disables movement completely. \n\nIf you want the agent to stand still, but still react to local avoidance and use gravity: use isStopped instead.\n\nThis is also useful if you want to have full control over when the movement calculations run. Take a look at MovementUpdate\n\n[more in online documentation]
Pathfinding.AILerp.canSearch	ailerp.html#canSearch	Enables or disables recalculating the path at regular intervals. \n\nSetting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.\n\nNote that this only disables automatic path recalculations. If you call the SearchPath() method a path will still be calculated.\n\n[more in online documentation]
Pathfinding.AILerp.canSearchAgain	ailerp.html#canSearchAgain	Only when the previous path has been returned should a search for a new path be done.
Pathfinding.AILerp.canSearchCompability	ailerp.html#canSearchCompability	
Pathfinding.AILerp.desiredVelocity	ailerp.html#desiredVelocity	Velocity that this agent wants to move with. \n\nIncludes gravity and local avoidance if applicable. In world units per second.\n\n[more in online documentation]
Pathfinding.AILerp.desiredVelocityWithoutLocalAvoidance	ailerp.html#desiredVelocityWithoutLocalAvoidance	Velocity that this agent wants to move with before taking local avoidance into account. \n\nIncludes gravity. In world units per second.\n\nSetting this property will set the current velocity that the agent is trying to move with, including gravity. This can be useful if you want to make the agent come to a complete stop in a single frame or if you want to modify the velocity in some way.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]\n\n\nIf you are not using local avoidance then this property will in almost all cases be identical to desiredVelocity plus some noise due to floating point math.\n\n[more in online documentation]
Pathfinding.AILerp.destination	ailerp.html#destination	Position in the world that this agent should move to. \n\nIf no destination has been set yet, then (+infinity, +infinity, +infinity) will be returned.\n\nNote that setting this property does not immediately cause the agent to recalculate its path. So it may take some time before the agent starts to move towards this point. Most movement scripts have a <b>repathRate</b> field which indicates how often the agent looks for a new path. You can also call the SearchPath method to immediately start to search for a new path. Paths are calculated asynchronously so when an agent starts to search for path it may take a few frames (usually 1 or 2) until the result is available. During this time the pathPending property will return true.\n\nIf you are setting a destination and then want to know when the agent has reached that destination then you could either use reachedDestination (recommended) or check both pathPending and reachedEndOfPath. Check the documentation for the respective fields to learn about their differences.\n\n<b>[code in online documentation]</b><b>[code in online documentation]</b>
Pathfinding.AILerp.enableRotation	ailerp.html#enableRotation	If true, the AI will rotate to face the movement direction. \n\n[more in online documentation]
Pathfinding.AILerp.endOfPath	ailerp.html#endOfPath	End point of path the agent is currently following. \n\nIf the agent has no path (or it might not be calculated yet), this will return the destination instead. If the agent has no destination it will return the agent's current position.\n\nThe end of the path is usually identical or very close to the destination, but it may differ if the path for example was blocked by a wall so that the agent couldn't get any closer.\n\nThis is only updated when the path is recalculated.
Pathfinding.AILerp.hasPath	ailerp.html#hasPath	True if this agent currently has a path that it follows.
Pathfinding.AILerp.height	ailerp.html#height	Height of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nThis value is currently only used if an RVOController is attached to the same GameObject, otherwise it is only used for drawing nice gizmos in the scene view. However since the height value is used for some things, the radius field is always visible for consistency and easier visualization of the character. That said, it may be used for something in a future release.\n\n[more in online documentation]
Pathfinding.AILerp.interpolatePathSwitches	ailerp.html#interpolatePathSwitches	If true, some interpolation will be done when a new path has been calculated. \n\nThis is used to avoid short distance teleportation. \n\n[more in online documentation]
Pathfinding.AILerp.interpolator	ailerp.html#interpolator	
Pathfinding.AILerp.interpolatorPath	ailerp.html#interpolatorPath	
Pathfinding.AILerp.isStopped	ailerp.html#isStopped	Gets or sets if the agent should stop moving. \n\nIf this is set to true the agent will immediately start to slow down as quickly as it can to come to a full stop. The agent will still react to local avoidance and gravity (if applicable), but it will not try to move in any particular direction.\n\nThe current path of the agent will not be cleared, so when this is set to false again the agent will continue moving along the previous path.\n\nThis is a purely user-controlled parameter, so for example it is not set automatically when the agent stops moving because it has reached the target. Use reachedEndOfPath for that.\n\nIf this property is set to true while the agent is traversing an off-mesh link (RichAI script only), then the agent will continue traversing the link and stop once it has completed it.\n\n[more in online documentation]\nThe steeringTarget property will continue to indicate the point which the agent would move towards if it would not be stopped.
Pathfinding.AILerp.maxSpeed	ailerp.html#maxSpeed	Max speed in world units per second.
Pathfinding.AILerp.movementPlane	ailerp.html#movementPlane	The plane the agent is moving in. \n\nThis is typically the ground plane, which will be the XZ plane in a 3D game, and the XY plane in a 2D game. Ultimately it depends on the graph orientation.\n\nIf you are doing pathfinding on a spherical world (see Spherical Worlds), the the movement plane will be the tangent plane of the sphere at the agent's position.
Pathfinding.AILerp.onPathComplete	ailerp.html#onPathComplete	Cached delegate for the OnPathComplete method. \n\nCaching this avoids allocating a new one every time a path is calculated, which reduces GC pressure.
Pathfinding.AILerp.onSearchPath	ailerp.html#onSearchPath	Called when the agent recalculates its path. \n\nThis is called both for automatic path recalculations (see canSearch) and manual ones (see SearchPath).\n\n[more in online documentation]
Pathfinding.AILerp.orientation	ailerp.html#orientation	Determines which direction the agent moves in. \n\nFor 3D games you most likely want the ZAxisIsForward option as that is the convention for 3D games. For 2D games you most likely want the YAxisIsForward option as that is the convention for 2D games.\n\nUsing the YAxisForward option will also allow the agent to assume that the movement will happen in the 2D (XY) plane instead of the XZ plane if it does not know. This is important only for the point graph which does not have a well defined up direction. The other built-in graphs (e.g the grid graph) will all tell the agent which movement plane it is supposed to use.\n\n <b>[image in online documentation]</b>
Pathfinding.AILerp.path	ailerp.html#path	Current path which is followed.
Pathfinding.AILerp.pathPending	ailerp.html#pathPending	True if a path is currently being calculated.
Pathfinding.AILerp.pathSwitchInterpolationTime	ailerp.html#pathSwitchInterpolationTime	Time since the path was replaced by a new path. \n\n[more in online documentation]
Pathfinding.AILerp.position	ailerp.html#position	Position of the agent. \n\nIn world space. \n\n[more in online documentation]\nIf you want to move the agent you may use Teleport or Move.
Pathfinding.AILerp.previousMovementDirection	ailerp.html#previousMovementDirection	
Pathfinding.AILerp.previousMovementOrigin	ailerp.html#previousMovementOrigin	When a new path was returned, the AI was moving along this ray. \n\nUsed to smoothly interpolate between the previous movement and the movement along the new path. The speed is equal to movement direction.
Pathfinding.AILerp.previousPosition1	ailerp.html#previousPosition1	
Pathfinding.AILerp.previousPosition2	ailerp.html#previousPosition2	
Pathfinding.AILerp.radius	ailerp.html#radius	Radius of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nNote that this does not affect pathfinding in any way. The graph used completely determines where the agent can move.\n\n[more in online documentation]
Pathfinding.AILerp.reachedDestination	ailerp.html#reachedDestination	True if the ai has reached the destination. \n\nThis is a best effort calculation to see if the destination has been reached. For the AIPath/RichAI scripts, this is when the character is within AIPath.endReachedDistance world units from the destination. For the AILerp script it is when the character is at the destination (±a very small margin).\n\nThis value will be updated immediately when the destination is changed (in contrast to reachedEndOfPath), however since path requests are asynchronous it will use an approximation until it sees the real path result. What this property does is to check the distance to the end of the current path, and add to that the distance from the end of the path to the destination (i.e. is assumes it is possible to move in a straight line between the end of the current path to the destination) and then checks if that total distance is less than AIPath.endReachedDistance. This property is therefore only a best effort, but it will work well for almost all use cases.\n\nFurthermore it will not report that the destination is reached if the destination is above the head of the character or more than half the height of the character below its feet (so if you have a multilevel building, it is important that you configure the height of the character correctly).\n\nThe cases which could be problematic are if an agent is standing next to a very thin wall and the destination suddenly changes to the other side of that thin wall. During the time that it takes for the path to be calculated the agent may see itself as alredy having reached the destination because the destination only moved a very small distance (the wall was thin), even though it may actually be quite a long way around the wall to the other side.\n\nIn contrast to reachedEndOfPath, this property is immediately updated when the destination is changed.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.AILerp.reachedEndOfPath	ailerp.html#reachedEndOfPath	True if the end of the current path has been reached.
Pathfinding.AILerp.remainingDistance	ailerp.html#remainingDistance	Approximate remaining distance along the current path to the end of the path. \n\nThe RichAI movement script approximates this distance since it is quite expensive to calculate the real distance. However it will be accurate when the agent is within 1 corner of the destination. You can use GetRemainingPath to calculate the actual remaining path more precisely.\n\nThe AIPath and AILerp scripts use a more accurate distance calculation at all times.\n\nIf the agent does not currently have a path, then positive infinity will be returned.\n\n[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.AILerp.repathRate	ailerp.html#repathRate	Determines how often it will search for new paths. \n\nIf you have fast moving targets or AIs, you might want to set it to a lower value. The value is in seconds between path requests.\n\n[more in online documentation]
Pathfinding.AILerp.repathRateCompatibility	ailerp.html#repathRateCompatibility	
Pathfinding.AILerp.rotation	ailerp.html#rotation	Rotation of the agent. \n\nIn world space. \n\n[more in online documentation]
Pathfinding.AILerp.rotationSpeed	ailerp.html#rotationSpeed	How quickly to rotate.
Pathfinding.AILerp.seeker	ailerp.html#seeker	Cached Seeker component.
Pathfinding.AILerp.shouldRecalculatePath	ailerp.html#shouldRecalculatePath	True if the path should be automatically recalculated as soon as possible.
Pathfinding.AILerp.simulatedPosition	ailerp.html#simulatedPosition	
Pathfinding.AILerp.simulatedRotation	ailerp.html#simulatedRotation	
Pathfinding.AILerp.speed	ailerp.html#speed	Speed in world units.
Pathfinding.AILerp.startHasRun	ailerp.html#startHasRun	Holds if the Start function has been run. \n\nUsed to test if coroutines should be started in OnEnable to prevent calculating paths in the awake stage (or rather before start on frame 0).
Pathfinding.AILerp.steeringTarget	ailerp.html#steeringTarget	Point on the path which the agent is currently moving towards. \n\nThis is usually a point a small distance ahead of the agent or the end of the path.\n\nIf the agent does not have a path at the moment, then the agent's current position will be returned.
Pathfinding.AILerp.switchPathInterpolationSpeed	ailerp.html#switchPathInterpolationSpeed	How quickly to interpolate to the new path. \n\n[more in online documentation]
Pathfinding.AILerp.tr	ailerp.html#tr	Cached Transform component.
Pathfinding.AILerp.updatePosition	ailerp.html#updatePosition	Determines if the character's position should be coupled to the Transform's position. \n\nIf false then all movement calculations will happen as usual, but the object that this component is attached to will not move instead only the position property will change.\n\n[more in online documentation]
Pathfinding.AILerp.updateRotation	ailerp.html#updateRotation	Determines if the character's rotation should be coupled to the Transform's rotation. \n\nIf false then all movement calculations will happen as usual, but the object that this component is attached to will not rotate instead only the rotation property will change.\n\n[more in online documentation]
Pathfinding.AILerp.velocity	ailerp.html#velocity	Actual velocity that the agent is moving with. \n\nIn world units per second.\n\n[more in online documentation]
Pathfinding.AIPath.GizmoColor	aipath.html#GizmoColor	
Pathfinding.AIPath.alwaysDrawGizmos	aipath.html#alwaysDrawGizmos	Draws detailed gizmos constantly in the scene view instead of only when the agent is selected and settings are being modified.
Pathfinding.AIPath.cachedNNConstraint	aipath.html#cachedNNConstraint	
Pathfinding.AIPath.canMove	aipath.html#canMove	Enables or disables movement completely. \n\nIf you want the agent to stand still, but still react to local avoidance and use gravity: use isStopped instead.\n\nThis is also useful if you want to have full control over when the movement calculations run. Take a look at MovementUpdate\n\n[more in online documentation]
Pathfinding.AIPath.canSearch	aipath.html#canSearch	Enables or disables recalculating the path at regular intervals. \n\nSetting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.\n\nNote that this only disables automatic path recalculations. If you call the SearchPath() method a path will still be calculated.\n\n[more in online documentation]
Pathfinding.AIPath.constrainInsideGraph	aipath.html#constrainInsideGraph	Ensure that the character is always on the traversable surface of the navmesh. \n\nWhen this option is enabled a GetNearest query will be done every frame to find the closest node that the agent can walk on and if the agent is not inside that node, then the agent will be moved to it.\n\nThis is especially useful together with local avoidance in order to avoid agents pushing each other into walls. \n\n[more in online documentation]\nThis option also integrates with local avoidance so that if the agent is say forced into a wall by other agents the local avoidance system will be informed about that wall and can take that into account.\n\nEnabling this has some performance impact depending on the graph type (pretty fast for grid graphs, slightly slower for navmesh/recast graphs). If you are using a navmesh/recast graph you may want to switch to the RichAI movement script which is specifically written for navmesh/recast graphs and does this kind of clamping out of the box. In many cases it can also follow the path more smoothly around sharp bends in the path.\n\nIt is not recommended that you use this option together with the funnel modifier on grid graphs because the funnel modifier will make the path go very close to the border of the graph and this script has a tendency to try to cut corners a bit. This may cause it to try to go slightly outside the traversable surface near corners and that will look bad if this option is enabled.\n\n[more in online documentation]\nBelow you can see an image where several agents using local avoidance were ordered to go to the same point in a corner. When not constraining the agents to the graph they are easily pushed inside obstacles.  <b>[image in online documentation]</b>
Pathfinding.AIPath.endOfPath	aipath.html#endOfPath	End point of path the agent is currently following. \n\nIf the agent has no path (or it might not be calculated yet), this will return the destination instead. If the agent has no destination it will return the agent's current position.\n\nThe end of the path is usually identical or very close to the destination, but it may differ if the path for example was blocked by a wall so that the agent couldn't get any closer.\n\nThis is only updated when the path is recalculated.
Pathfinding.AIPath.gizmoHash	aipath.html#gizmoHash	
Pathfinding.AIPath.hasPath	aipath.html#hasPath	True if this agent currently has a path that it follows.
Pathfinding.AIPath.height	aipath.html#height	Height of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nThis value is currently only used if an RVOController is attached to the same GameObject, otherwise it is only used for drawing nice gizmos in the scene view. However since the height value is used for some things, the radius field is always visible for consistency and easier visualization of the character. That said, it may be used for something in a future release.\n\n[more in online documentation]
Pathfinding.AIPath.interpolator	aipath.html#interpolator	Represents the current steering target for the agent.
Pathfinding.AIPath.interpolatorPath	aipath.html#interpolatorPath	Helper which calculates points along the current path.
Pathfinding.AIPath.lastChangedTime	aipath.html#lastChangedTime	
Pathfinding.AIPath.maxAcceleration	aipath.html#maxAcceleration	How quickly the agent accelerates. \n\nPositive values represent an acceleration in world units per second squared. Negative values are interpreted as an inverse time of how long it should take for the agent to reach its max speed. For example if it should take roughly 0.4 seconds for the agent to reach its max speed then this field should be set to -1/0.4 = -2.5. For a negative value the final acceleration will be: -acceleration*maxSpeed. This behaviour exists mostly for compatibility reasons.\n\nIn the Unity inspector there are two modes: Default and Custom. In the Default mode this field is set to -2.5 which means that it takes about 0.4 seconds for the agent to reach its top speed. In the Custom mode you can set the acceleration to any positive value.
Pathfinding.AIPath.maxSpeed	aipath.html#maxSpeed	Max speed in world units per second.
Pathfinding.AIPath.movementPlane	aipath.html#movementPlane	The plane the agent is moving in. \n\nThis is typically the ground plane, which will be the XZ plane in a 3D game, and the XY plane in a 2D game. Ultimately it depends on the graph orientation.\n\nIf you are doing pathfinding on a spherical world (see Spherical Worlds), the the movement plane will be the tangent plane of the sphere at the agent's position.
Pathfinding.AIPath.path	aipath.html#path	Current path which is followed.
Pathfinding.AIPath.pathPending	aipath.html#pathPending	True if a path is currently being calculated.
Pathfinding.AIPath.pickNextWaypointDist	aipath.html#pickNextWaypointDist	How far the AI looks ahead along the path to determine the point it moves to. \n\nIn world units. If you enable the alwaysDrawGizmos toggle this value will be visualized in the scene view as a blue circle around the agent.  <b>[image in online documentation]</b>\n\nHere are a few example videos showing some typical outcomes with good values as well as how it looks when this value is too low and too high. [more in online documentation]
Pathfinding.AIPath.preventMovingBackwards	aipath.html#preventMovingBackwards	Prevent the velocity from being too far away from the forward direction of the character. \n\nIf the character is ordered to move in the opposite direction from where it is facing then enabling this will cause it to make a small loop instead of turning on the spot.\n\nThis setting only has an effect if slowWhenNotFacingTarget is enabled.
Pathfinding.AIPath.radius	aipath.html#radius	Radius of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nNote that this does not affect pathfinding in any way. The graph used completely determines where the agent can move.\n\n[more in online documentation]
Pathfinding.AIPath.reachedDestination	aipath.html#reachedDestination	True if the ai has reached the destination. \n\nThis is a best effort calculation to see if the destination has been reached. For the AIPath/RichAI scripts, this is when the character is within AIPath.endReachedDistance world units from the destination. For the AILerp script it is when the character is at the destination (±a very small margin).\n\nThis value will be updated immediately when the destination is changed (in contrast to reachedEndOfPath), however since path requests are asynchronous it will use an approximation until it sees the real path result. What this property does is to check the distance to the end of the current path, and add to that the distance from the end of the path to the destination (i.e. is assumes it is possible to move in a straight line between the end of the current path to the destination) and then checks if that total distance is less than AIPath.endReachedDistance. This property is therefore only a best effort, but it will work well for almost all use cases.\n\nFurthermore it will not report that the destination is reached if the destination is above the head of the character or more than half the height of the character below its feet (so if you have a multilevel building, it is important that you configure the height of the character correctly).\n\nThe cases which could be problematic are if an agent is standing next to a very thin wall and the destination suddenly changes to the other side of that thin wall. During the time that it takes for the path to be calculated the agent may see itself as alredy having reached the destination because the destination only moved a very small distance (the wall was thin), even though it may actually be quite a long way around the wall to the other side.\n\nIn contrast to reachedEndOfPath, this property is immediately updated when the destination is changed.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.AIPath.reachedEndOfPath	aipath.html#reachedEndOfPath	True if the agent has reached the end of the current path. \n\nNote that setting the destination does not immediately update the path, nor is there any guarantee that the AI will actually be able to reach the destination that you set. The AI will try to get as close as possible. Often you want to use reachedDestination instead which is easier to work with.\n\nIt is very hard to provide a method for detecting if the AI has reached the destination that works across all different games because the destination may not even lie on the navmesh and how that is handled differs from game to game (see also the code snippet in the docs for destination).\n\n[more in online documentation]
Pathfinding.AIPath.remainingDistance	aipath.html#remainingDistance	Approximate remaining distance along the current path to the end of the path. \n\nThe RichAI movement script approximates this distance since it is quite expensive to calculate the real distance. However it will be accurate when the agent is within 1 corner of the destination. You can use GetRemainingPath to calculate the actual remaining path more precisely.\n\nThe AIPath and AILerp scripts use a more accurate distance calculation at all times.\n\nIf the agent does not currently have a path, then positive infinity will be returned.\n\n[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.AIPath.rotationFilterState	aipath.html#rotationFilterState	
Pathfinding.AIPath.rotationFilterState2	aipath.html#rotationFilterState2	
Pathfinding.AIPath.rotationSpeed	aipath.html#rotationSpeed	Rotation speed in degrees per second. \n\nRotation is calculated using Quaternion.RotateTowards. This variable represents the rotation speed in degrees per second. The higher it is, the faster the character will be able to rotate.
Pathfinding.AIPath.slowWhenNotFacingTarget	aipath.html#slowWhenNotFacingTarget	Slow down when not facing the target direction. \n\nIncurs at a small performance overhead.\n\nThis setting only has an effect if enableRotation is enabled.
Pathfinding.AIPath.slowdownDistance	aipath.html#slowdownDistance	Distance from the end of the path where the AI will start to slow down.
Pathfinding.AIPath.steeringTarget	aipath.html#steeringTarget	Point on the path which the agent is currently moving towards. \n\nThis is usually a point a small distance ahead of the agent or the end of the path.\n\nIf the agent does not have a path at the moment, then the agent's current position will be returned.
Pathfinding.AIPathAlignedToSurface.scratchDictionary	aipathalignedtosurface.html#scratchDictionary	Scratch dictionary used to avoid allocations every frame.
Pathfinding.AdvancedSmooth.ConstantTurn.circleCenter	constantturn.html#circleCenter	
Pathfinding.AdvancedSmooth.ConstantTurn.clockwise	constantturn.html#clockwise	
Pathfinding.AdvancedSmooth.ConstantTurn.gamma1	constantturn.html#gamma1	
Pathfinding.AdvancedSmooth.ConstantTurn.gamma2	constantturn.html#gamma2	
Pathfinding.AdvancedSmooth.MaxTurn.alfaLeftLeft	maxturn.html#alfaLeftLeft	
Pathfinding.AdvancedSmooth.MaxTurn.alfaLeftRight	maxturn.html#alfaLeftRight	
Pathfinding.AdvancedSmooth.MaxTurn.alfaRightLeft	maxturn.html#alfaRightLeft	
Pathfinding.AdvancedSmooth.MaxTurn.alfaRightRight	maxturn.html#alfaRightRight	
Pathfinding.AdvancedSmooth.MaxTurn.betaLeftLeft	maxturn.html#betaLeftLeft	
Pathfinding.AdvancedSmooth.MaxTurn.betaLeftRight	maxturn.html#betaLeftRight	
Pathfinding.AdvancedSmooth.MaxTurn.betaRightLeft	maxturn.html#betaRightLeft	
Pathfinding.AdvancedSmooth.MaxTurn.betaRightRight	maxturn.html#betaRightRight	
Pathfinding.AdvancedSmooth.MaxTurn.deltaLeftRight	maxturn.html#deltaLeftRight	
Pathfinding.AdvancedSmooth.MaxTurn.deltaRightLeft	maxturn.html#deltaRightLeft	
Pathfinding.AdvancedSmooth.MaxTurn.gammaLeft	maxturn.html#gammaLeft	
Pathfinding.AdvancedSmooth.MaxTurn.gammaRight	maxturn.html#gammaRight	
Pathfinding.AdvancedSmooth.MaxTurn.leftCircleCenter	maxturn.html#leftCircleCenter	
Pathfinding.AdvancedSmooth.MaxTurn.preLeftCircleCenter	maxturn.html#preLeftCircleCenter	
Pathfinding.AdvancedSmooth.MaxTurn.preRightCircleCenter	maxturn.html#preRightCircleCenter	
Pathfinding.AdvancedSmooth.MaxTurn.preVaLeft	maxturn.html#preVaLeft	
Pathfinding.AdvancedSmooth.MaxTurn.preVaRight	maxturn.html#preVaRight	
Pathfinding.AdvancedSmooth.MaxTurn.rightCircleCenter	maxturn.html#rightCircleCenter	
Pathfinding.AdvancedSmooth.MaxTurn.vaLeft	maxturn.html#vaLeft	
Pathfinding.AdvancedSmooth.MaxTurn.vaRight	maxturn.html#vaRight	
Pathfinding.AdvancedSmooth.Order	advancedsmooth.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.AdvancedSmooth.Turn.constructor	turn.html#constructor	
Pathfinding.AdvancedSmooth.Turn.id	turn.html#id	
Pathfinding.AdvancedSmooth.Turn.length	turn.html#length	
Pathfinding.AdvancedSmooth.Turn.score	turn.html#score	
Pathfinding.AdvancedSmooth.TurnConstructor.ThreeSixtyRadians	turnconstructor.html#ThreeSixtyRadians	
Pathfinding.AdvancedSmooth.TurnConstructor.changedPreviousTangent	turnconstructor.html#changedPreviousTangent	
Pathfinding.AdvancedSmooth.TurnConstructor.constantBias	turnconstructor.html#constantBias	Constant bias to add to the path lengths. \n\nThis can be used to favor certain turn types before others.\n\nBy for example setting this to -5, paths from this path constructor will be chosen if there are no other paths more than 5 world units shorter than this one (as opposed to just any shorter path)
Pathfinding.AdvancedSmooth.TurnConstructor.current	turnconstructor.html#current	
Pathfinding.AdvancedSmooth.TurnConstructor.factorBias	turnconstructor.html#factorBias	Bias to multiply the path lengths with. \n\nThis can be used to favor certain turn types before others. \n\n[more in online documentation]
Pathfinding.AdvancedSmooth.TurnConstructor.next	turnconstructor.html#next	
Pathfinding.AdvancedSmooth.TurnConstructor.normal	turnconstructor.html#normal	
Pathfinding.AdvancedSmooth.TurnConstructor.prev	turnconstructor.html#prev	
Pathfinding.AdvancedSmooth.TurnConstructor.prevNormal	turnconstructor.html#prevNormal	
Pathfinding.AdvancedSmooth.TurnConstructor.t1	turnconstructor.html#t1	
Pathfinding.AdvancedSmooth.TurnConstructor.t2	turnconstructor.html#t2	
Pathfinding.AdvancedSmooth.TurnConstructor.turningRadius	turnconstructor.html#turningRadius	
Pathfinding.AdvancedSmooth.turnConstruct1	advancedsmooth.html#turnConstruct1	
Pathfinding.AdvancedSmooth.turnConstruct2	advancedsmooth.html#turnConstruct2	
Pathfinding.AdvancedSmooth.turningRadius	advancedsmooth.html#turningRadius	
Pathfinding.AlternativePath.Order	alternativepath.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.AlternativePath.destroyed	alternativepath.html#destroyed	
Pathfinding.AlternativePath.penalty	alternativepath.html#penalty	How much penalty (weight) to apply to nodes.
Pathfinding.AlternativePath.prevNodes	alternativepath.html#prevNodes	The previous path.
Pathfinding.AlternativePath.prevPenalty	alternativepath.html#prevPenalty	The previous penalty used. \n\nStored just in case it changes during operation
Pathfinding.AlternativePath.randomStep	alternativepath.html#randomStep	Max number of nodes to skip in a row.
Pathfinding.AlternativePath.rnd	alternativepath.html#rnd	A random object.
Pathfinding.AnimationLink.LinkClip.clip	linkclip.html#clip	
Pathfinding.AnimationLink.LinkClip.loopCount	linkclip.html#loopCount	
Pathfinding.AnimationLink.LinkClip.name	linkclip.html#name	
Pathfinding.AnimationLink.LinkClip.velocity	linkclip.html#velocity	
Pathfinding.AnimationLink.animSpeed	animationlink.html#animSpeed	
Pathfinding.AnimationLink.boneRoot	animationlink.html#boneRoot	
Pathfinding.AnimationLink.clip	animationlink.html#clip	
Pathfinding.AnimationLink.referenceMesh	animationlink.html#referenceMesh	
Pathfinding.AnimationLink.reverseAnim	animationlink.html#reverseAnim	
Pathfinding.AnimationLink.sequence	animationlink.html#sequence	
Pathfinding.AstarColor.AreaColors	astarcolor.html#AreaColors	
Pathfinding.AstarColor.BoundsHandles	astarcolor.html#BoundsHandles	
Pathfinding.AstarColor.ConnectionHighLerp	astarcolor.html#ConnectionHighLerp	
Pathfinding.AstarColor.ConnectionLowLerp	astarcolor.html#ConnectionLowLerp	
Pathfinding.AstarColor.MeshEdgeColor	astarcolor.html#MeshEdgeColor	
Pathfinding.AstarColor.SolidColor	astarcolor.html#SolidColor	
Pathfinding.AstarColor.UnwalkableNode	astarcolor.html#UnwalkableNode	
Pathfinding.AstarColor._AreaColors	astarcolor.html#_AreaColors	Holds user set area colors. \n\nUse GetAreaColor to get an area color
Pathfinding.AstarColor._BoundsHandles	astarcolor.html#_BoundsHandles	
Pathfinding.AstarColor._ConnectionHighLerp	astarcolor.html#_ConnectionHighLerp	
Pathfinding.AstarColor._ConnectionLowLerp	astarcolor.html#_ConnectionLowLerp	
Pathfinding.AstarColor._MeshEdgeColor	astarcolor.html#_MeshEdgeColor	
Pathfinding.AstarColor._SolidColor	astarcolor.html#_SolidColor	
Pathfinding.AstarColor._UnwalkableNode	astarcolor.html#_UnwalkableNode	
Pathfinding.AstarData.MarkerDeserializeGraphs	astardata.html#MarkerDeserializeGraphs	
Pathfinding.AstarData.MarkerFindGraphTypes	astardata.html#MarkerFindGraphTypes	
Pathfinding.AstarData.MarkerLoadFromCache	astardata.html#MarkerLoadFromCache	
Pathfinding.AstarData.MarkerSerializeGraphs	astardata.html#MarkerSerializeGraphs	
Pathfinding.AstarData.active	astardata.html#active	The AstarPath component which owns this AstarData.
Pathfinding.AstarData.cacheStartup	astardata.html#cacheStartup	Should graph-data be cached. \n\nCaching the startup means saving the whole graphs - not only the settings - to a file (file_cachedStartup) which can be loaded when the game starts. This is usually much faster than scanning the graphs when the game starts. This is configured from the editor under the "Save &amp; Load" tab.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.AstarData.data	astardata.html#data	Serialized data for all graphs and settings.
Pathfinding.AstarData.dataString	astardata.html#dataString	Serialized data for all graphs and settings. \n\nStored as a base64 encoded string because otherwise Unity's Undo system would sometimes corrupt the byte data (because it only stores deltas).\n\nThis can be accessed as a byte array from the data property.
Pathfinding.AstarData.file_cachedStartup	astardata.html#file_cachedStartup	Serialized data for cached startup. \n\nIf set, and cacheStartup is enabled, graphs will be deserialized from this file when the game starts.\n\n <b>[image in online documentation]</b>
Pathfinding.AstarData.graphStructureLocked	astardata.html#graphStructureLocked	
Pathfinding.AstarData.graphTypes	astardata.html#graphTypes	All supported graph types. \n\nPopulated through reflection search
Pathfinding.AstarData.graphs	astardata.html#graphs	All graphs. \n\nThis will be filled only after deserialization has completed. May contain null entries if graph have been removed.
Pathfinding.AstarData.gridGraph	astardata.html#gridGraph	Shortcut to the first GridGraph.
Pathfinding.AstarData.layerGridGraph	astardata.html#layerGridGraph	Shortcut to the first LayerGridGraph. \n\n  [more in online documentation]
Pathfinding.AstarData.linkGraph	astardata.html#linkGraph	Shortcut to the first LinkGraph.
Pathfinding.AstarData.navmesh	astardata.html#navmesh	Shortcut to the first NavMeshGraph. \n\n[more in online documentation]
Pathfinding.AstarData.navmeshGraph	astardata.html#navmeshGraph	Shortcut to the first NavMeshGraph.
Pathfinding.AstarData.pointGraph	astardata.html#pointGraph	Shortcut to the first PointGraph.
Pathfinding.AstarData.recastGraph	astardata.html#recastGraph	Shortcut to the first RecastGraph. \n\n  [more in online documentation]
Pathfinding.AstarDebugger.GraphPoint.collectEvent	graphpoint.html#collectEvent	
Pathfinding.AstarDebugger.GraphPoint.fps	graphpoint.html#fps	
Pathfinding.AstarDebugger.GraphPoint.memory	graphpoint.html#memory	
Pathfinding.AstarDebugger.PathTypeDebug.getSize	pathtypedebug.html#getSize	
Pathfinding.AstarDebugger.PathTypeDebug.getTotalCreated	pathtypedebug.html#getTotalCreated	
Pathfinding.AstarDebugger.PathTypeDebug.name	pathtypedebug.html#name	
Pathfinding.AstarDebugger.allocMem	astardebugger.html#allocMem	
Pathfinding.AstarDebugger.allocRate	astardebugger.html#allocRate	
Pathfinding.AstarDebugger.boxRect	astardebugger.html#boxRect	
Pathfinding.AstarDebugger.cachedText	astardebugger.html#cachedText	
Pathfinding.AstarDebugger.cam	astardebugger.html#cam	
Pathfinding.AstarDebugger.collectAlloc	astardebugger.html#collectAlloc	
Pathfinding.AstarDebugger.debugTypes	astardebugger.html#debugTypes	
Pathfinding.AstarDebugger.delayedDeltaTime	astardebugger.html#delayedDeltaTime	
Pathfinding.AstarDebugger.delta	astardebugger.html#delta	
Pathfinding.AstarDebugger.font	astardebugger.html#font	Font to use. \n\nA monospaced font is the best
Pathfinding.AstarDebugger.fontSize	astardebugger.html#fontSize	
Pathfinding.AstarDebugger.fpsDropCounterSize	astardebugger.html#fpsDropCounterSize	
Pathfinding.AstarDebugger.fpsDrops	astardebugger.html#fpsDrops	
Pathfinding.AstarDebugger.graph	astardebugger.html#graph	
Pathfinding.AstarDebugger.graphBufferSize	astardebugger.html#graphBufferSize	
Pathfinding.AstarDebugger.graphHeight	astardebugger.html#graphHeight	
Pathfinding.AstarDebugger.graphOffset	astardebugger.html#graphOffset	
Pathfinding.AstarDebugger.graphWidth	astardebugger.html#graphWidth	
Pathfinding.AstarDebugger.lastAllocMemory	astardebugger.html#lastAllocMemory	
Pathfinding.AstarDebugger.lastAllocSet	astardebugger.html#lastAllocSet	
Pathfinding.AstarDebugger.lastCollect	astardebugger.html#lastCollect	
Pathfinding.AstarDebugger.lastCollectNum	astardebugger.html#lastCollectNum	
Pathfinding.AstarDebugger.lastDeltaTime	astardebugger.html#lastDeltaTime	
Pathfinding.AstarDebugger.lastUpdate	astardebugger.html#lastUpdate	
Pathfinding.AstarDebugger.maxNodePool	astardebugger.html#maxNodePool	
Pathfinding.AstarDebugger.maxVecPool	astardebugger.html#maxVecPool	
Pathfinding.AstarDebugger.peakAlloc	astardebugger.html#peakAlloc	
Pathfinding.AstarDebugger.show	astardebugger.html#show	
Pathfinding.AstarDebugger.showFPS	astardebugger.html#showFPS	
Pathfinding.AstarDebugger.showGraph	astardebugger.html#showGraph	
Pathfinding.AstarDebugger.showInEditor	astardebugger.html#showInEditor	
Pathfinding.AstarDebugger.showMemProfile	astardebugger.html#showMemProfile	
Pathfinding.AstarDebugger.showPathProfile	astardebugger.html#showPathProfile	
Pathfinding.AstarDebugger.style	astardebugger.html#style	
Pathfinding.AstarDebugger.text	astardebugger.html#text	
Pathfinding.AstarDebugger.yOffset	astardebugger.html#yOffset	
Pathfinding.AstarMath.GlobalRandom	astarmath.html#GlobalRandom	
Pathfinding.AstarMath.GlobalRandomLock	astarmath.html#GlobalRandomLock	
Pathfinding.AstarPathEditor.aboutArea	astarpatheditor.html#aboutArea	
Pathfinding.AstarPathEditor.addGraphsArea	astarpatheditor.html#addGraphsArea	
Pathfinding.AstarPathEditor.alwaysVisibleArea	astarpatheditor.html#alwaysVisibleArea	
Pathfinding.AstarPathEditor.astarSkin	astarpatheditor.html#astarSkin	
Pathfinding.AstarPathEditor.colorSettingsArea	astarpatheditor.html#colorSettingsArea	
Pathfinding.AstarPathEditor.defines	astarpatheditor.html#defines	Holds defines found in script files, used for optimizations. \n\n  [more in online documentation]
Pathfinding.AstarPathEditor.editorSettingsArea	astarpatheditor.html#editorSettingsArea	
Pathfinding.AstarPathEditor.graphDeleteButtonStyle	astarpatheditor.html#graphDeleteButtonStyle	
Pathfinding.AstarPathEditor.graphDuplicateButtonStyle	astarpatheditor.html#graphDuplicateButtonStyle	
Pathfinding.AstarPathEditor.graphEditNameButtonStyle	astarpatheditor.html#graphEditNameButtonStyle	
Pathfinding.AstarPathEditor.graphEditorTypes	astarpatheditor.html#graphEditorTypes	List of all graph editors available (e.g GridGraphEditor)
Pathfinding.AstarPathEditor.graphEditors	astarpatheditor.html#graphEditors	List of all graph editors for the graphs. \n\nMay be larger than script.data.graphs.Length
Pathfinding.AstarPathEditor.graphGizmoButtonStyle	astarpatheditor.html#graphGizmoButtonStyle	
Pathfinding.AstarPathEditor.graphInfoButtonStyle	astarpatheditor.html#graphInfoButtonStyle	
Pathfinding.AstarPathEditor.graphNameFocused	astarpatheditor.html#graphNameFocused	Graph editor which has its 'name' field focused.
Pathfinding.AstarPathEditor.graphNodeCounts	astarpatheditor.html#graphNodeCounts	Holds node counts for each graph to avoid calculating it every frame. \n\nOnly used for visualization purposes
Pathfinding.AstarPathEditor.graphTypes	astarpatheditor.html#graphTypes	
Pathfinding.AstarPathEditor.graphsArea	astarpatheditor.html#graphsArea	
Pathfinding.AstarPathEditor.helpBox	astarpatheditor.html#helpBox	
Pathfinding.AstarPathEditor.heuristicOptimizationOptions	astarpatheditor.html#heuristicOptimizationOptions	
Pathfinding.AstarPathEditor.ignoredChecksum	astarpatheditor.html#ignoredChecksum	Used to make sure correct behaviour when handling undos.
Pathfinding.AstarPathEditor.isPrefab	astarpatheditor.html#isPrefab	
Pathfinding.AstarPathEditor.lastUndoGroup	astarpatheditor.html#lastUndoGroup	
Pathfinding.AstarPathEditor.level0AreaStyle	astarpatheditor.html#level0AreaStyle	
Pathfinding.AstarPathEditor.level0LabelStyle	astarpatheditor.html#level0LabelStyle	
Pathfinding.AstarPathEditor.level1AreaStyle	astarpatheditor.html#level1AreaStyle	
Pathfinding.AstarPathEditor.level1LabelStyle	astarpatheditor.html#level1LabelStyle	
Pathfinding.AstarPathEditor.optimizationSettingsArea	astarpatheditor.html#optimizationSettingsArea	
Pathfinding.AstarPathEditor.script	astarpatheditor.html#script	AstarPath instance that is being inspected.
Pathfinding.AstarPathEditor.scriptsFolder	astarpatheditor.html#scriptsFolder	
Pathfinding.AstarPathEditor.serializationSettingsArea	astarpatheditor.html#serializationSettingsArea	
Pathfinding.AstarPathEditor.settingsArea	astarpatheditor.html#settingsArea	
Pathfinding.AstarPathEditor.showCustomAreaColors	astarpatheditor.html#showCustomAreaColors	
Pathfinding.AstarPathEditor.showSettings	astarpatheditor.html#showSettings	
Pathfinding.AstarPathEditor.showTagNames	astarpatheditor.html#showTagNames	
Pathfinding.AstarPathEditor.stylesLoaded	astarpatheditor.html#stylesLoaded	
Pathfinding.AstarPathEditor.tagsArea	astarpatheditor.html#tagsArea	
Pathfinding.AstarPathEditor.thinHelpBox	astarpatheditor.html#thinHelpBox	
Pathfinding.AstarUpdateChecker._lastUpdateCheck	astarupdatechecker.html#_lastUpdateCheck	
Pathfinding.AstarUpdateChecker._lastUpdateCheckRead	astarupdatechecker.html#_lastUpdateCheckRead	
Pathfinding.AstarUpdateChecker._latestBetaVersion	astarupdatechecker.html#_latestBetaVersion	
Pathfinding.AstarUpdateChecker._latestVersion	astarupdatechecker.html#_latestVersion	
Pathfinding.AstarUpdateChecker._latestVersionDescription	astarupdatechecker.html#_latestVersionDescription	Description of the latest update of the A* Pathfinding Project.
Pathfinding.AstarUpdateChecker.astarServerData	astarupdatechecker.html#astarServerData	Holds various URLs and text for the editor. \n\nThis info can be updated when a check for new versions is done to ensure that there are no invalid links.
Pathfinding.AstarUpdateChecker.hasParsedServerMessage	astarupdatechecker.html#hasParsedServerMessage	
Pathfinding.AstarUpdateChecker.lastUpdateCheck	astarupdatechecker.html#lastUpdateCheck	Last time an update check was made.
Pathfinding.AstarUpdateChecker.latestBetaVersion	astarupdatechecker.html#latestBetaVersion	Latest beta version of the A* Pathfinding Project.
Pathfinding.AstarUpdateChecker.latestVersion	astarupdatechecker.html#latestVersion	Latest version of the A* Pathfinding Project.
Pathfinding.AstarUpdateChecker.latestVersionDescription	astarupdatechecker.html#latestVersionDescription	Summary of the latest update.
Pathfinding.AstarUpdateChecker.updateCheckDownload	astarupdatechecker.html#updateCheckDownload	Used for downloading new version information.
Pathfinding.AstarUpdateChecker.updateCheckRate	astarupdatechecker.html#updateCheckRate	Number of days between update checks.
Pathfinding.AstarUpdateChecker.updateURL	astarupdatechecker.html#updateURL	URL to the version file containing the latest version number.
Pathfinding.AstarUpdateWindow.largeStyle	astarupdatewindow.html#largeStyle	
Pathfinding.AstarUpdateWindow.normalStyle	astarupdatewindow.html#normalStyle	
Pathfinding.AstarUpdateWindow.setReminder	astarupdatewindow.html#setReminder	
Pathfinding.AstarUpdateWindow.summary	astarupdatewindow.html#summary	
Pathfinding.AstarUpdateWindow.version	astarupdatewindow.html#version	
Pathfinding.AstarWorkItem.init	astarworkitem.html#init	Init function. \n\nMay be null if no initialization is needed. Will be called once, right before the first call to update or updateWithContext.
Pathfinding.AstarWorkItem.initWithContext	astarworkitem.html#initWithContext	Init function. \n\nMay be null if no initialization is needed. Will be called once, right before the first call to update or updateWithContext.\n\nA context object is sent as a parameter. This can be used to for example queue a flood fill that will be executed either when a work item calls EnsureValidFloodFill or all work items have been completed. If multiple work items are updating nodes so that they need a flood fill afterwards, using the QueueFloodFill method is preferred since then only a single flood fill needs to be performed for all of the work items instead of one per work item.
Pathfinding.AstarWorkItem.update	astarworkitem.html#update	Update function, called once per frame when the work item executes. \n\nTakes a param <b>force</b>. If that is true, the work item should try to complete the whole item in one go instead of spreading it out over multiple frames.\n\n[more in online documentation]
Pathfinding.AstarWorkItem.updateWithContext	astarworkitem.html#updateWithContext	Update function, called once per frame when the work item executes. \n\nTakes a param <b>force</b>. If that is true, the work item should try to complete the whole item in one go instead of spreading it out over multiple frames. \n\n[more in online documentation]\n\n\nA context object is sent as a parameter. This can be used to for example queue a flood fill that will be executed either when a work item calls EnsureValidFloodFill or all work items have been completed. If multiple work items are updating nodes so that they need a flood fill afterwards, using the QueueFloodFill method is preferred since then only a single flood fill needs to be performed for all of the work items instead of one per work item.
Pathfinding.AutoRepathPolicy.Mode	autorepathpolicy2.html#Mode	Policy mode for how often to recalculate an agent's path.
Pathfinding.AutoRepathPolicy.lastDestination	autorepathpolicy2.html#lastDestination	
Pathfinding.AutoRepathPolicy.lastRepathTime	autorepathpolicy2.html#lastRepathTime	
Pathfinding.AutoRepathPolicy.maximumPeriod	autorepathpolicy2.html#maximumPeriod	Maximum number of seconds between each automatic path recalculation for Mode.Dynamic.
Pathfinding.AutoRepathPolicy.mode	autorepathpolicy2.html#mode	Policy to use when recalculating paths. \n\n[more in online documentation]
Pathfinding.AutoRepathPolicy.period	autorepathpolicy2.html#period	Number of seconds between each automatic path recalculation for Mode.EveryNSeconds.
Pathfinding.AutoRepathPolicy.sensitivity	autorepathpolicy2.html#sensitivity	How sensitive the agent should be to changes in its destination for Mode.Dynamic. \n\nA higher value means the destination has to move less for the path to be recalculated.\n\n[more in online documentation]
Pathfinding.AutoRepathPolicy.visualizeSensitivity	autorepathpolicy2.html#visualizeSensitivity	If true the sensitivity will be visualized as a circle in the scene view when the game is playing.
Pathfinding.BaseAIEditor.debug	baseaieditor.html#debug	
Pathfinding.BaseAIEditor.lastSeenCustomGravity	baseaieditor.html#lastSeenCustomGravity	
Pathfinding.BinaryHeap.D	binaryheap.html#D	Number of children of each node in the tree. \n\nDifferent values have been tested and 4 has been empirically found to perform the best. \n\n[more in online documentation]
Pathfinding.BinaryHeap.GrowthFactor	binaryheap.html#GrowthFactor	The tree will grow by at least this factor every time it is expanded.
Pathfinding.BinaryHeap.HeapNode.F	heapnode.html#F	
Pathfinding.BinaryHeap.HeapNode.TieBreaker	heapnode.html#TieBreaker	
Pathfinding.BinaryHeap.HeapNode.pathNodeIndex	heapnode.html#pathNodeIndex	
Pathfinding.BinaryHeap.HeapNode.sortKey	heapnode.html#sortKey	Bitpacked F and G scores.
Pathfinding.BinaryHeap.NotInHeap	binaryheap.html#NotInHeap	
Pathfinding.BinaryHeap.TieBreaking	binaryheap.html#TieBreaking	
Pathfinding.BinaryHeap.heap	binaryheap.html#heap	Internal backing array for the heap.
Pathfinding.BinaryHeap.insertionOrder	binaryheap.html#insertionOrder	
Pathfinding.BinaryHeap.isEmpty	binaryheap.html#isEmpty	True if the heap does not contain any elements.
Pathfinding.BinaryHeap.numberOfItems	binaryheap.html#numberOfItems	Number of items in the tree.
Pathfinding.BinaryHeap.tieBreaking	binaryheap.html#tieBreaking	Ties between elements that have the same F score can be broken by the H score or by insertion order.
Pathfinding.BlockManager.BlockMode	blockmanager.html#BlockMode	
Pathfinding.BlockManager.TraversalProvider.blockManager	traversalprovider.html#blockManager	Holds information about which nodes are occupied.
Pathfinding.BlockManager.TraversalProvider.filterDiagonalGridConnections	traversalprovider.html#filterDiagonalGridConnections	Filter diagonal connections using GridGraph.cutCorners for effects applied by this ITraversalProvider. \n\nThis includes tags and other effects that this ITraversalProvider controls.\n\nThis only has an effect if GridGraph.cutCorners is set to false and your grid has GridGraph.neighbours set to Eight.\n\nTake this example, the grid is completely walkable, but an ITraversalProvider is used to make the nodes marked with '#' as unwalkable. The agent 'S' is in the middle.\n\n<b>[code in online documentation]</b>\n\nIf <b>filterDiagonalGridConnections</b> is false the agent will be free to use the diagonal connections to move away from that spot. However, if <b>filterDiagonalGridConnections</b> is true (the default) then the diagonal connections will be disabled and the agent will be stuck.\n\nTypically, there are a few common use cases:\n- If your ITraversalProvider makes walls and obstacles and you want it to behave identically to obstacles included in the original grid graph scan, then this should be true.\n\n- If your ITraversalProvider is used for agent to agent avoidance and you want them to be able to move around each other more freely, then this should be false.\n\n\n\n[more in online documentation]
Pathfinding.BlockManager.TraversalProvider.mode	traversalprovider.html#mode	Affects which nodes are considered blocked.
Pathfinding.BlockManager.TraversalProvider.selector	traversalprovider.html#selector	Blockers for this path. \n\nThe effect depends on mode.\n\nNote that having a large selector has a performance cost.\n\n[more in online documentation]
Pathfinding.BlockManager.blocked	blockmanager.html#blocked	Contains info on which SingleNodeBlocker objects have blocked a particular node.
Pathfinding.CloseToDestinationMode	pathfinding.html#CloseToDestinationMode	What to do when the character is close to the destination.
Pathfinding.Collections.AABBTree.AABBComparer.dim	aabbcomparer.html#dim	
Pathfinding.Collections.AABBTree.AABBComparer.nodes	aabbcomparer.html#nodes	
Pathfinding.Collections.AABBTree.Key.isValid	key.html#isValid	
Pathfinding.Collections.AABBTree.Key.node	key.html#node	
Pathfinding.Collections.AABBTree.Key.value	key.html#value	
Pathfinding.Collections.AABBTree.NoNode	aabbtree.html#NoNode	
Pathfinding.Collections.AABBTree.Node.AllocatedBit	node2.html#AllocatedBit	
Pathfinding.Collections.AABBTree.Node.InvalidParent	node2.html#InvalidParent	
Pathfinding.Collections.AABBTree.Node.ParentMask	node2.html#ParentMask	
Pathfinding.Collections.AABBTree.Node.TagInsideBit	node2.html#TagInsideBit	
Pathfinding.Collections.AABBTree.Node.TagPartiallyInsideBit	node2.html#TagPartiallyInsideBit	
Pathfinding.Collections.AABBTree.Node.bounds	node2.html#bounds	
Pathfinding.Collections.AABBTree.Node.flags	node2.html#flags	
Pathfinding.Collections.AABBTree.Node.isAllocated	node2.html#isAllocated	
Pathfinding.Collections.AABBTree.Node.isLeaf	node2.html#isLeaf	
Pathfinding.Collections.AABBTree.Node.left	node2.html#left	
Pathfinding.Collections.AABBTree.Node.parent	node2.html#parent	
Pathfinding.Collections.AABBTree.Node.right	node2.html#right	
Pathfinding.Collections.AABBTree.Node.subtreePartiallyTagged	node2.html#subtreePartiallyTagged	
Pathfinding.Collections.AABBTree.Node.value	node2.html#value	
Pathfinding.Collections.AABBTree.Node.wholeSubtreeTagged	node2.html#wholeSubtreeTagged	
Pathfinding.Collections.AABBTree.freeNodes	aabbtree.html#freeNodes	
Pathfinding.Collections.AABBTree.nodes	aabbtree.html#nodes	
Pathfinding.Collections.AABBTree.rebuildCounter	aabbtree.html#rebuildCounter	
Pathfinding.Collections.AABBTree.root	aabbtree.html#root	
Pathfinding.Collections.AABBTree.this[Key key]	aabbtree.html#thisKeykey	User data for a node in the tree.
Pathfinding.Collections.BBTree.BBTreeBox.IsLeaf	bbtreebox.html#IsLeaf	
Pathfinding.Collections.BBTree.BBTreeBox.left	bbtreebox.html#left	
Pathfinding.Collections.BBTree.BBTreeBox.nodeOffset	bbtreebox.html#nodeOffset	
Pathfinding.Collections.BBTree.BBTreeBox.rect	bbtreebox.html#rect	
Pathfinding.Collections.BBTree.BBTreeBox.right	bbtreebox.html#right	
Pathfinding.Collections.BBTree.CloseNode.closestPointOnNode	closenode.html#closestPointOnNode	
Pathfinding.Collections.BBTree.CloseNode.distanceSq	closenode.html#distanceSq	
Pathfinding.Collections.BBTree.CloseNode.node	closenode.html#node	
Pathfinding.Collections.BBTree.CloseNode.tieBreakingDistance	closenode.html#tieBreakingDistance	
Pathfinding.Collections.BBTree.DistanceMetric	bbtree.html#DistanceMetric	
Pathfinding.Collections.BBTree.MAX_TREE_HEIGHT	bbtree.html#MAX_TREE_HEIGHT	
Pathfinding.Collections.BBTree.MaximumLeafSize	bbtree.html#MaximumLeafSize	
Pathfinding.Collections.BBTree.NearbyNodesIterator.BoxWithDist.distSqr	boxwithdist.html#distSqr	
Pathfinding.Collections.BBTree.NearbyNodesIterator.BoxWithDist.index	boxwithdist.html#index	
Pathfinding.Collections.BBTree.NearbyNodesIterator.Current	nearbynodesiterator.html#Current	
Pathfinding.Collections.BBTree.NearbyNodesIterator.current	nearbynodesiterator.html#current	
Pathfinding.Collections.BBTree.NearbyNodesIterator.distanceThresholdSqr	nearbynodesiterator.html#distanceThresholdSqr	
Pathfinding.Collections.BBTree.NearbyNodesIterator.indexInLeaf	nearbynodesiterator.html#indexInLeaf	
Pathfinding.Collections.BBTree.NearbyNodesIterator.nodes	nearbynodesiterator.html#nodes	
Pathfinding.Collections.BBTree.NearbyNodesIterator.point	nearbynodesiterator.html#point	
Pathfinding.Collections.BBTree.NearbyNodesIterator.projection	nearbynodesiterator.html#projection	
Pathfinding.Collections.BBTree.NearbyNodesIterator.stack	nearbynodesiterator.html#stack	
Pathfinding.Collections.BBTree.NearbyNodesIterator.stackSize	nearbynodesiterator.html#stackSize	
Pathfinding.Collections.BBTree.NearbyNodesIterator.tieBreakingDistanceThreshold	nearbynodesiterator.html#tieBreakingDistanceThreshold	
Pathfinding.Collections.BBTree.NearbyNodesIterator.tree	nearbynodesiterator.html#tree	
Pathfinding.Collections.BBTree.NearbyNodesIterator.triangles	nearbynodesiterator.html#triangles	
Pathfinding.Collections.BBTree.NearbyNodesIterator.vertices	nearbynodesiterator.html#vertices	
Pathfinding.Collections.BBTree.ProjectionParams.alignedWithXZPlane	projectionparams.html#alignedWithXZPlane	
Pathfinding.Collections.BBTree.ProjectionParams.alignedWithXZPlaneBacking	projectionparams.html#alignedWithXZPlaneBacking	
Pathfinding.Collections.BBTree.ProjectionParams.distanceMetric	projectionparams.html#distanceMetric	
Pathfinding.Collections.BBTree.ProjectionParams.distanceScaleAlongProjectionAxis	projectionparams.html#distanceScaleAlongProjectionAxis	
Pathfinding.Collections.BBTree.ProjectionParams.planeProjection	projectionparams.html#planeProjection	
Pathfinding.Collections.BBTree.ProjectionParams.projectedUpNormalized	projectionparams.html#projectedUpNormalized	
Pathfinding.Collections.BBTree.ProjectionParams.projectionAxis	projectionparams.html#projectionAxis	
Pathfinding.Collections.BBTree.Size	bbtree.html#Size	
Pathfinding.Collections.BBTree.nodePermutation	bbtree.html#nodePermutation	
Pathfinding.Collections.BBTree.tree	bbtree.html#tree	Holds all tree nodes.
Pathfinding.Collections.CircularBuffer.AbsoluteEndIndex	circularbuffer.html#AbsoluteEndIndex	Absolute index of the last item in the buffer, may be negative or greater than Length.
Pathfinding.Collections.CircularBuffer.AbsoluteStartIndex	circularbuffer.html#AbsoluteStartIndex	Absolute index of the first item in the buffer, may be negative or greater than Length.
Pathfinding.Collections.CircularBuffer.Count	circularbuffer.html#Count	
Pathfinding.Collections.CircularBuffer.First	circularbuffer.html#First	First item in the buffer, throws if the buffer is empty.
Pathfinding.Collections.CircularBuffer.Last	circularbuffer.html#Last	Last item in the buffer, throws if the buffer is empty.
Pathfinding.Collections.CircularBuffer.Length	circularbuffer.html#Length	Number of items in the buffer.
Pathfinding.Collections.CircularBuffer.data	circularbuffer.html#data	
Pathfinding.Collections.CircularBuffer.head	circularbuffer.html#head	
Pathfinding.Collections.CircularBuffer.length	circularbuffer.html#length	
Pathfinding.Collections.CircularBuffer.this[int index]	circularbuffer.html#thisintindex	Indexes the buffer, with index 0 being the first element.
Pathfinding.Collections.GridLookup.AllItems	gridlookup.html#AllItems	Linked list of all items.
Pathfinding.Collections.GridLookup.Item.next	item3.html#next	
Pathfinding.Collections.GridLookup.Item.prev	item3.html#prev	
Pathfinding.Collections.GridLookup.Item.root	item3.html#root	
Pathfinding.Collections.GridLookup.Root.flag	root.html#flag	
Pathfinding.Collections.GridLookup.Root.items	root.html#items	References to an item in each grid cell that this object is contained inside.
Pathfinding.Collections.GridLookup.Root.next	root.html#next	Next item in the linked list of all roots.
Pathfinding.Collections.GridLookup.Root.obj	root.html#obj	Underlying object.
Pathfinding.Collections.GridLookup.Root.prev	root.html#prev	Previous item in the linked list of all roots.
Pathfinding.Collections.GridLookup.Root.previousBounds	root.html#previousBounds	
Pathfinding.Collections.GridLookup.Root.previousPosition	root.html#previousPosition	
Pathfinding.Collections.GridLookup.Root.previousRotation	root.html#previousRotation	
Pathfinding.Collections.GridLookup.all	gridlookup.html#all	Linked list of all items. \n\nNote that the first item in the list is a dummy item and does not contain any data.
Pathfinding.Collections.GridLookup.cells	gridlookup.html#cells	
Pathfinding.Collections.GridLookup.itemPool	gridlookup.html#itemPool	
Pathfinding.Collections.GridLookup.rootLookup	gridlookup.html#rootLookup	
Pathfinding.Collections.GridLookup.size	gridlookup.html#size	
Pathfinding.Collections.HierarchicalBitset.Capacity	hierarchicalbitset.html#Capacity	
Pathfinding.Collections.HierarchicalBitset.IsCreated	hierarchicalbitset.html#IsCreated	
Pathfinding.Collections.HierarchicalBitset.IsEmpty	hierarchicalbitset.html#IsEmpty	True if the bitset is empty.
Pathfinding.Collections.HierarchicalBitset.Iterator.Current	iterator.html#Current	
Pathfinding.Collections.HierarchicalBitset.Iterator.bitSet	iterator.html#bitSet	
Pathfinding.Collections.HierarchicalBitset.Iterator.l2bitIndex	iterator.html#l2bitIndex	
Pathfinding.Collections.HierarchicalBitset.Iterator.l3bitIndex	iterator.html#l3bitIndex	
Pathfinding.Collections.HierarchicalBitset.Iterator.l3index	iterator.html#l3index	
Pathfinding.Collections.HierarchicalBitset.Iterator.result	iterator.html#result	
Pathfinding.Collections.HierarchicalBitset.Iterator.resultCount	iterator.html#resultCount	
Pathfinding.Collections.HierarchicalBitset.Log64	hierarchicalbitset.html#Log64	
Pathfinding.Collections.HierarchicalBitset.allocator	hierarchicalbitset.html#allocator	
Pathfinding.Collections.HierarchicalBitset.l1	hierarchicalbitset.html#l1	
Pathfinding.Collections.HierarchicalBitset.l2	hierarchicalbitset.html#l2	
Pathfinding.Collections.HierarchicalBitset.l3	hierarchicalbitset.html#l3	
Pathfinding.Collections.NativeCircularBuffer.AbsoluteEndIndex	nativecircularbuffer.html#AbsoluteEndIndex	Absolute index of the last item in the buffer, may be negative or greater than Length.
Pathfinding.Collections.NativeCircularBuffer.AbsoluteStartIndex	nativecircularbuffer.html#AbsoluteStartIndex	Absolute index of the first item in the buffer, may be negative or greater than Length.
Pathfinding.Collections.NativeCircularBuffer.Allocator	nativecircularbuffer.html#Allocator	The allocator used to create the internal buffer.
Pathfinding.Collections.NativeCircularBuffer.Count	nativecircularbuffer.html#Count	
Pathfinding.Collections.NativeCircularBuffer.First	nativecircularbuffer.html#First	First item in the buffer throws if the buffer is empty.
Pathfinding.Collections.NativeCircularBuffer.IsCreated	nativecircularbuffer.html#IsCreated	
Pathfinding.Collections.NativeCircularBuffer.Last	nativecircularbuffer.html#Last	Last item in the buffer, throws if the buffer is empty.
Pathfinding.Collections.NativeCircularBuffer.Length	nativecircularbuffer.html#Length	Number of items in the buffer.
Pathfinding.Collections.NativeCircularBuffer.capacityMask	nativecircularbuffer.html#capacityMask	Capacity of the allocation minus 1. \n\nInvariant: (a power of two) minus 1
Pathfinding.Collections.NativeCircularBuffer.data	nativecircularbuffer.html#data	
Pathfinding.Collections.NativeCircularBuffer.head	nativecircularbuffer.html#head	
Pathfinding.Collections.NativeCircularBuffer.length	nativecircularbuffer.html#length	
Pathfinding.Collections.NativeCircularBuffer.this[int index]	nativecircularbuffer.html#thisintindex	Indexes the buffer, with index 0 being the first element.
Pathfinding.Collections.SlabAllocator.AllocatedBit	slaballocator.html#AllocatedBit	
Pathfinding.Collections.SlabAllocator.AllocatorData.freeHeads	allocatordata.html#freeHeads	
Pathfinding.Collections.SlabAllocator.AllocatorData.mem	allocatordata.html#mem	
Pathfinding.Collections.SlabAllocator.ByteSize	slaballocator.html#ByteSize	
Pathfinding.Collections.SlabAllocator.Header.length	header.html#length	
Pathfinding.Collections.SlabAllocator.InvalidAllocation	slaballocator.html#InvalidAllocation	Allocation which is always invalid.
Pathfinding.Collections.SlabAllocator.IsCreated	slaballocator.html#IsCreated	
Pathfinding.Collections.SlabAllocator.IsDebugAllocator	slaballocator.html#IsDebugAllocator	
Pathfinding.Collections.SlabAllocator.LengthMask	slaballocator.html#LengthMask	
Pathfinding.Collections.SlabAllocator.List.Length	list.html#Length	
Pathfinding.Collections.SlabAllocator.List.allocationIndex	list.html#allocationIndex	
Pathfinding.Collections.SlabAllocator.List.allocator	list.html#allocator	
Pathfinding.Collections.SlabAllocator.List.span	list.html#span	
Pathfinding.Collections.SlabAllocator.List.this[int index]	list.html#thisintindex	
Pathfinding.Collections.SlabAllocator.MaxAllocationSize	slaballocator.html#MaxAllocationSize	
Pathfinding.Collections.SlabAllocator.MaxAllocationSizeIndex	slaballocator.html#MaxAllocationSizeIndex	
Pathfinding.Collections.SlabAllocator.NextBlock.next	nextblock.html#next	
Pathfinding.Collections.SlabAllocator.UsedBit	slaballocator.html#UsedBit	
Pathfinding.Collections.SlabAllocator.ZeroLengthArray	slaballocator.html#ZeroLengthArray	Allocation representing a zero-length array.
Pathfinding.Collections.SlabAllocator.data	slaballocator.html#data	
Pathfinding.Collections.UnsafeSpan.Length	unsafespan.html#Length	Number of elements in this span.
Pathfinding.Collections.UnsafeSpan.length	unsafespan.html#length	
Pathfinding.Collections.UnsafeSpan.ptr	unsafespan.html#ptr	
Pathfinding.Collections.UnsafeSpan.this[int index]	unsafespan.html#thisintindex	
Pathfinding.Collections.UnsafeSpan.this[uint index]	unsafespan.html#thisuintindex	
Pathfinding.Connection.IdenticalEdge	connection.html#IdenticalEdge	
Pathfinding.Connection.IncomingConnection	connection.html#IncomingConnection	
Pathfinding.Connection.NoSharedEdge	connection.html#NoSharedEdge	
Pathfinding.Connection.OutgoingConnection	connection.html#OutgoingConnection	
Pathfinding.Connection.adjacentShapeEdge	connection.html#adjacentShapeEdge	The edge of the shape in the other node, which this connection represents. \n\n[more in online documentation]
Pathfinding.Connection.cost	connection.html#cost	Cost of moving along this connection. \n\nA cost of 1000 corresponds approximately to the cost of moving one world unit.
Pathfinding.Connection.edgesAreIdentical	connection.html#edgesAreIdentical	True if the two nodes share an identical edge. \n\nThis is only true if the connection is between two triangle mesh nodes and the nodes share the edge which this connection represents.\n\nIn contrast to isEdgeShared, this is true only if the triangle edge is identical (but reversed) in the other node.
Pathfinding.Connection.isEdgeShared	connection.html#isEdgeShared	True if the two nodes share an edge. \n\nThis is only true if the connection is between two triangle mesh nodes and the nodes share the edge which this connection represents. Note that the edge does not need to be perfectly identical for this to be true, it is enough if the edge is very similar.
Pathfinding.Connection.isIncoming	connection.html#isIncoming	True if the connection allows movement from the other node to this node. \n\nA connection can be either outgoing, incoming, or both. Most connections are two-way, so both incoming and outgoing.
Pathfinding.Connection.isOutgoing	connection.html#isOutgoing	True if the connection allows movement from this node to the other node. \n\nA connection can be either outgoing, incoming, or both. Most connections are two-way, so both incoming and outgoing.
Pathfinding.Connection.node	connection.html#node	Node which this connection goes to.
Pathfinding.Connection.shapeEdge	connection.html#shapeEdge	The edge of the shape which this connection uses. \n\nThis is an index into the shape's vertices.\n\nA value of 0 corresponds to using the side for vertex 0 and vertex 1 on the node. 1 corresponds to vertex 1 and 2, etc. A value of 3 is invalid, and this will be the value if isEdgeShared is false.\n\n[more in online documentation]
Pathfinding.Connection.shapeEdgeInfo	connection.html#shapeEdgeInfo	Various metadata about the connection, such as the side of the node shape which this connection uses. \n\n- Bits 0..1 represent shapeEdge.\n\n- Bits 2..3 represent adjacentShapeEdge.\n\n- Bit 4 represents isIncoming.\n\n- Bit 5 represents isOutgoing.\n\n- Bit 6 represents edgesAreIdentical.\n\n\n\n[more in online documentation]
Pathfinding.ConstantPath.allNodes	constantpath.html#allNodes	Contains all nodes the path found. \n\nThis list will be sorted by G score (cost/distance to reach the node).
Pathfinding.ConstantPath.endingCondition	constantpath.html#endingCondition	Determines when the path calculation should stop. \n\nThis is set up automatically in the constructor to an instance of the Pathfinding.EndingConditionDistance class with a <b>maxGScore</b> is specified in the constructor.\n\n[more in online documentation]
Pathfinding.ConstantPath.originalStartPoint	constantpath.html#originalStartPoint	
Pathfinding.ConstantPath.startNode	constantpath.html#startNode	
Pathfinding.ConstantPath.startPoint	constantpath.html#startPoint	
Pathfinding.CustomGraphEditorAttribute.displayName	customgrapheditorattribute.html#displayName	Name displayed in the inpector.
Pathfinding.CustomGraphEditorAttribute.editorType	customgrapheditorattribute.html#editorType	Type of the editor for the graph.
Pathfinding.CustomGraphEditorAttribute.graphType	customgrapheditorattribute.html#graphType	Graph type which this is an editor for.
Pathfinding.DistanceMetric.Euclidean	distancemetric.html#Euclidean	Returns a DistanceMetric which will find the closest node in euclidean 3D space. \n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.DistanceMetric.distanceScaleAlongProjectionDirection	distancemetric.html#distanceScaleAlongProjectionDirection	Distance scaling along the projectionAxis. \n\n[more in online documentation]
Pathfinding.DistanceMetric.isProjectedDistance	distancemetric.html#isProjectedDistance	True when using the ClosestAsSeenFromAbove or ClosestAsSeenFromAboveSoft modes.
Pathfinding.DistanceMetric.projectionAxis	distancemetric.html#projectionAxis	Normal of the plane on which nodes will be projected before finding the closest point on them. \n\nWhen zero, this has no effect.\n\nWhen set to the special value (inf, inf, inf) then the graph's natural up direction will be used.\n\nOften you do not want to find the closest point on a node in 3D space, but rather find for example the closest point on the node directly below the agent.\n\nThis allows you to project the nodes onto a plane before finding the closest point on them. For example, if you set this to Vector3.up, then the nodes will be projected onto the XZ plane. Running a GetNearest query will then find the closest node as seen from above.\n\n <b>[image in online documentation]</b>\n\nThis is more flexible, however. You can set the distanceScaleAlongProjectionDirection to any value (though usually somewhere between 0 and 1). With a value of 0, the closest node will be found as seen from above. When the distance is greater than 0, moving along the <b>projectionAxis</b> from the query point will only cost distanceScaleAlongProjectionDirection times the regular distance, but moving sideways will cost the normal amount.\n\n <b>[image in online documentation]</b>\n\nA nice value to use is 0.2 for distanceScaleAlongProjectionDirection. This will make moving upwards or downwards (along the projection direction) only appear like 20% the original distance to the nearest node search. This allows you to find the closest position directly under the agent, if there is a navmesh directly under the agent, but also to search not directly below the agent if that is necessary.\n\n[more in online documentation]
Pathfinding.DynamicGridObstacle.checkTime	dynamicgridobstacle.html#checkTime	
Pathfinding.DynamicGridObstacle.enabled	dynamicgridobstacle.html#enabled	
Pathfinding.DynamicGridObstacle.updateError	dynamicgridobstacle.html#updateError	
Pathfinding.DynamicObstacle.bounds	dynamicobstacle.html#bounds	
Pathfinding.DynamicObstacle.checkTime	dynamicobstacle.html#checkTime	Time in seconds between bounding box checks. \n\nIf AstarPath.batchGraphUpdates is enabled, it is not beneficial to have a checkTime much lower than AstarPath.graphUpdateBatchingInterval because that will just add extra unnecessary graph updates.\n\nIn real time seconds (based on Time.realtimeSinceStartup).
Pathfinding.DynamicObstacle.coll	dynamicobstacle.html#coll	Collider to get bounds information from.
Pathfinding.DynamicObstacle.coll2D	dynamicobstacle.html#coll2D	2D Collider to get bounds information from
Pathfinding.DynamicObstacle.colliderEnabled	dynamicobstacle.html#colliderEnabled	
Pathfinding.DynamicObstacle.lastCheckTime	dynamicobstacle.html#lastCheckTime	
Pathfinding.DynamicObstacle.pendingGraphUpdates	dynamicobstacle.html#pendingGraphUpdates	
Pathfinding.DynamicObstacle.prevBounds	dynamicobstacle.html#prevBounds	Bounds of the collider the last time the graphs were updated.
Pathfinding.DynamicObstacle.prevEnabled	dynamicobstacle.html#prevEnabled	True if the collider was enabled last time the graphs were updated.
Pathfinding.DynamicObstacle.prevRotation	dynamicobstacle.html#prevRotation	Rotation of the collider the last time the graphs were updated.
Pathfinding.DynamicObstacle.tr	dynamicobstacle.html#tr	Cached transform component.
Pathfinding.DynamicObstacle.updateError	dynamicobstacle.html#updateError	The minimum change in world units along one of the axis of the bounding box of the collider to trigger a graph update.
Pathfinding.ECS.AIMoveSystem.MarkerMovementOverride	aimovesystem.html#MarkerMovementOverride	
Pathfinding.ECS.AIMoveSystem.MovementStateTypeHandleRO	aimovesystem.html#MovementStateTypeHandleRO	
Pathfinding.ECS.AIMoveSystem.ResolvedMovementHandleRO	aimovesystem.html#ResolvedMovementHandleRO	
Pathfinding.ECS.AIMoveSystem.entityQueryGizmos	aimovesystem.html#entityQueryGizmos	
Pathfinding.ECS.AIMoveSystem.entityQueryMovementOverride	aimovesystem.html#entityQueryMovementOverride	
Pathfinding.ECS.AIMoveSystem.entityQueryPrepareMovement	aimovesystem.html#entityQueryPrepareMovement	
Pathfinding.ECS.AIMoveSystem.entityQueryWithGravity	aimovesystem.html#entityQueryWithGravity	
Pathfinding.ECS.AIMoveSystem.jobRepairPathScheduler	aimovesystem.html#jobRepairPathScheduler	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.CheapSimulationOnly	timescaledratemanager.html#CheapSimulationOnly	True if it was determined that zero substeps should be simulated. \n\nIn this case all systems will get an opportunity to run a single update, but they should avoid systems that don't have to run every single frame.
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.CheapStepDeltaTime	timescaledratemanager.html#CheapStepDeltaTime	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.IsFirstSubstep	timescaledratemanager.html#IsFirstSubstep	True when this is the first substep of the current simulation.
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.IsLastSubstep	timescaledratemanager.html#IsLastSubstep	True when this is the last substep of the current simulation.
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.NumUpdatesThisFrame	timescaledratemanager.html#NumUpdatesThisFrame	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.Timestep	timescaledratemanager.html#Timestep	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.cheapSimulationOnly	timescaledratemanager.html#cheapSimulationOnly	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.cheapTimeData	timescaledratemanager.html#cheapTimeData	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.cheapTimeDataQueue	timescaledratemanager.html#cheapTimeDataQueue	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.inGroup	timescaledratemanager.html#inGroup	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.isFirstSubstep	timescaledratemanager.html#isFirstSubstep	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.isLastSubstep	timescaledratemanager.html#isLastSubstep	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.lastCheapSimulation	timescaledratemanager.html#lastCheapSimulation	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.lastFullSimulation	timescaledratemanager.html#lastFullSimulation	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.maximumDt	timescaledratemanager.html#maximumDt	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.numUpdatesThisFrame	timescaledratemanager.html#numUpdatesThisFrame	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.ownProcessingTimePerIteration	timescaledratemanager.html#ownProcessingTimePerIteration	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.stepDt	timescaledratemanager.html#stepDt	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.timeDataQueue	timescaledratemanager.html#timeDataQueue	
Pathfinding.ECS.AIMovementSystemGroup.TimeScaledRateManager.updateIndex	timescaledratemanager.html#updateIndex	
Pathfinding.ECS.AgentCylinderShape.height	agentcylindershape.html#height	Height of the agent in world units.
Pathfinding.ECS.AgentCylinderShape.radius	agentcylindershape.html#radius	Radius of the agent in world units.
Pathfinding.ECS.AgentMovementPlane.value	agentmovementplane.html#value	The movement plane for the agent. \n\nThe movement plane determines what the "up" direction of the agent is. For most typical 3D games, this will be aligned with the Y axis, but there are games in which the agent needs to navigate on walls, or on spherical worlds. For those games this movement plane will track the plane in which the agent is currently moving.\n\n[more in online documentation]
Pathfinding.ECS.AgentMovementPlaneSource.value	agentmovementplanesource.html#value	
Pathfinding.ECS.AgentOffMeshLinkTraversal.firstPosition	agentoffmeshlinktraversal.html#firstPosition	The start point of the off-mesh link from the agent's perspective. \n\nThis is the point where the agent starts traversing the off-mesh link, regardless of if the link is traversed from the start to end or from end to start. \n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversal.isReverse	agentoffmeshlinktraversal.html#isReverse	True if the agent is traversing the off-mesh link from original link's end to its start point. \n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversal.relativeEnd	agentoffmeshlinktraversal.html#relativeEnd	The end point of the off-mesh link from the agent's perspective. \n\nThis is the point where the agent will finish traversing the off-mesh link, regardless of if the link is traversed from start to end or from end to start.
Pathfinding.ECS.AgentOffMeshLinkTraversal.relativeStart	agentoffmeshlinktraversal.html#relativeStart	The start point of the off-mesh link from the agent's perspective. \n\nThis is the point where the agent starts traversing the off-mesh link, regardless of if the link is traversed from the start to end or from end to start.
Pathfinding.ECS.AgentOffMeshLinkTraversal.secondPosition	agentoffmeshlinktraversal.html#secondPosition	The end point of the off-mesh link from the agent's perspective. \n\nThis is the point where the agent will finish traversing the off-mesh link, regardless of if the link is traversed from start to end or from end to start. \n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.backupRotationSmoothing	agentoffmeshlinktraversalcontext.html#backupRotationSmoothing	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.concreteLink	agentoffmeshlinktraversalcontext.html#concreteLink	The off-mesh link that is being traversed. \n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.deltaTime	agentoffmeshlinktraversalcontext.html#deltaTime	Delta time since the last link simulation. \n\nDuring high time scales, the simulation may run multiple substeps per frame.\n\nThis is <b>not</b> the same as Time.deltaTime. Inside the link coroutine, you should always use this field instead of Time.deltaTime.
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.disabledRVO	agentoffmeshlinktraversalcontext.html#disabledRVO	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.enableBuiltInMovement	agentoffmeshlinktraversalcontext.html#enableBuiltInMovement	True if the agent's built-in movement logic should be enabled. \n\nWhen traversing an off-mesh link, you typically want the agent's movement to be completely controlled by an animation, or some other code. However, sometimes you may want to use the built-in movement logic to move the agent.\n\nUsing the MoveTowards method will automatically enable the agent's movement logic during that frame.\n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.entity	agentoffmeshlinktraversalcontext.html#entity	The entity that is traversing the off-mesh link.
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.gameObject	agentoffmeshlinktraversalcontext.html#gameObject	GameObject associated with the agent. \n\nIn most cases, an agent is associated with an agent, but this is not always the case. For example, if you have created an entity without using the FollowerEntity component, this property may return null.\n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.gameObjectCache	agentoffmeshlinktraversalcontext.html#gameObjectCache	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.link	agentoffmeshlinktraversalcontext.html#link	Information about the off-mesh link that the agent is traversing.
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.linkInfo	agentoffmeshlinktraversalcontext.html#linkInfo	Information about the off-mesh link that the agent is traversing. \n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.linkInfoPtr	agentoffmeshlinktraversalcontext.html#linkInfoPtr	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.managedState	agentoffmeshlinktraversalcontext.html#managedState	Some internal state of the agent.
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.movementControl	agentoffmeshlinktraversalcontext.html#movementControl	How the agent should move. \n\nThe agent will move according to this data, every frame, if enableBuiltInMovement is enabled.\n\n[more in online documentation]
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.movementControlPtr	agentoffmeshlinktraversalcontext.html#movementControlPtr	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.movementDisabled	agentoffmeshlinktraversalcontext.html#movementDisabled	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.movementPlane	agentoffmeshlinktraversalcontext.html#movementPlane	The plane in which the agent is moving. \n\nIn a 3D game, this will typically be the XZ plane, but in a 2D game it will typically be the XY plane. Games on spherical planets could have planes that are aligned with the surface of the planet.
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.movementPlanePtr	agentoffmeshlinktraversalcontext.html#movementPlanePtr	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.movementSettings	agentoffmeshlinktraversalcontext.html#movementSettings	The movement settings for the agent.
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.movementSettingsPtr	agentoffmeshlinktraversalcontext.html#movementSettingsPtr	
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.transform	agentoffmeshlinktraversalcontext.html#transform	ECS LocalTransform component attached to the agent.
Pathfinding.ECS.AgentOffMeshLinkTraversalContext.transformPtr	agentoffmeshlinktraversalcontext.html#transformPtr	
Pathfinding.ECS.AutoRepathPolicy.Default	autorepathpolicy.html#Default	
Pathfinding.ECS.AutoRepathPolicy.Sensitivity	autorepathpolicy.html#Sensitivity	How sensitive the agent should be to changes in its destination for Mode.Dynamic. \n\nA higher value means the destination has to move less for the path to be recalculated.\n\n[more in online documentation]
Pathfinding.ECS.AutoRepathPolicy.lastDestination	autorepathpolicy.html#lastDestination	
Pathfinding.ECS.AutoRepathPolicy.lastRepathTime	autorepathpolicy.html#lastRepathTime	
Pathfinding.ECS.AutoRepathPolicy.mode	autorepathpolicy.html#mode	Policy to use when recalculating paths. \n\n[more in online documentation]
Pathfinding.ECS.AutoRepathPolicy.pathFailures	autorepathpolicy.html#pathFailures	
Pathfinding.ECS.AutoRepathPolicy.period	autorepathpolicy.html#period	Number of seconds between each automatic path recalculation for Mode.EveryNSeconds, and the maximum interval for Mode.Dynamic.
Pathfinding.ECS.ComponentRef.ptr	componentref.html#ptr	
Pathfinding.ECS.ComponentRef.value	componentref.html#value	
Pathfinding.ECS.DestinationPoint.destination	destinationpoint.html#destination	The destination point that the agent is moving towards. \n\nThis is the point that the agent is trying to reach, but it may not always be possible to reach it.\n\n[more in online documentation]
Pathfinding.ECS.DestinationPoint.facingDirection	destinationpoint.html#facingDirection	The direction the agent should face when it reaches the destination. \n\nIf zero, the agent will not try to face any particular direction when reaching the destination.
Pathfinding.ECS.EntityAccess.handle	entityaccess.html#handle	
Pathfinding.ECS.EntityAccess.lastSystemVersion	entityaccess.html#lastSystemVersion	
Pathfinding.ECS.EntityAccess.readOnly	entityaccess.html#readOnly	
Pathfinding.ECS.EntityAccess.this[EntityStorageInfo storage]	entityaccess.html#thisEntityStorageInfostorage	
Pathfinding.ECS.EntityAccess.worldSequenceNumber	entityaccess.html#worldSequenceNumber	
Pathfinding.ECS.EntityAccessHelper.GlobalSystemVersionOffset	entityaccesshelper.html#GlobalSystemVersionOffset	
Pathfinding.ECS.EntityStorageCache.entity	entitystoragecache.html#entity	
Pathfinding.ECS.EntityStorageCache.lastWorldHash	entitystoragecache.html#lastWorldHash	
Pathfinding.ECS.EntityStorageCache.storage	entitystoragecache.html#storage	
Pathfinding.ECS.FollowerControlSystem.MarkerMovementOverrideAfterControl	followercontrolsystem.html#MarkerMovementOverrideAfterControl	
Pathfinding.ECS.FollowerControlSystem.MarkerMovementOverrideBeforeControl	followercontrolsystem.html#MarkerMovementOverrideBeforeControl	
Pathfinding.ECS.FollowerControlSystem.entityQueryControlManaged	followercontrolsystem.html#entityQueryControlManaged	
Pathfinding.ECS.FollowerControlSystem.entityQueryControlManaged2	followercontrolsystem.html#entityQueryControlManaged2	
Pathfinding.ECS.FollowerControlSystem.redrawScope	followercontrolsystem.html#redrawScope	
Pathfinding.ECS.GravityState.verticalVelocity	gravitystate.html#verticalVelocity	Current vertical velocity of the agent. \n\nThis is the velocity that the agent is moving with due to gravity. It is not necessarily the same as the Y component of the estimated velocity.
Pathfinding.ECS.JobAlignAgentWithMovementDirection.dt	jobalignagentwithmovementdirection.html#dt	
Pathfinding.ECS.JobApplyGravity.draw	jobapplygravity.html#draw	
Pathfinding.ECS.JobApplyGravity.dt	jobapplygravity.html#dt	
Pathfinding.ECS.JobApplyGravity.raycastCommands	jobapplygravity.html#raycastCommands	
Pathfinding.ECS.JobApplyGravity.raycastHits	jobapplygravity.html#raycastHits	
Pathfinding.ECS.JobControl.MarkerConvertObstacles	jobcontrol.html#MarkerConvertObstacles	
Pathfinding.ECS.JobControl.draw	jobcontrol.html#draw	
Pathfinding.ECS.JobControl.dt	jobcontrol.html#dt	
Pathfinding.ECS.JobControl.edgesScratch	jobcontrol.html#edgesScratch	
Pathfinding.ECS.JobControl.indicesScratch	jobcontrol.html#indicesScratch	
Pathfinding.ECS.JobControl.navmeshEdgeData	jobcontrol.html#navmeshEdgeData	
Pathfinding.ECS.JobDrawFollowerGizmos.AgentCylinderShapeHandleRO	jobdrawfollowergizmos.html#AgentCylinderShapeHandleRO	
Pathfinding.ECS.JobDrawFollowerGizmos.AgentMovementPlaneHandleRO	jobdrawfollowergizmos.html#AgentMovementPlaneHandleRO	
Pathfinding.ECS.JobDrawFollowerGizmos.InternalRotation	jobdrawfollowergizmos.html#InternalRotation	
Pathfinding.ECS.JobDrawFollowerGizmos.LocalTransformTypeHandleRO	jobdrawfollowergizmos.html#LocalTransformTypeHandleRO	
Pathfinding.ECS.JobDrawFollowerGizmos.ManagedStateHandleRW	jobdrawfollowergizmos.html#ManagedStateHandleRW	
Pathfinding.ECS.JobDrawFollowerGizmos.MovementSettingsHandleRO	jobdrawfollowergizmos.html#MovementSettingsHandleRO	
Pathfinding.ECS.JobDrawFollowerGizmos.MovementStateHandleRO	jobdrawfollowergizmos.html#MovementStateHandleRO	
Pathfinding.ECS.JobDrawFollowerGizmos.Path	jobdrawfollowergizmos.html#Path	
Pathfinding.ECS.JobDrawFollowerGizmos.ResolvedMovementHandleRO	jobdrawfollowergizmos.html#ResolvedMovementHandleRO	
Pathfinding.ECS.JobDrawFollowerGizmos.TargetInternalRotation	jobdrawfollowergizmos.html#TargetInternalRotation	
Pathfinding.ECS.JobDrawFollowerGizmos.TargetInternalRotationHint	jobdrawfollowergizmos.html#TargetInternalRotationHint	
Pathfinding.ECS.JobDrawFollowerGizmos.UnsmoothedRotation	jobdrawfollowergizmos.html#UnsmoothedRotation	
Pathfinding.ECS.JobDrawFollowerGizmos.VisualRotationColor	jobdrawfollowergizmos.html#VisualRotationColor	
Pathfinding.ECS.JobDrawFollowerGizmos.draw	jobdrawfollowergizmos.html#draw	
Pathfinding.ECS.JobDrawFollowerGizmos.entityManagerHandle	jobdrawfollowergizmos.html#entityManagerHandle	
Pathfinding.ECS.JobDrawFollowerGizmos.scratchBuffer1	jobdrawfollowergizmos.html#scratchBuffer1	
Pathfinding.ECS.JobDrawFollowerGizmos.scratchBuffer2	jobdrawfollowergizmos.html#scratchBuffer2	
Pathfinding.ECS.JobManagedMovementOverrideAfterControl.dt	jobmanagedmovementoverrideaftercontrol.html#dt	
Pathfinding.ECS.JobManagedMovementOverrideBeforeControl.dt	jobmanagedmovementoverridebeforecontrol.html#dt	
Pathfinding.ECS.JobManagedMovementOverrideBeforeMovement.dt	jobmanagedmovementoverridebeforemovement.html#dt	
Pathfinding.ECS.JobManagedOffMeshLinkTransition.commandBuffer	jobmanagedoffmeshlinktransition.html#commandBuffer	
Pathfinding.ECS.JobManagedOffMeshLinkTransition.deltaTime	jobmanagedoffmeshlinktransition.html#deltaTime	
Pathfinding.ECS.JobMoveAgent.dt	jobmoveagent.html#dt	
Pathfinding.ECS.JobPrepareAgentRaycasts.draw	jobprepareagentraycasts.html#draw	
Pathfinding.ECS.JobPrepareAgentRaycasts.dt	jobprepareagentraycasts.html#dt	
Pathfinding.ECS.JobPrepareAgentRaycasts.gravity	jobprepareagentraycasts.html#gravity	
Pathfinding.ECS.JobPrepareAgentRaycasts.raycastCommands	jobprepareagentraycasts.html#raycastCommands	
Pathfinding.ECS.JobPrepareAgentRaycasts.raycastQueryParameters	jobprepareagentraycasts.html#raycastQueryParameters	
Pathfinding.ECS.JobRepairPath.MarkerGetNextCorners	jobrepairpath.html#MarkerGetNextCorners	
Pathfinding.ECS.JobRepairPath.MarkerRepair	jobrepairpath.html#MarkerRepair	
Pathfinding.ECS.JobRepairPath.MarkerUpdateReachedEndInfo	jobrepairpath.html#MarkerUpdateReachedEndInfo	
Pathfinding.ECS.JobRepairPath.Scheduler.AgentCylinderShapeTypeHandleRO	scheduler.html#AgentCylinderShapeTypeHandleRO	
Pathfinding.ECS.JobRepairPath.Scheduler.AgentMovementPlaneTypeHandleRO	scheduler.html#AgentMovementPlaneTypeHandleRO	
Pathfinding.ECS.JobRepairPath.Scheduler.AutoRepathPolicyRW	scheduler.html#AutoRepathPolicyRW	
Pathfinding.ECS.JobRepairPath.Scheduler.DestinationPointTypeHandleRO	scheduler.html#DestinationPointTypeHandleRO	
Pathfinding.ECS.JobRepairPath.Scheduler.LocalTransformTypeHandleRO	scheduler.html#LocalTransformTypeHandleRO	
Pathfinding.ECS.JobRepairPath.Scheduler.ManagedStateTypeHandleRW	scheduler.html#ManagedStateTypeHandleRW	
Pathfinding.ECS.JobRepairPath.Scheduler.MovementSettingsTypeHandleRO	scheduler.html#MovementSettingsTypeHandleRO	
Pathfinding.ECS.JobRepairPath.Scheduler.MovementStateTypeHandleRW	scheduler.html#MovementStateTypeHandleRW	
Pathfinding.ECS.JobRepairPath.Scheduler.ReadyToTraverseOffMeshLinkTypeHandleRW	scheduler.html#ReadyToTraverseOffMeshLinkTypeHandleRW	
Pathfinding.ECS.JobRepairPath.Scheduler.entityManagerHandle	scheduler.html#entityManagerHandle	
Pathfinding.ECS.JobRepairPath.Scheduler.onlyApplyPendingPaths	scheduler.html#onlyApplyPendingPaths	
Pathfinding.ECS.JobRepairPath.indicesScratch	jobrepairpath.html#indicesScratch	
Pathfinding.ECS.JobRepairPath.nextCornersScratch	jobrepairpath.html#nextCornersScratch	
Pathfinding.ECS.JobRepairPath.onlyApplyPendingPaths	jobrepairpath.html#onlyApplyPendingPaths	
Pathfinding.ECS.JobRepairPath.scheduler	jobrepairpath.html#scheduler	
Pathfinding.ECS.JobRepairPathHelpers.PathTracerInfo.endPointOfFirstPart	pathtracerinfo.html#endPointOfFirstPart	
Pathfinding.ECS.JobRepairPathHelpers.PathTracerInfo.isStale	pathtracerinfo.html#isStale	
Pathfinding.ECS.JobRepairPathHelpers.PathTracerInfo.isStaleBacking	pathtracerinfo.html#isStaleBacking	
Pathfinding.ECS.JobRepairPathHelpers.PathTracerInfo.partCount	pathtracerinfo.html#partCount	
Pathfinding.ECS.JobStartOffMeshLinkTransition.commandBuffer	jobstartoffmeshlinktransition.html#commandBuffer	
Pathfinding.ECS.JobSyncEntitiesToTransforms.entities	jobsyncentitiestotransforms.html#entities	
Pathfinding.ECS.JobSyncEntitiesToTransforms.entityPositions	jobsyncentitiestotransforms.html#entityPositions	
Pathfinding.ECS.JobSyncEntitiesToTransforms.movementState	jobsyncentitiestotransforms.html#movementState	
Pathfinding.ECS.JobSyncEntitiesToTransforms.orientationYAxisForward	jobsyncentitiestotransforms.html#orientationYAxisForward	
Pathfinding.ECS.JobSyncEntitiesToTransforms.syncPositionWithTransform	jobsyncentitiestotransforms.html#syncPositionWithTransform	
Pathfinding.ECS.JobSyncEntitiesToTransforms.syncRotationWithTransform	jobsyncentitiestotransforms.html#syncRotationWithTransform	
Pathfinding.ECS.ManagedAgentOffMeshLinkTraversal.context	managedagentoffmeshlinktraversal.html#context	Internal context used to pass component data to the coroutine.
Pathfinding.ECS.ManagedAgentOffMeshLinkTraversal.coroutine	managedagentoffmeshlinktraversal.html#coroutine	Coroutine which is used to traverse the link.
Pathfinding.ECS.ManagedAgentOffMeshLinkTraversal.handler	managedagentoffmeshlinktraversal.html#handler	
Pathfinding.ECS.ManagedAgentOffMeshLinkTraversal.stateMachine	managedagentoffmeshlinktraversal.html#stateMachine	
Pathfinding.ECS.ManagedEntityAccess.entityManager	managedentityaccess.html#entityManager	
Pathfinding.ECS.ManagedEntityAccess.handle	managedentityaccess.html#handle	
Pathfinding.ECS.ManagedEntityAccess.readOnly	managedentityaccess.html#readOnly	
Pathfinding.ECS.ManagedEntityAccess.this[EntityStorageInfo storage]	managedentityaccess.html#thisEntityStorageInfostorage	
Pathfinding.ECS.ManagedMovementOverride.callback	managedmovementoverride.html#callback	
Pathfinding.ECS.ManagedMovementOverrides.entity	managedmovementoverrides.html#entity	
Pathfinding.ECS.ManagedMovementOverrides.world	managedmovementoverrides.html#world	
Pathfinding.ECS.ManagedState.activePath	managedstate.html#activePath	Path that is being followed, if any. \n\nThe agent may have moved away from this path since it was calculated. So it may not be up to date.
Pathfinding.ECS.ManagedState.autoRepath	managedstate.html#autoRepath	Settings for when to recalculate the path. \n\n[more in online documentation]
Pathfinding.ECS.ManagedState.enableGravity	managedstate.html#enableGravity	True if gravity is enabled for this agent. \n\nThe agent will always fall down according to its own movement plane. The gravity applied is Physics.gravity.y.\n\nEnabling this will add the GravityState component to the entity.\n\nThis has no effect if the agent's orientation is set to YAxisForward (2D mode). Gravity does not really make sense for top-down 2D games. The gravity setting is also hidden from the inspector in this mode.
Pathfinding.ECS.ManagedState.enableLocalAvoidance	managedstate.html#enableLocalAvoidance	True if local avoidance is enabled for this agent. \n\nEnabling this will automatically add a Pathfinding.ECS.RVO.RVOAgent component to the entity.\n\n[more in online documentation]
Pathfinding.ECS.ManagedState.onTraverseOffMeshLink	managedstate.html#onTraverseOffMeshLink	Callback for when the agent starts to traverse an off-mesh link.
Pathfinding.ECS.ManagedState.pathTracer	managedstate.html#pathTracer	Calculates in which direction to move to follow the path.
Pathfinding.ECS.ManagedState.pathfindingSettings	managedstate.html#pathfindingSettings	
Pathfinding.ECS.ManagedState.pendingPath	managedstate.html#pendingPath	Path that is being calculated, if any.
Pathfinding.ECS.ManagedState.rvoSettings	managedstate.html#rvoSettings	Local avoidance settings. \n\nWhen the agent has local avoidance enabled, these settings will be copied into a Pathfinding.ECS.RVO.RVOAgent component which is attached to the agent.\n\n[more in online documentation]
Pathfinding.ECS.MovementControl.endOfPath	movementcontrol.html#endOfPath	The end of the current path. \n\nThis informs the local avoidance system about the final desired destination for the agent. This is used to make agents stop if the destination is crowded and it cannot reach its destination.\n\nIf this is not set, agents will often move forever around a crowded destination, always trying to find some way to get closer, but never finding it.
Pathfinding.ECS.MovementControl.hierarchicalNodeIndex	movementcontrol.html#hierarchicalNodeIndex	The index of the hierarchical node that the agent is currently in. \n\nWill be -1 if the hierarchical node index is not known. \n\n[more in online documentation]
Pathfinding.ECS.MovementControl.maxSpeed	movementcontrol.html#maxSpeed	The maximum speed at which the agent may move, in meters per second. \n\nIt is recommended to keep this slightly above speed, to allow the local avoidance system to move agents around more efficiently when necessary.
Pathfinding.ECS.MovementControl.overrideLocalAvoidance	movementcontrol.html#overrideLocalAvoidance	If true, this agent will ignore other agents during local avoidance, but other agents will still avoid this one. \n\nThis is useful for example for a player character which should not avoid other agents, but other agents should avoid the player.
Pathfinding.ECS.MovementControl.rotationSpeed	movementcontrol.html#rotationSpeed	The speed at which the agent should rotate towards targetRotation + targetRotationOffset, in radians per second.
Pathfinding.ECS.MovementControl.speed	movementcontrol.html#speed	The speed at which the agent should move towards targetPoint, in meters per second.
Pathfinding.ECS.MovementControl.targetPoint	movementcontrol.html#targetPoint	The point the agent should move towards.
Pathfinding.ECS.MovementControl.targetRotation	movementcontrol.html#targetRotation	The desired rotation of the agent, in radians, relative to the current movement plane. \n\n[more in online documentation]
Pathfinding.ECS.MovementControl.targetRotationHint	movementcontrol.html#targetRotationHint	The desired rotation of the agent, in radians, over a longer time horizon, relative to the current movement plane. \n\nThe targetRotation is usually only over a very short time-horizon, usually a single simulation time step. This variable is used to provide a hint of where the agent wants to rotate to over a slightly longer time scale (on the order of a second or so). It is not used to control movement directly, but it may be used to guide animations, or rotation smoothing.\n\nIf no better hint is available, this should be set to the same value as targetRotation.\n\n[more in online documentation]
Pathfinding.ECS.MovementControl.targetRotationOffset	movementcontrol.html#targetRotationOffset	Additive modifier to targetRotation, in radians. \n\nThis is used by the local avoidance system to rotate the agent, without this causing a feedback loop. This extra rotation will be ignored by the control system which decides how the agent *wants* to move. It will instead be directly applied to the agent.
Pathfinding.ECS.MovementPlaneFromGraphSystem.JobMovementPlaneFromGraph.movementPlanes	jobmovementplanefromgraph.html#movementPlanes	
Pathfinding.ECS.MovementPlaneFromGraphSystem.JobMovementPlaneFromNavmeshNormal.dt	jobmovementplanefromnavmeshnormal.html#dt	
Pathfinding.ECS.MovementPlaneFromGraphSystem.JobMovementPlaneFromNavmeshNormal.que	jobmovementplanefromnavmeshnormal.html#que	
Pathfinding.ECS.MovementPlaneFromGraphSystem.JobMovementPlaneFromNavmeshNormal.vertices	jobmovementplanefromnavmeshnormal.html#vertices	
Pathfinding.ECS.MovementPlaneFromGraphSystem.entityQueryGraph	movementplanefromgraphsystem.html#entityQueryGraph	
Pathfinding.ECS.MovementPlaneFromGraphSystem.entityQueryNormal	movementplanefromgraphsystem.html#entityQueryNormal	
Pathfinding.ECS.MovementPlaneFromGraphSystem.graphNodeQueue	movementplanefromgraphsystem.html#graphNodeQueue	
Pathfinding.ECS.MovementPlaneSource	ecs.html#MovementPlaneSource	How to calculate which direction is "up" for the agent.
Pathfinding.ECS.MovementSettings.debugFlags	movementsettings.html#debugFlags	Flags for enabling debug rendering in the scene view.
Pathfinding.ECS.MovementSettings.follower	movementsettings.html#follower	Additional movement settings.
Pathfinding.ECS.MovementSettings.groundMask	movementsettings.html#groundMask	Layer mask to use for ground placement. \n\nMake sure this does not include the layer of any colliders attached to this gameobject.\n\n[more in online documentation]
Pathfinding.ECS.MovementSettings.isStopped	movementsettings.html#isStopped	Gets or sets if the agent should stop moving. \n\nIf this is set to true the agent will immediately start to slow down as quickly as it can to come to a full stop. The agent will still react to local avoidance and gravity (if applicable), but it will not try to move in any particular direction.\n\nThe current path of the agent will not be cleared, so when this is set to false again the agent will continue moving along the previous path.\n\nThis is a purely user-controlled parameter, so for example it is not set automatically when the agent stops moving because it has reached the target. Use reachedEndOfPath for that.\n\nIf this property is set to true while the agent is traversing an off-mesh link (RichAI script only), then the agent will continue traversing the link and stop once it has completed it.\n\n[more in online documentation]\nThe steeringTarget property will continue to indicate the point which the agent would move towards if it would not be stopped.
Pathfinding.ECS.MovementSettings.movementPlaneSource	movementsettings.html#movementPlaneSource	How to calculate which direction is "up" for the agent. \n\n[more in online documentation]
Pathfinding.ECS.MovementSettings.positionSmoothing	movementsettings.html#positionSmoothing	How much to smooth the visual position of the agent. \n\nThis does not affect movement, but smoothes out the position of the agent visually.\n\nRecommended values are between 0.0 and 0.5. A value of zero will disable smoothing completely.\n\nThis will make the agent seem to lag slightly behind the internal position of the agent. It may also cut corners slightly.\n\nThe unit for this field is seconds.
Pathfinding.ECS.MovementSettings.rotationSmoothing	movementsettings.html#rotationSmoothing	How much to smooth the visual rotation of the agent. \n\nThis does not affect movement, but smoothes out how the agent rotates visually.\n\nRecommended values are between 0.0 and 0.5. A value of zero will disable smoothing completely.\n\nThe smoothing is done primarily using an exponential moving average, but with a small linear term to make the rotation converge faster when the agent is almost facing the desired direction.\n\nAdding smoothing will make the visual rotation of the agent lag a bit behind the actual rotation. Too much smoothing may make the agent seem sluggish, and appear to move sideways.\n\nThe unit for this field is seconds.
Pathfinding.ECS.MovementSettings.stopDistance	movementsettings.html#stopDistance	How far away from the destination should the agent aim to stop, in world units. \n\nIf the agent is within this distance from the destination point it will be considered to have reached the destination.\n\nEven if you want the agent to stop precisely at a given point, it is recommended to keep this slightly above zero. If it is exactly zero, the agent may have a hard time deciding that it has actually reached the end of the path, due to floating point errors and such.\n\n[more in online documentation]
Pathfinding.ECS.MovementState.ReachedDestinationFlag	movementstate.html#ReachedDestinationFlag	
Pathfinding.ECS.MovementState.ReachedEndOfPartFlag	movementstate.html#ReachedEndOfPartFlag	
Pathfinding.ECS.MovementState.ReachedEndOfPathFlag	movementstate.html#ReachedEndOfPathFlag	
Pathfinding.ECS.MovementState.TraversingLastPartFlag	movementstate.html#TraversingLastPartFlag	
Pathfinding.ECS.MovementState.closestOnNavmesh	movementstate.html#closestOnNavmesh	The closest point on the navmesh to the agent. \n\nThe agent will be snapped to this point.
Pathfinding.ECS.MovementState.endOfPath	movementstate.html#endOfPath	The end of the current path. \n\nNote that the agent may be heading towards an off-mesh link which is not the same as this point.
Pathfinding.ECS.MovementState.flags	movementstate.html#flags	Bitmask for various flags.
Pathfinding.ECS.MovementState.followerState	movementstate.html#followerState	State of the PID controller for the movement.
Pathfinding.ECS.MovementState.graphIndex	movementstate.html#graphIndex	The index of the graph that the agent is currently traversing. \n\nWill be GraphNode.InvalidGraphIndex if the agent has no path, or the node that the agent is traversing has been destroyed.
Pathfinding.ECS.MovementState.hierarchicalNodeIndex	movementstate.html#hierarchicalNodeIndex	The index of the hierarchical node that the agent is currently in. \n\nWill be -1 if the hierarchical node index is not known.\n\nThis field is valid during all system updates in the AIMovementSystemGroup. It will be cleared at the end of that group by JobClearTemporaryData, so you'll typically not be able to observe it during other times. It is cleared as a safety measure, as it is not guaranteed to be valid after that group has finished running, as graph updates may have changed the graph.\n\n[more in online documentation]
Pathfinding.ECS.MovementState.isOnValidNode	movementstate.html#isOnValidNode	True if the agent is currently on a valid node. \n\nThis is true if the agent has a path, and the node that the agent is traversing is walkable and not destroyed.\n\nIf false, the hierarchicalNodeIndex and graphIndex fields are invalid.
Pathfinding.ECS.MovementState.nextCorner	movementstate.html#nextCorner	The next corner in the path.
Pathfinding.ECS.MovementState.pathTracerVersion	movementstate.html#pathTracerVersion	Version number of PathTracer.version when the movement state was last updated. \n\nIn particular, closestOnNavmesh, nextCorner, endOfPath, remainingDistanceToEndOfPart, reachedDestination and reachedEndOfPath will only be considered up to date if this is equal to the current version number of the path tracer.
Pathfinding.ECS.MovementState.positionOffset	movementstate.html#positionOffset	Offset from the agent's internal position to its visual position. \n\nThis is used when position smoothing is enabled. Otherwise it is zero.
Pathfinding.ECS.MovementState.reachedDestination	movementstate.html#reachedDestination	True if the agent has reached its destination. \n\nThe destination will be considered reached if all of these conditions are met:\n- The agent has a path\n\n- The path is not stale\n\n- The destination is not significantly below the agent's feet.\n\n- The destination is not significantly above the agent's head.\n\n- The agent is on the last part of the path (there are no more remaining off-mesh links).\n\n- The remaining distance to the end of the path + the distance from the end of the path to the destination is less than MovementSettings.stopDistance.
Pathfinding.ECS.MovementState.reachedDestinationAndOrientation	movementstate.html#reachedDestinationAndOrientation	True if the agent has reached its destination and is facing the desired orientation. \n\nThis will become true if all of these conditions are met:\n- reachedDestination is true\n\n- The agent is facing the desired facing direction as specified in DestinationPoint.facingDirection.
Pathfinding.ECS.MovementState.reachedDestinationAndOrientationFlag	movementstate.html#reachedDestinationAndOrientationFlag	
Pathfinding.ECS.MovementState.reachedEndOfPart	movementstate.html#reachedEndOfPart	True if the agent has reached the end of the current part in the path. \n\nThe end of the current part will be considered reached if all of these conditions are met:\n- The agent has a path\n\n- The path is not stale\n\n- The end of the current part is not significantly below the agent's feet.\n\n- The end of the current part is not significantly above the agent's head.\n\n- The remaining distance to the end of the part is not significantly larger than the agent's radius.
Pathfinding.ECS.MovementState.reachedEndOfPath	movementstate.html#reachedEndOfPath	True if the agent has reached the end of the path. \n\nThe end of the path will be considered reached if all of these conditions are met:\n- The agent has a path\n\n- The path is not stale\n\n- The end of the path is not significantly below the agent's feet.\n\n- The end of the path is not significantly above the agent's head.\n\n- The agent is on the last part of the path (there are no more remaining off-mesh links).\n\n- The remaining distance to the end of the path is less than MovementSettings.stopDistance.
Pathfinding.ECS.MovementState.reachedEndOfPathAndOrientation	movementstate.html#reachedEndOfPathAndOrientation	True if the agent has reached its destination and is facing the desired orientation. \n\nThis will become true if all of these conditions are met:\n- reachedEndOfPath is true\n\n- The agent is facing the desired facing direction as specified in DestinationPoint.facingDirection.
Pathfinding.ECS.MovementState.reachedEndOfPathAndOrientationFlag	movementstate.html#reachedEndOfPathAndOrientationFlag	
Pathfinding.ECS.MovementState.remainingDistanceToEndOfPart	movementstate.html#remainingDistanceToEndOfPart	The remaining distance until the end of the path, or the next off-mesh link.
Pathfinding.ECS.MovementState.rotationOffset	movementstate.html#rotationOffset	The current additional rotation that is applied to the agent. \n\nThis is used by the local avoidance system to rotate the agent, without this causing a feedback loop.\n\n[more in online documentation]
Pathfinding.ECS.MovementState.rotationOffset2	movementstate.html#rotationOffset2	An additional, purely visual, rotation offset. \n\nThis is used for rotation smoothing, but does not affect the movement of the agent.
Pathfinding.ECS.MovementState.traversingLastPart	movementstate.html#traversingLastPart	True if the agent is traversing the last part of the path. \n\nIf false, the agent will have to traverse at least one off-mesh link before it gets to its destination.
Pathfinding.ECS.MovementStatistics.estimatedVelocity	movementstatistics.html#estimatedVelocity	The estimated velocity that the agent is moving with. \n\nThis includes all form of movement, including local avoidance and gravity.
Pathfinding.ECS.MovementStatistics.lastPosition	movementstatistics.html#lastPosition	The position of the agent at the end of the last movement simulation step.
Pathfinding.ECS.MovementTarget.isReached	movementtarget.html#isReached	
Pathfinding.ECS.MovementTarget.reached	movementtarget.html#reached	
Pathfinding.ECS.PhysicsSceneRef.physicsScene	physicssceneref.html#physicsScene	
Pathfinding.ECS.PollPendingPathsSystem.anyPendingPaths	pollpendingpathssystem.html#anyPendingPaths	
Pathfinding.ECS.PollPendingPathsSystem.entityQueryPrepare	pollpendingpathssystem.html#entityQueryPrepare	
Pathfinding.ECS.PollPendingPathsSystem.jobRepairPathScheduler	pollpendingpathssystem.html#jobRepairPathScheduler	
Pathfinding.ECS.PollPendingPathsSystem.onPathsCalculated	pollpendingpathssystem.html#onPathsCalculated	
Pathfinding.ECS.RVO.AgentIndex.DeletedBit	agentindex.html#DeletedBit	
Pathfinding.ECS.RVO.AgentIndex.Index	agentindex.html#Index	Index of the agent in the simulation's data arrays. \n\n[more in online documentation]
Pathfinding.ECS.RVO.AgentIndex.IndexMask	agentindex.html#IndexMask	
Pathfinding.ECS.RVO.AgentIndex.Valid	agentindex.html#Valid	
Pathfinding.ECS.RVO.AgentIndex.Version	agentindex.html#Version	
Pathfinding.ECS.RVO.AgentIndex.VersionMask	agentindex.html#VersionMask	
Pathfinding.ECS.RVO.AgentIndex.VersionOffset	agentindex.html#VersionOffset	
Pathfinding.ECS.RVO.AgentIndex.packedAgentIndex	agentindex.html#packedAgentIndex	
Pathfinding.ECS.RVO.RVOAgent.Default	rvoagent.html#Default	Good default settings for an RVO agent.
Pathfinding.ECS.RVO.RVOAgent.agentTimeHorizon	rvoagent.html#agentTimeHorizon	How far into the future to look for collisions with other agents (in seconds)
Pathfinding.ECS.RVO.RVOAgent.collidesWith	rvoagent.html#collidesWith	Layer mask specifying which layers this agent will avoid. \n\nYou can set it as CollidesWith = RVOLayer.DefaultAgent | RVOLayer.Layer3 | RVOLayer.Layer6 ...\n\nThis can be very useful in games which have multiple teams of some sort. For example you usually want the agents in one team to avoid each other, but you do not want them to avoid the enemies.\n\nThis field only affects which other agents that this agent will avoid, it does not affect how other agents react to this agent.\n\n[more in online documentation]
Pathfinding.ECS.RVO.RVOAgent.debug	rvoagent.html#debug	Enables drawing debug information in the scene view.
Pathfinding.ECS.RVO.RVOAgent.flowFollowingStrength	rvoagent.html#flowFollowingStrength	
Pathfinding.ECS.RVO.RVOAgent.layer	rvoagent.html#layer	Specifies the avoidance layer for this agent. \n\nThe collidesWith mask on other agents will determine if they will avoid this agent.
Pathfinding.ECS.RVO.RVOAgent.locked	rvoagent.html#locked	A locked unit cannot move. \n\nOther units will still avoid it but avoidance quality is not the best.
Pathfinding.ECS.RVO.RVOAgent.maxNeighbours	rvoagent.html#maxNeighbours	Max number of other agents to take into account. \n\nA smaller value can reduce CPU load, a higher value can lead to better local avoidance quality.
Pathfinding.ECS.RVO.RVOAgent.obstacleTimeHorizon	rvoagent.html#obstacleTimeHorizon	How far into the future to look for collisions with obstacles (in seconds)
Pathfinding.ECS.RVO.RVOAgent.priority	rvoagent.html#priority	How strongly other agents will avoid this agent. \n\nUsually a value between 0 and 1. Agents with similar priorities will avoid each other with an equal strength. If an agent sees another agent with a higher priority than itself it will avoid that agent more strongly. In the extreme case (e.g this agent has a priority of 0 and the other agent has a priority of 1) it will treat the other agent as being a moving obstacle. Similarly if an agent sees another agent with a lower priority than itself it will avoid that agent less.\n\nIn general the avoidance strength for this agent is: <b>[code in online documentation]</b>
Pathfinding.ECS.RVO.RVOAgent.priorityMultiplier	rvoagent.html#priorityMultiplier	Priority multiplier. \n\nThis functions identically to the priority, however it is not exposed in the Unity inspector. It is primarily used by the Pathfinding.RVO.RVODestinationCrowdedBehavior.
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromEntitiesToRVOSimulator.agentData	jobcopyfromentitiestorvosimulator.html#agentData	
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromEntitiesToRVOSimulator.agentOffMeshLinkTraversalLookup	jobcopyfromentitiestorvosimulator.html#agentOffMeshLinkTraversalLookup	
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromEntitiesToRVOSimulator.agentOutputData	jobcopyfromentitiestorvosimulator.html#agentOutputData	
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromEntitiesToRVOSimulator.dt	jobcopyfromentitiestorvosimulator.html#dt	
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromEntitiesToRVOSimulator.movementPlaneMode	jobcopyfromentitiestorvosimulator.html#movementPlaneMode	
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromRVOSimulatorToEntities.MaximumCirclePackingDensity	jobcopyfromrvosimulatortoentities.html#MaximumCirclePackingDensity	See <a href="https://en.wikipedia.org/wiki/Circle_packing">https://en.wikipedia.org/wiki/Circle_packing</a>.
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromRVOSimulatorToEntities.agentDataVersions	jobcopyfromrvosimulatortoentities.html#agentDataVersions	
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromRVOSimulatorToEntities.agentOutputData	jobcopyfromrvosimulatortoentities.html#agentOutputData	
Pathfinding.ECS.RVO.RVOSystem.JobCopyFromRVOSimulatorToEntities.quadtree	jobcopyfromrvosimulatortoentities.html#quadtree	
Pathfinding.ECS.RVO.RVOSystem.agentOffMeshLinkTraversalLookup	rvosystem.html#agentOffMeshLinkTraversalLookup	
Pathfinding.ECS.RVO.RVOSystem.lastSimulator	rvosystem.html#lastSimulator	Keeps track of the last simulator that this RVOSystem saw. \n\nThis is a weak GCHandle to allow it to be stored in an ISystem.
Pathfinding.ECS.RVO.RVOSystem.shouldBeAddedToSimulation	rvosystem.html#shouldBeAddedToSimulation	
Pathfinding.ECS.RVO.RVOSystem.shouldBeRemovedFromSimulation	rvosystem.html#shouldBeRemovedFromSimulation	
Pathfinding.ECS.RVO.RVOSystem.withAgentIndex	rvosystem.html#withAgentIndex	
Pathfinding.ECS.RepairPathSystem.JobCheckStaleness.index	jobcheckstaleness.html#index	
Pathfinding.ECS.RepairPathSystem.JobCheckStaleness.isPathStale	jobcheckstaleness.html#isPathStale	
Pathfinding.ECS.RepairPathSystem.JobRecalculatePaths.index	jobrecalculatepaths.html#index	
Pathfinding.ECS.RepairPathSystem.JobRecalculatePaths.shouldRecalculatePath	jobrecalculatepaths.html#shouldRecalculatePath	
Pathfinding.ECS.RepairPathSystem.JobRecalculatePaths.time	jobrecalculatepaths.html#time	
Pathfinding.ECS.RepairPathSystem.JobShouldRecalculatePaths.index	jobshouldrecalculatepaths.html#index	
Pathfinding.ECS.RepairPathSystem.JobShouldRecalculatePaths.shouldRecalculatePath	jobshouldrecalculatepaths.html#shouldRecalculatePath	
Pathfinding.ECS.RepairPathSystem.JobShouldRecalculatePaths.time	jobshouldrecalculatepaths.html#time	
Pathfinding.ECS.RepairPathSystem.entityQueryOffMeshLink	repairpathsystem.html#entityQueryOffMeshLink	
Pathfinding.ECS.RepairPathSystem.entityQueryOffMeshLinkCleanup	repairpathsystem.html#entityQueryOffMeshLinkCleanup	
Pathfinding.ECS.RepairPathSystem.entityQueryPrepare	repairpathsystem.html#entityQueryPrepare	
Pathfinding.ECS.RepairPathSystem.jobRepairPathScheduler	repairpathsystem.html#jobRepairPathScheduler	
Pathfinding.ECS.ResolvedMovement.rotationSpeed	resolvedmovement.html#rotationSpeed	The speed at which the agent should rotate towards targetRotation + targetRotationOffset, in radians per second.
Pathfinding.ECS.ResolvedMovement.speed	resolvedmovement.html#speed	The speed at which the agent should move towards targetPoint, in meters per second.
Pathfinding.ECS.ResolvedMovement.targetPoint	resolvedmovement.html#targetPoint	The point the agent should move towards.
Pathfinding.ECS.ResolvedMovement.targetRotation	resolvedmovement.html#targetRotation	The desired rotation of the agent, in radians, relative to the current movement plane. \n\n[more in online documentation]
Pathfinding.ECS.ResolvedMovement.targetRotationHint	resolvedmovement.html#targetRotationHint	The desired rotation of the agent, in radians, over a longer time horizon, relative to the current movement plane. \n\nThe targetRotation is usually only over a very short time-horizon, usually a single simulation time step. This variable is used to provide a hint of where the agent wants to rotate to over a slightly longer time scale (on the order of a second or so). It is not used to control movement directly, but it may be used to guide animations, or rotation smoothing.\n\nIf no better hint is available, this should be set to the same value as targetRotation.\n\n[more in online documentation]
Pathfinding.ECS.ResolvedMovement.targetRotationOffset	resolvedmovement.html#targetRotationOffset	Additive modifier to targetRotation, in radians. \n\nThis is used by the local avoidance system to rotate the agent, without this causing a feedback loop. This extra rotation will be ignored by the control system which decides how the agent *wants* to move. It will instead be directly applied to the agent.
Pathfinding.ECS.ResolvedMovement.turningRadiusMultiplier	resolvedmovement.html#turningRadiusMultiplier	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.SyncTransformsToEntitiesJob.entities	synctransformstoentitiesjob.html#entities	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.SyncTransformsToEntitiesJob.entityPositions	synctransformstoentitiesjob.html#entityPositions	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.SyncTransformsToEntitiesJob.movementState	synctransformstoentitiesjob.html#movementState	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.SyncTransformsToEntitiesJob.orientationYAxisForward	synctransformstoentitiesjob.html#orientationYAxisForward	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.SyncTransformsToEntitiesJob.syncPositionWithTransform	synctransformstoentitiesjob.html#syncPositionWithTransform	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.SyncTransformsToEntitiesJob.syncRotationWithTransform	synctransformstoentitiesjob.html#syncRotationWithTransform	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.YAxisForwardToZAxisForward	synctransformstoentitiessystem.html#YAxisForwardToZAxisForward	
Pathfinding.ECS.SyncTransformsToEntitiesSystem.ZAxisForwardToYAxisForward	synctransformstoentitiessystem.html#ZAxisForwardToYAxisForward	
Pathfinding.EditorBase.cachedTooltips	editorbase.html#cachedTooltips	
Pathfinding.EditorBase.cachedURLs	editorbase.html#cachedURLs	
Pathfinding.EditorBase.content	editorbase.html#content	
Pathfinding.EditorBase.getDocumentationURL	editorbase.html#getDocumentationURL	
Pathfinding.EditorBase.noOptions	editorbase.html#noOptions	
Pathfinding.EditorBase.props	editorbase.html#props	
Pathfinding.EditorBase.remainingUnhandledProperties	editorbase.html#remainingUnhandledProperties	
Pathfinding.EditorBase.showInDocContent	editorbase.html#showInDocContent	
Pathfinding.EditorGUILayoutx.dummyList	editorguilayoutx.html#dummyList	
Pathfinding.EditorGUILayoutx.lastUpdateTick	editorguilayoutx.html#lastUpdateTick	
Pathfinding.EditorGUILayoutx.layerNames	editorguilayoutx.html#layerNames	
Pathfinding.EditorResourceHelper.GizmoLineMaterial	editorresourcehelper.html#GizmoLineMaterial	
Pathfinding.EditorResourceHelper.GizmoSurfaceMaterial	editorresourcehelper.html#GizmoSurfaceMaterial	
Pathfinding.EditorResourceHelper.HandlesAALineTexture	editorresourcehelper.html#HandlesAALineTexture	
Pathfinding.EditorResourceHelper.editorAssets	editorresourcehelper.html#editorAssets	Path to the editor assets folder for the A* Pathfinding Project. \n\nIf this path turns out to be incorrect, the script will try to find the correct path \n\n[more in online documentation]
Pathfinding.EditorResourceHelper.handlesAALineTex	editorresourcehelper.html#handlesAALineTex	
Pathfinding.EditorResourceHelper.lineMat	editorresourcehelper.html#lineMat	
Pathfinding.EditorResourceHelper.surfaceMat	editorresourcehelper.html#surfaceMat	
Pathfinding.EndingConditionDistance.maxGScore	endingconditiondistance.html#maxGScore	Max G score a node may have.
Pathfinding.EndingConditionProximity.maxDistance	endingconditionproximity.html#maxDistance	Maximum world distance to the target node before terminating the path.
Pathfinding.Examples.AnimationLinkTraverser.ai	animationlinktraverser.html#ai	
Pathfinding.Examples.AnimationLinkTraverser.anim	animationlinktraverser.html#anim	
Pathfinding.Examples.Astar3DButton.node	astar3dbutton.html#node	
Pathfinding.Examples.BezierMover.averageCurvature	beziermover.html#averageCurvature	
Pathfinding.Examples.BezierMover.points	beziermover.html#points	
Pathfinding.Examples.BezierMover.speed	beziermover.html#speed	
Pathfinding.Examples.BezierMover.tiltAmount	beziermover.html#tiltAmount	
Pathfinding.Examples.BezierMover.tiltSmoothing	beziermover.html#tiltSmoothing	
Pathfinding.Examples.BezierMover.time	beziermover.html#time	
Pathfinding.Examples.DocumentationButton.UrlBase	documentationbutton.html#UrlBase	
Pathfinding.Examples.DocumentationButton.buttonContent	documentationbutton.html#buttonContent	
Pathfinding.Examples.DocumentationButton.page	documentationbutton.html#page	
Pathfinding.Examples.DoorController.bounds	doorcontroller.html#bounds	
Pathfinding.Examples.DoorController.closedtag	doorcontroller.html#closedtag	
Pathfinding.Examples.DoorController.open	doorcontroller.html#open	
Pathfinding.Examples.DoorController.opentag	doorcontroller.html#opentag	
Pathfinding.Examples.DoorController.updateGraphsWithGUO	doorcontroller.html#updateGraphsWithGUO	
Pathfinding.Examples.DoorController.yOffset	doorcontroller.html#yOffset	
Pathfinding.Examples.GroupController.adjustCamera	groupcontroller.html#adjustCamera	
Pathfinding.Examples.GroupController.cam	groupcontroller.html#cam	
Pathfinding.Examples.GroupController.end	groupcontroller.html#end	
Pathfinding.Examples.GroupController.rad2Deg	groupcontroller.html#rad2Deg	Radians to degrees constant.
Pathfinding.Examples.GroupController.selection	groupcontroller.html#selection	
Pathfinding.Examples.GroupController.selectionBox	groupcontroller.html#selectionBox	
Pathfinding.Examples.GroupController.sim	groupcontroller.html#sim	
Pathfinding.Examples.GroupController.start	groupcontroller.html#start	
Pathfinding.Examples.GroupController.wasDown	groupcontroller.html#wasDown	
Pathfinding.Examples.HexagonTrigger.anim	hexagontrigger.html#anim	
Pathfinding.Examples.HexagonTrigger.visible	hexagontrigger.html#visible	
Pathfinding.Examples.HighlightOnHover.highlight	highlightonhover.html#highlight	
Pathfinding.Examples.Interactable.ActivateParticleSystem.particleSystem	activateparticlesystem.html#particleSystem	
Pathfinding.Examples.Interactable.AnimatorPlay.animator	animatorplay.html#animator	
Pathfinding.Examples.Interactable.AnimatorPlay.normalizedTime	animatorplay.html#normalizedTime	
Pathfinding.Examples.Interactable.AnimatorPlay.stateName	animatorplay.html#stateName	
Pathfinding.Examples.Interactable.AnimatorSetBoolAction.animator	animatorsetboolaction.html#animator	
Pathfinding.Examples.Interactable.AnimatorSetBoolAction.propertyName	animatorsetboolaction.html#propertyName	
Pathfinding.Examples.Interactable.AnimatorSetBoolAction.value	animatorsetboolaction.html#value	
Pathfinding.Examples.Interactable.CallFunction.function	callfunction.html#function	
Pathfinding.Examples.Interactable.CoroutineAction	interactable.html#CoroutineAction	
Pathfinding.Examples.Interactable.DelayAction.delay	delayaction.html#delay	
Pathfinding.Examples.Interactable.InstantiatePrefab.position	instantiateprefab.html#position	
Pathfinding.Examples.Interactable.InstantiatePrefab.prefab	instantiateprefab.html#prefab	
Pathfinding.Examples.Interactable.InteractAction.interactable	interactaction.html#interactable	
Pathfinding.Examples.Interactable.MoveToAction.destination	movetoaction.html#destination	
Pathfinding.Examples.Interactable.MoveToAction.useRotation	movetoaction.html#useRotation	
Pathfinding.Examples.Interactable.MoveToAction.waitUntilReached	movetoaction.html#waitUntilReached	
Pathfinding.Examples.Interactable.SetObjectActiveAction.active	setobjectactiveaction.html#active	
Pathfinding.Examples.Interactable.SetObjectActiveAction.target	setobjectactiveaction.html#target	
Pathfinding.Examples.Interactable.SetTransformAction.setPosition	settransformaction.html#setPosition	
Pathfinding.Examples.Interactable.SetTransformAction.setRotation	settransformaction.html#setRotation	
Pathfinding.Examples.Interactable.SetTransformAction.setScale	settransformaction.html#setScale	
Pathfinding.Examples.Interactable.SetTransformAction.source	settransformaction.html#source	
Pathfinding.Examples.Interactable.SetTransformAction.transform	settransformaction.html#transform	
Pathfinding.Examples.Interactable.TeleportAgentAction.destination	teleportagentaction.html#destination	
Pathfinding.Examples.Interactable.TeleportAgentOnLinkAction.Destination	teleportagentonlinkaction.html#Destination	
Pathfinding.Examples.Interactable.TeleportAgentOnLinkAction.destination	teleportagentonlinkaction.html#destination	
Pathfinding.Examples.Interactable.actions	interactable.html#actions	
Pathfinding.Examples.InteractableEditor.actions	interactableeditor.html#actions	
Pathfinding.Examples.LightweightRVO.LightweightAgentData.color	lightweightagentdata.html#color	
Pathfinding.Examples.LightweightRVO.LightweightAgentData.maxSpeed	lightweightagentdata.html#maxSpeed	
Pathfinding.Examples.LightweightRVO.LightweightRVOControlSystem.AlignAgentWithMovementDirectionJob.deltaTime	alignagentwithmovementdirectionjob.html#deltaTime	
Pathfinding.Examples.LightweightRVO.LightweightRVOControlSystem.AlignAgentWithMovementDirectionJob.rotationSpeed	alignagentwithmovementdirectionjob.html#rotationSpeed	
Pathfinding.Examples.LightweightRVO.LightweightRVOControlSystem.JobControlAgents.debug	jobcontrolagents.html#debug	
Pathfinding.Examples.LightweightRVO.LightweightRVOControlSystem.JobControlAgents.deltaTime	jobcontrolagents.html#deltaTime	
Pathfinding.Examples.LightweightRVO.LightweightRVOControlSystem.debug	lightweightrvocontrolsystem.html#debug	Determines what kind of debug info the RVO system should render as gizmos.
Pathfinding.Examples.LightweightRVO.LightweightRVOControlSystem.entityQueryControl	lightweightrvocontrolsystem.html#entityQueryControl	
Pathfinding.Examples.LightweightRVO.LightweightRVOControlSystem.entityQueryDirection	lightweightrvocontrolsystem.html#entityQueryDirection	
Pathfinding.Examples.LightweightRVO.LightweightRVOMoveSystem.JobMoveAgents.deltaTime	jobmoveagents.html#deltaTime	
Pathfinding.Examples.LightweightRVO.LightweightRVOMoveSystem.entityQuery	lightweightrvomovesystem.html#entityQuery	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.JobGenerateMesh.renderingOffset	jobgeneratemesh.html#renderingOffset	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.JobGenerateMesh.tris	jobgeneratemesh.html#tris	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.JobGenerateMesh.verts	jobgeneratemesh.html#verts	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.Vertex.color	vertex.html#color	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.Vertex.position	vertex.html#position	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.Vertex.uv	vertex.html#uv	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.entityQuery	lightweightrvorendersystem.html#entityQuery	
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.material	lightweightrvorendersystem.html#material	Material for rendering.
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.mesh	lightweightrvorendersystem.html#mesh	Mesh for rendering.
Pathfinding.Examples.LightweightRVO.LightweightRVORenderSystem.renderingOffset	lightweightrvorendersystem.html#renderingOffset	Offset with which to render the mesh from the agent's original positions.
Pathfinding.Examples.LightweightRVO.RVOExampleType	lightweightrvo.html#RVOExampleType	
Pathfinding.Examples.LightweightRVO.agentCount	lightweightrvo.html#agentCount	Number of agents created at start.
Pathfinding.Examples.LightweightRVO.agentTimeHorizon	lightweightrvo.html#agentTimeHorizon	How far in the future too look for agents.
Pathfinding.Examples.LightweightRVO.debug	lightweightrvo.html#debug	Bitmas of debugging options to enable for the agents.
Pathfinding.Examples.LightweightRVO.exampleScale	lightweightrvo.html#exampleScale	How large is the area in which the agents are distributed when starting the simulation.
Pathfinding.Examples.LightweightRVO.material	lightweightrvo.html#material	
Pathfinding.Examples.LightweightRVO.maxNeighbours	lightweightrvo.html#maxNeighbours	Max number of neighbour agents to take into account.
Pathfinding.Examples.LightweightRVO.maxSpeed	lightweightrvo.html#maxSpeed	Max speed for an agent.
Pathfinding.Examples.LightweightRVO.obstacleTimeHorizon	lightweightrvo.html#obstacleTimeHorizon	How far in the future too look for obstacles.
Pathfinding.Examples.LightweightRVO.radius	lightweightrvo.html#radius	Agent radius.
Pathfinding.Examples.LightweightRVO.renderingOffset	lightweightrvo.html#renderingOffset	Offset from the agent position the actual drawn postition. \n\nUsed to get rid of z-buffer issues
Pathfinding.Examples.LightweightRVO.type	lightweightrvo.html#type	How the agents are distributed when starting the simulation.
Pathfinding.Examples.LocalSpaceRichAI.graph	localspacerichai.html#graph	Root of the object we are moving on.
Pathfinding.Examples.ManualRVOAgent.rvo	manualrvoagent.html#rvo	
Pathfinding.Examples.ManualRVOAgent.speed	manualrvoagent.html#speed	
Pathfinding.Examples.MecanimBridge.InputMagnitudeKey	mecanimbridge.html#InputMagnitudeKey	
Pathfinding.Examples.MecanimBridge.InputMagnitudeKeyHash	mecanimbridge.html#InputMagnitudeKeyHash	
Pathfinding.Examples.MecanimBridge.NormalizedSpeedKey	mecanimbridge.html#NormalizedSpeedKey	
Pathfinding.Examples.MecanimBridge.NormalizedSpeedKeyHash	mecanimbridge.html#NormalizedSpeedKeyHash	
Pathfinding.Examples.MecanimBridge.XAxisKey	mecanimbridge.html#XAxisKey	
Pathfinding.Examples.MecanimBridge.XAxisKeyHash	mecanimbridge.html#XAxisKeyHash	
Pathfinding.Examples.MecanimBridge.YAxisKey	mecanimbridge.html#YAxisKey	
Pathfinding.Examples.MecanimBridge.YAxisKeyHash	mecanimbridge.html#YAxisKeyHash	
Pathfinding.Examples.MecanimBridge.ai	mecanimbridge.html#ai	Cached reference to the movement script.
Pathfinding.Examples.MecanimBridge.angularVelocitySmoothing	mecanimbridge.html#angularVelocitySmoothing	Smoothing factor for the angular velocity, in seconds. \n\n[more in online documentation]
Pathfinding.Examples.MecanimBridge.anim	mecanimbridge.html#anim	Cached Animator component.
Pathfinding.Examples.MecanimBridge.footTransforms	mecanimbridge.html#footTransforms	Cached reference to the left and right feet.
Pathfinding.Examples.MecanimBridge.naturalSpeed	mecanimbridge.html#naturalSpeed	
Pathfinding.Examples.MecanimBridge.prevFootPos	mecanimbridge.html#prevFootPos	Position of the left and right feet during the previous frame.
Pathfinding.Examples.MecanimBridge.smoothedRotationSpeed	mecanimbridge.html#smoothedRotationSpeed	
Pathfinding.Examples.MecanimBridge.smoothedVelocity	mecanimbridge.html#smoothedVelocity	
Pathfinding.Examples.MecanimBridge.tr	mecanimbridge.html#tr	Cached Transform component.
Pathfinding.Examples.MecanimBridge.velocitySmoothing	mecanimbridge.html#velocitySmoothing	Smoothing factor for the velocity, in seconds.
Pathfinding.Examples.MecanimBridge2D.RotationMode	mecanimbridge2d.html#RotationMode	
Pathfinding.Examples.MecanimBridge2D.ai	mecanimbridge2d.html#ai	Cached reference to the movement script.
Pathfinding.Examples.MecanimBridge2D.anim	mecanimbridge2d.html#anim	Cached Animator component.
Pathfinding.Examples.MecanimBridge2D.naturalSpeed	mecanimbridge2d.html#naturalSpeed	The natural movement speed is the speed that the animations are designed for. \n\nOne can for example configure the animator to speed up the animation if the agent moves faster than this, or slow it down if the agent moves slower than this.
Pathfinding.Examples.MecanimBridge2D.rotationMode	mecanimbridge2d.html#rotationMode	How the agent's rotation is handled. \n\n[more in online documentation]
Pathfinding.Examples.MecanimBridge2D.smoothedVelocity	mecanimbridge2d.html#smoothedVelocity	
Pathfinding.Examples.MecanimBridge2D.velocitySmoothing	mecanimbridge2d.html#velocitySmoothing	How much to smooth the velocity of the agent. \n\nThe velocity will be smoothed out over approximately this number of seconds. A value of zero indicates no smoothing.
Pathfinding.Examples.MineBotAnimation.NormalizedSpeedKey	minebotanimation.html#NormalizedSpeedKey	
Pathfinding.Examples.MineBotAnimation.NormalizedSpeedKeyHash	minebotanimation.html#NormalizedSpeedKeyHash	
Pathfinding.Examples.MineBotAnimation.ai	minebotanimation.html#ai	
Pathfinding.Examples.MineBotAnimation.anim	minebotanimation.html#anim	Animator component.
Pathfinding.Examples.MineBotAnimation.endOfPathEffect	minebotanimation.html#endOfPathEffect	Effect which will be instantiated when end of path is reached. \n\n[more in online documentation]
Pathfinding.Examples.MineBotAnimation.isAtEndOfPath	minebotanimation.html#isAtEndOfPath	
Pathfinding.Examples.MineBotAnimation.lastTarget	minebotanimation.html#lastTarget	Point for the last spawn of endOfPathEffect.
Pathfinding.Examples.MineBotAnimation.naturalSpeed	minebotanimation.html#naturalSpeed	The natural movement speed is the speed that the animations are designed for. \n\nOne can for example configure the animator to speed up the animation if the agent moves faster than this, or slow it down if the agent moves slower than this.
Pathfinding.Examples.MineBotAnimation.tr	minebotanimation.html#tr	
Pathfinding.Examples.ObjectPlacer.alignToSurface	objectplacer.html#alignToSurface	Align created objects to the surface normal where it is created.
Pathfinding.Examples.ObjectPlacer.direct	objectplacer.html#direct	Flush Graph Updates directly after placing. \n\nSlower, but updates are applied immidiately
Pathfinding.Examples.ObjectPlacer.go	objectplacer.html#go	GameObject to place. \n\nWhen using a Grid Graph you need to make sure the object's layer is included in the collision mask in the GridGraph settings.
Pathfinding.Examples.ObjectPlacer.issueGUOs	objectplacer.html#issueGUOs	Issue a graph update object after placement.
Pathfinding.Examples.ObjectPlacer.lastPlacedTime	objectplacer.html#lastPlacedTime	
Pathfinding.Examples.ObjectPlacer.offset	objectplacer.html#offset	Global offset of the placed object relative to the mouse cursor.
Pathfinding.Examples.ObjectPlacer.randomizeRotation	objectplacer.html#randomizeRotation	Randomize rotation of the placed object.
Pathfinding.Examples.PathTypesDemo.DemoMode	pathtypesdemo.html#DemoMode	
Pathfinding.Examples.PathTypesDemo.activeDemo	pathtypesdemo.html#activeDemo	
Pathfinding.Examples.PathTypesDemo.aimStrength	pathtypesdemo.html#aimStrength	
Pathfinding.Examples.PathTypesDemo.constantPathMeshGo	pathtypesdemo.html#constantPathMeshGo	
Pathfinding.Examples.PathTypesDemo.end	pathtypesdemo.html#end	Target point of paths.
Pathfinding.Examples.PathTypesDemo.lastFloodPath	pathtypesdemo.html#lastFloodPath	
Pathfinding.Examples.PathTypesDemo.lastPath	pathtypesdemo.html#lastPath	
Pathfinding.Examples.PathTypesDemo.lastRender	pathtypesdemo.html#lastRender	
Pathfinding.Examples.PathTypesDemo.lineMat	pathtypesdemo.html#lineMat	Material used for rendering paths.
Pathfinding.Examples.PathTypesDemo.lineWidth	pathtypesdemo.html#lineWidth	
Pathfinding.Examples.PathTypesDemo.multipoints	pathtypesdemo.html#multipoints	
Pathfinding.Examples.PathTypesDemo.onlyShortestPath	pathtypesdemo.html#onlyShortestPath	
Pathfinding.Examples.PathTypesDemo.pathOffset	pathtypesdemo.html#pathOffset	Offset from the real path to where it is rendered. \n\nUsed to avoid z-fighting
Pathfinding.Examples.PathTypesDemo.searchLength	pathtypesdemo.html#searchLength	
Pathfinding.Examples.PathTypesDemo.spread	pathtypesdemo.html#spread	
Pathfinding.Examples.PathTypesDemo.squareMat	pathtypesdemo.html#squareMat	Material used for rendering result of the ConstantPath.
Pathfinding.Examples.PathTypesDemo.start	pathtypesdemo.html#start	Start of paths.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.density	proceduralprefab.html#density	Number of objects per square world unit.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.maxScale	proceduralprefab.html#maxScale	Maximum scale of prefab.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.minScale	proceduralprefab.html#minScale	Minimum scale of prefab.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.perlin	proceduralprefab.html#perlin	Multiply by [perlin noise]. \n\nValue from 0 to 1 indicating weight.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.perlinOffset	proceduralprefab.html#perlinOffset	Some offset to avoid identical density maps.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.perlinPower	proceduralprefab.html#perlinPower	Perlin will be raised to this power. \n\nA higher value gives more distinct edges
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.perlinScale	proceduralprefab.html#perlinScale	Perlin noise scale. \n\nA higher value spreads out the maximums and minimums of the density.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.prefab	proceduralprefab.html#prefab	Prefab to use.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.random	proceduralprefab.html#random	Multiply by [random]. \n\nValue from 0 to 1 indicating weight.
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.randomRotation	proceduralprefab.html#randomRotation	
Pathfinding.Examples.ProceduralWorld.ProceduralPrefab.singleFixed	proceduralprefab.html#singleFixed	If checked, a single object will be created in the center of each tile.
Pathfinding.Examples.ProceduralWorld.ProceduralTile.destroyed	proceduraltile.html#destroyed	
Pathfinding.Examples.ProceduralWorld.ProceduralTile.ie	proceduraltile.html#ie	
Pathfinding.Examples.ProceduralWorld.ProceduralTile.rnd	proceduraltile.html#rnd	
Pathfinding.Examples.ProceduralWorld.ProceduralTile.root	proceduraltile.html#root	
Pathfinding.Examples.ProceduralWorld.ProceduralTile.world	proceduraltile.html#world	
Pathfinding.Examples.ProceduralWorld.ProceduralTile.x	proceduraltile.html#x	
Pathfinding.Examples.ProceduralWorld.ProceduralTile.z	proceduraltile.html#z	
Pathfinding.Examples.ProceduralWorld.RotationRandomness	proceduralworld.html#RotationRandomness	
Pathfinding.Examples.ProceduralWorld.disableAsyncLoadWithinRange	proceduralworld.html#disableAsyncLoadWithinRange	
Pathfinding.Examples.ProceduralWorld.prefabs	proceduralworld.html#prefabs	
Pathfinding.Examples.ProceduralWorld.range	proceduralworld.html#range	How far away to generate tiles.
Pathfinding.Examples.ProceduralWorld.staticBatching	proceduralworld.html#staticBatching	Enable static batching on generated tiles. \n\nWill improve overall FPS, but might cause FPS drops on some frames when static batching is done
Pathfinding.Examples.ProceduralWorld.subTiles	proceduralworld.html#subTiles	
Pathfinding.Examples.ProceduralWorld.target	proceduralworld.html#target	
Pathfinding.Examples.ProceduralWorld.tileGenerationQueue	proceduralworld.html#tileGenerationQueue	
Pathfinding.Examples.ProceduralWorld.tileSize	proceduralworld.html#tileSize	World size of tiles.
Pathfinding.Examples.ProceduralWorld.tiles	proceduralworld.html#tiles	All tiles.
Pathfinding.Examples.RTS.BTContext.animator	btcontext.html#animator	
Pathfinding.Examples.RTS.BTContext.transform	btcontext.html#transform	
Pathfinding.Examples.RTS.BTContext.unit	btcontext.html#unit	
Pathfinding.Examples.RTS.BTMove.destination	btmove.html#destination	
Pathfinding.Examples.RTS.BTNode.lastStatus	btnode.html#lastStatus	
Pathfinding.Examples.RTS.BTSelector.childIndex	btselector.html#childIndex	
Pathfinding.Examples.RTS.BTSelector.children	btselector.html#children	
Pathfinding.Examples.RTS.BTSequence.childIndex	btsequence.html#childIndex	
Pathfinding.Examples.RTS.BTSequence.children	btsequence.html#children	
Pathfinding.Examples.RTS.BTTransparent.child	bttransparent.html#child	
Pathfinding.Examples.RTS.Binding.getter	binding.html#getter	
Pathfinding.Examples.RTS.Binding.setter	binding.html#setter	
Pathfinding.Examples.RTS.Binding.val	binding.html#val	
Pathfinding.Examples.RTS.Binding.value	binding.html#value	
Pathfinding.Examples.RTS.Condition.predicate	condition.html#predicate	
Pathfinding.Examples.RTS.FindClosestUnit.reserve	findclosestunit.html#reserve	
Pathfinding.Examples.RTS.FindClosestUnit.target	findclosestunit.html#target	
Pathfinding.Examples.RTS.FindClosestUnit.type	findclosestunit.html#type	
Pathfinding.Examples.RTS.Harvest.duration	harvest.html#duration	
Pathfinding.Examples.RTS.Harvest.resource	harvest.html#resource	
Pathfinding.Examples.RTS.Harvest.time	harvest.html#time	
Pathfinding.Examples.RTS.MovementMode	rts.html#MovementMode	
Pathfinding.Examples.RTS.Once.child	once.html#child	
Pathfinding.Examples.RTS.RTSAudio.Source.available	source.html#available	
Pathfinding.Examples.RTS.RTSAudio.Source.source	source.html#source	
Pathfinding.Examples.RTS.RTSAudio.sources	rtsaudio.html#sources	
Pathfinding.Examples.RTS.RTSBuildingBarracks.UnitItem.buildingTime	unititem.html#buildingTime	
Pathfinding.Examples.RTS.RTSBuildingBarracks.UnitItem.cost	unititem.html#cost	
Pathfinding.Examples.RTS.RTSBuildingBarracks.UnitItem.menuItem	unititem.html#menuItem	
Pathfinding.Examples.RTS.RTSBuildingBarracks.UnitItem.prefab	unititem.html#prefab	
Pathfinding.Examples.RTS.RTSBuildingBarracks.items	rtsbuildingbarracks.html#items	
Pathfinding.Examples.RTS.RTSBuildingBarracks.maxQueueSize	rtsbuildingbarracks.html#maxQueueSize	
Pathfinding.Examples.RTS.RTSBuildingBarracks.menu	rtsbuildingbarracks.html#menu	
Pathfinding.Examples.RTS.RTSBuildingBarracks.queue	rtsbuildingbarracks.html#queue	
Pathfinding.Examples.RTS.RTSBuildingBarracks.queueProgressFraction	rtsbuildingbarracks.html#queueProgressFraction	
Pathfinding.Examples.RTS.RTSBuildingBarracks.queueStartTime	rtsbuildingbarracks.html#queueStartTime	
Pathfinding.Examples.RTS.RTSBuildingBarracks.rallyPoint	rtsbuildingbarracks.html#rallyPoint	
Pathfinding.Examples.RTS.RTSBuildingBarracks.spawnPoint	rtsbuildingbarracks.html#spawnPoint	
Pathfinding.Examples.RTS.RTSBuildingBarracks.unit	rtsbuildingbarracks.html#unit	
Pathfinding.Examples.RTS.RTSBuildingButton.cost	rtsbuildingbutton.html#cost	
Pathfinding.Examples.RTS.RTSBuildingButton.prefab	rtsbuildingbutton.html#prefab	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.UIItem.QueItem.icon	queitem.html#icon	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.UIItem.QueItem.progress	queitem.html#progress	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.UIItem.QueItem.root	queitem.html#root	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.UIItem.parent	uiitem.html#parent	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.UIItem.queItems	uiitem.html#queItems	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.building	rtsbuildingqueueui.html#building	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.item	rtsbuildingqueueui.html#item	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.prefab	rtsbuildingqueueui.html#prefab	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.screenOffset	rtsbuildingqueueui.html#screenOffset	
Pathfinding.Examples.RTS.RTSBuildingQueueUI.worldOffset	rtsbuildingqueueui.html#worldOffset	
Pathfinding.Examples.RTS.RTSHarvestableResource.harvestable	rtsharvestableresource.html#harvestable	
Pathfinding.Examples.RTS.RTSHarvestableResource.resourceType	rtsharvestableresource.html#resourceType	
Pathfinding.Examples.RTS.RTSHarvestableResource.value	rtsharvestableresource.html#value	
Pathfinding.Examples.RTS.RTSHarvester.animator	rtsharvester.html#animator	
Pathfinding.Examples.RTS.RTSHarvester.behave	rtsharvester.html#behave	
Pathfinding.Examples.RTS.RTSHarvester.ctx	rtsharvester.html#ctx	
Pathfinding.Examples.RTS.RTSHarvester.unit	rtsharvester.html#unit	
Pathfinding.Examples.RTS.RTSManager.PlayerCount	rtsmanager.html#PlayerCount	
Pathfinding.Examples.RTS.RTSManager.audioManager	rtsmanager.html#audioManager	
Pathfinding.Examples.RTS.RTSManager.instance	rtsmanager.html#instance	
Pathfinding.Examples.RTS.RTSManager.players	rtsmanager.html#players	
Pathfinding.Examples.RTS.RTSManager.units	rtsmanager.html#units	
Pathfinding.Examples.RTS.RTSPlayer.index	rtsplayer.html#index	
Pathfinding.Examples.RTS.RTSPlayer.resources	rtsplayer.html#resources	
Pathfinding.Examples.RTS.RTSPlayerResources.resources	rtsplayerresources.html#resources	
Pathfinding.Examples.RTS.RTSResourceDeterioration.initialResources	rtsresourcedeterioration.html#initialResources	
Pathfinding.Examples.RTS.RTSResourceDeterioration.maxOffset	rtsresourcedeterioration.html#maxOffset	
Pathfinding.Examples.RTS.RTSResourceDeterioration.offsetRoot	rtsresourcedeterioration.html#offsetRoot	
Pathfinding.Examples.RTS.RTSResourceDeterioration.resource	rtsresourcedeterioration.html#resource	
Pathfinding.Examples.RTS.RTSResourceView.Item.label	item.html#label	
Pathfinding.Examples.RTS.RTSResourceView.Item.name	item.html#name	
Pathfinding.Examples.RTS.RTSResourceView.Item.resource	item.html#resource	
Pathfinding.Examples.RTS.RTSResourceView.Item.smoothedValue	item.html#smoothedValue	
Pathfinding.Examples.RTS.RTSResourceView.adjustmentSpeed	rtsresourceview.html#adjustmentSpeed	
Pathfinding.Examples.RTS.RTSResourceView.items	rtsresourceview.html#items	
Pathfinding.Examples.RTS.RTSResourceView.team	rtsresourceview.html#team	
Pathfinding.Examples.RTS.RTSTimedDestruction.time	rtstimeddestruction.html#time	
Pathfinding.Examples.RTS.RTSUI.Menu.itemPrefab	menu.html#itemPrefab	
Pathfinding.Examples.RTS.RTSUI.Menu.root	menu.html#root	
Pathfinding.Examples.RTS.RTSUI.MenuItem.description	menuitem.html#description	
Pathfinding.Examples.RTS.RTSUI.MenuItem.icon	menuitem.html#icon	
Pathfinding.Examples.RTS.RTSUI.MenuItem.label	menuitem.html#label	
Pathfinding.Examples.RTS.RTSUI.State	rtsui.html#State	
Pathfinding.Examples.RTS.RTSUI.active	rtsui.html#active	
Pathfinding.Examples.RTS.RTSUI.activeMenu	rtsui.html#activeMenu	
Pathfinding.Examples.RTS.RTSUI.buildingInfo	rtsui.html#buildingInfo	
Pathfinding.Examples.RTS.RTSUI.buildingPreview	rtsui.html#buildingPreview	
Pathfinding.Examples.RTS.RTSUI.click	rtsui.html#click	
Pathfinding.Examples.RTS.RTSUI.clickFallback	rtsui.html#clickFallback	
Pathfinding.Examples.RTS.RTSUI.dragStart	rtsui.html#dragStart	
Pathfinding.Examples.RTS.RTSUI.groundMask	rtsui.html#groundMask	
Pathfinding.Examples.RTS.RTSUI.hasSelected	rtsui.html#hasSelected	
Pathfinding.Examples.RTS.RTSUI.ignoreFrame	rtsui.html#ignoreFrame	
Pathfinding.Examples.RTS.RTSUI.menuItemPrefab	rtsui.html#menuItemPrefab	
Pathfinding.Examples.RTS.RTSUI.menuRoot	rtsui.html#menuRoot	
Pathfinding.Examples.RTS.RTSUI.notEnoughResources	rtsui.html#notEnoughResources	
Pathfinding.Examples.RTS.RTSUI.selectionBox	rtsui.html#selectionBox	
Pathfinding.Examples.RTS.RTSUI.state	rtsui.html#state	
Pathfinding.Examples.RTS.RTSUI.worldSpaceUI	rtsui.html#worldSpaceUI	
Pathfinding.Examples.RTS.RTSUnit.OnUpdateDelegate	rtsunit.html#OnUpdateDelegate	
Pathfinding.Examples.RTS.RTSUnit.Type	rtsunit.html#Type	
Pathfinding.Examples.RTS.RTSUnit.ai	rtsunit.html#ai	
Pathfinding.Examples.RTS.RTSUnit.attackTarget	rtsunit.html#attackTarget	
Pathfinding.Examples.RTS.RTSUnit.deathEffect	rtsunit.html#deathEffect	
Pathfinding.Examples.RTS.RTSUnit.detectionRange	rtsunit.html#detectionRange	
Pathfinding.Examples.RTS.RTSUnit.health	rtsunit.html#health	
Pathfinding.Examples.RTS.RTSUnit.lastDestination	rtsunit.html#lastDestination	
Pathfinding.Examples.RTS.RTSUnit.lastSeenAttackTarget	rtsunit.html#lastSeenAttackTarget	
Pathfinding.Examples.RTS.RTSUnit.locked	rtsunit.html#locked	
Pathfinding.Examples.RTS.RTSUnit.mSelected	rtsunit.html#mSelected	
Pathfinding.Examples.RTS.RTSUnit.maxHealth	rtsunit.html#maxHealth	
Pathfinding.Examples.RTS.RTSUnit.movementMode	rtsunit.html#movementMode	
Pathfinding.Examples.RTS.RTSUnit.onMakeActiveUnit	rtsunit.html#onMakeActiveUnit	
Pathfinding.Examples.RTS.RTSUnit.owner	rtsunit.html#owner	
Pathfinding.Examples.RTS.RTSUnit.position	rtsunit.html#position	Position at the start of the current frame.
Pathfinding.Examples.RTS.RTSUnit.radius	rtsunit.html#radius	
Pathfinding.Examples.RTS.RTSUnit.reachedDestination	rtsunit.html#reachedDestination	
Pathfinding.Examples.RTS.RTSUnit.reservedBy	rtsunit.html#reservedBy	
Pathfinding.Examples.RTS.RTSUnit.resource	rtsunit.html#resource	
Pathfinding.Examples.RTS.RTSUnit.rvo	rtsunit.html#rvo	
Pathfinding.Examples.RTS.RTSUnit.selected	rtsunit.html#selected	
Pathfinding.Examples.RTS.RTSUnit.selectionIndicator	rtsunit.html#selectionIndicator	
Pathfinding.Examples.RTS.RTSUnit.selectionIndicatorEnabled	rtsunit.html#selectionIndicatorEnabled	
Pathfinding.Examples.RTS.RTSUnit.storedCrystals	rtsunit.html#storedCrystals	
Pathfinding.Examples.RTS.RTSUnit.team	rtsunit.html#team	
Pathfinding.Examples.RTS.RTSUnit.transform	rtsunit.html#transform	
Pathfinding.Examples.RTS.RTSUnit.type	rtsunit.html#type	
Pathfinding.Examples.RTS.RTSUnit.weapon	rtsunit.html#weapon	
Pathfinding.Examples.RTS.RTSUnitBuilder.BuildingItem.cost	buildingitem.html#cost	
Pathfinding.Examples.RTS.RTSUnitBuilder.BuildingItem.menuItem	buildingitem.html#menuItem	
Pathfinding.Examples.RTS.RTSUnitBuilder.BuildingItem.prefab	buildingitem.html#prefab	
Pathfinding.Examples.RTS.RTSUnitBuilder.items	rtsunitbuilder.html#items	
Pathfinding.Examples.RTS.RTSUnitBuilder.menu	rtsunitbuilder.html#menu	
Pathfinding.Examples.RTS.RTSUnitBuilder.unit	rtsunitbuilder.html#unit	
Pathfinding.Examples.RTS.RTSUnitManager.activeUnit	rtsunitmanager.html#activeUnit	
Pathfinding.Examples.RTS.RTSUnitManager.batchSelection	rtsunitmanager.html#batchSelection	
Pathfinding.Examples.RTS.RTSUnitManager.cam	rtsunitmanager.html#cam	
Pathfinding.Examples.RTS.RTSUnitManager.mActiveUnit	rtsunitmanager.html#mActiveUnit	
Pathfinding.Examples.RTS.RTSUnitManager.selectedUnits	rtsunitmanager.html#selectedUnits	
Pathfinding.Examples.RTS.RTSUnitManager.units	rtsunitmanager.html#units	
Pathfinding.Examples.RTS.RTSWaveSpawner.Wave.count	wave.html#count	
Pathfinding.Examples.RTS.RTSWaveSpawner.Wave.delay	wave.html#delay	
Pathfinding.Examples.RTS.RTSWaveSpawner.Wave.health	wave.html#health	
Pathfinding.Examples.RTS.RTSWaveSpawner.Wave.prefab	wave.html#prefab	
Pathfinding.Examples.RTS.RTSWaveSpawner.Wave.spawnPoint	wave.html#spawnPoint	
Pathfinding.Examples.RTS.RTSWaveSpawner.target	rtswavespawner.html#target	
Pathfinding.Examples.RTS.RTSWaveSpawner.team	rtswavespawner.html#team	
Pathfinding.Examples.RTS.RTSWaveSpawner.waveCounter	rtswavespawner.html#waveCounter	
Pathfinding.Examples.RTS.RTSWaveSpawner.waves	rtswavespawner.html#waves	
Pathfinding.Examples.RTS.RTSWeapon.attackDuration	rtsweapon.html#attackDuration	
Pathfinding.Examples.RTS.RTSWeapon.canMoveWhileAttacking	rtsweapon.html#canMoveWhileAttacking	
Pathfinding.Examples.RTS.RTSWeapon.cooldown	rtsweapon.html#cooldown	
Pathfinding.Examples.RTS.RTSWeapon.isAttacking	rtsweapon.html#isAttacking	
Pathfinding.Examples.RTS.RTSWeapon.lastAttackTime	rtsweapon.html#lastAttackTime	
Pathfinding.Examples.RTS.RTSWeapon.range	rtsweapon.html#range	
Pathfinding.Examples.RTS.RTSWeapon.ranged	rtsweapon.html#ranged	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.damage	rtsweaponsimpleranged.html#damage	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.rotationRootY	rtsweaponsimpleranged.html#rotationRootY	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.rotationSpeed	rtsweaponsimpleranged.html#rotationSpeed	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.sfx	rtsweaponsimpleranged.html#sfx	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.sourceEffect	rtsweaponsimpleranged.html#sourceEffect	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.sourceEffectRoot	rtsweaponsimpleranged.html#sourceEffectRoot	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.targetEffect	rtsweaponsimpleranged.html#targetEffect	
Pathfinding.Examples.RTS.RTSWeaponSimpleRanged.volume	rtsweaponsimpleranged.html#volume	
Pathfinding.Examples.RTS.RTSWorldSpaceUI.Item.screenOffset	item2.html#screenOffset	
Pathfinding.Examples.RTS.RTSWorldSpaceUI.Item.tracking	item2.html#tracking	
Pathfinding.Examples.RTS.RTSWorldSpaceUI.Item.transform	item2.html#transform	
Pathfinding.Examples.RTS.RTSWorldSpaceUI.Item.valid	item2.html#valid	
Pathfinding.Examples.RTS.RTSWorldSpaceUI.Item.worldOffset	item2.html#worldOffset	
Pathfinding.Examples.RTS.RTSWorldSpaceUI.items	rtsworldspaceui.html#items	
Pathfinding.Examples.RTS.RTSWorldSpaceUI.worldCamera	rtsworldspaceui.html#worldCamera	
Pathfinding.Examples.RTS.ResourceType	rts.html#ResourceType	
Pathfinding.Examples.RTS.SimpleAction.action	simpleaction.html#action	
Pathfinding.Examples.RTS.Status	rts.html#Status	
Pathfinding.Examples.RTS.Value.Bound	value.html#Bound	
Pathfinding.Examples.RTS.Value.binding	value.html#binding	
Pathfinding.Examples.RTS.Value.val	value.html#val	
Pathfinding.Examples.RTS.Value.value	value.html#value	
Pathfinding.Examples.RTSTiltInMovementDirection.accelerationFraction	rtstiltinmovementdirection.html#accelerationFraction	
Pathfinding.Examples.RTSTiltInMovementDirection.ai	rtstiltinmovementdirection.html#ai	
Pathfinding.Examples.RTSTiltInMovementDirection.amount	rtstiltinmovementdirection.html#amount	
Pathfinding.Examples.RTSTiltInMovementDirection.lastVelocity	rtstiltinmovementdirection.html#lastVelocity	
Pathfinding.Examples.RTSTiltInMovementDirection.motorSound	rtstiltinmovementdirection.html#motorSound	
Pathfinding.Examples.RTSTiltInMovementDirection.smoothAcceleration	rtstiltinmovementdirection.html#smoothAcceleration	
Pathfinding.Examples.RTSTiltInMovementDirection.soundAdjustmentSpeed	rtstiltinmovementdirection.html#soundAdjustmentSpeed	
Pathfinding.Examples.RTSTiltInMovementDirection.soundGain	rtstiltinmovementdirection.html#soundGain	
Pathfinding.Examples.RTSTiltInMovementDirection.soundIdleVolume	rtstiltinmovementdirection.html#soundIdleVolume	
Pathfinding.Examples.RTSTiltInMovementDirection.soundPitchGain	rtstiltinmovementdirection.html#soundPitchGain	
Pathfinding.Examples.RTSTiltInMovementDirection.speed	rtstiltinmovementdirection.html#speed	
Pathfinding.Examples.RTSTiltInMovementDirection.target	rtstiltinmovementdirection.html#target	
Pathfinding.Examples.RVOAgentPlacer.agents	rvoagentplacer.html#agents	
Pathfinding.Examples.RVOAgentPlacer.goalOffset	rvoagentplacer.html#goalOffset	
Pathfinding.Examples.RVOAgentPlacer.mask	rvoagentplacer.html#mask	
Pathfinding.Examples.RVOAgentPlacer.prefab	rvoagentplacer.html#prefab	
Pathfinding.Examples.RVOAgentPlacer.rad2Deg	rvoagentplacer.html#rad2Deg	
Pathfinding.Examples.RVOAgentPlacer.repathRate	rvoagentplacer.html#repathRate	
Pathfinding.Examples.RVOAgentPlacer.ringSize	rvoagentplacer.html#ringSize	
Pathfinding.Examples.RVOExampleAgent.canSearchAgain	rvoexampleagent.html#canSearchAgain	
Pathfinding.Examples.RVOExampleAgent.controller	rvoexampleagent.html#controller	
Pathfinding.Examples.RVOExampleAgent.groundMask	rvoexampleagent.html#groundMask	
Pathfinding.Examples.RVOExampleAgent.maxSpeed	rvoexampleagent.html#maxSpeed	
Pathfinding.Examples.RVOExampleAgent.moveNextDist	rvoexampleagent.html#moveNextDist	
Pathfinding.Examples.RVOExampleAgent.nextRepath	rvoexampleagent.html#nextRepath	
Pathfinding.Examples.RVOExampleAgent.path	rvoexampleagent.html#path	
Pathfinding.Examples.RVOExampleAgent.rends	rvoexampleagent.html#rends	
Pathfinding.Examples.RVOExampleAgent.repathRate	rvoexampleagent.html#repathRate	
Pathfinding.Examples.RVOExampleAgent.seeker	rvoexampleagent.html#seeker	
Pathfinding.Examples.RVOExampleAgent.slowdownDistance	rvoexampleagent.html#slowdownDistance	
Pathfinding.Examples.RVOExampleAgent.target	rvoexampleagent.html#target	
Pathfinding.Examples.RVOExampleAgent.vectorPath	rvoexampleagent.html#vectorPath	
Pathfinding.Examples.RVOExampleAgent.wp	rvoexampleagent.html#wp	
Pathfinding.Examples.SmoothCameraFollow.damping	smoothcamerafollow.html#damping	
Pathfinding.Examples.SmoothCameraFollow.distance	smoothcamerafollow.html#distance	
Pathfinding.Examples.SmoothCameraFollow.enableRotation	smoothcamerafollow.html#enableRotation	
Pathfinding.Examples.SmoothCameraFollow.height	smoothcamerafollow.html#height	
Pathfinding.Examples.SmoothCameraFollow.rotationDamping	smoothcamerafollow.html#rotationDamping	
Pathfinding.Examples.SmoothCameraFollow.smoothRotation	smoothcamerafollow.html#smoothRotation	
Pathfinding.Examples.SmoothCameraFollow.staticOffset	smoothcamerafollow.html#staticOffset	
Pathfinding.Examples.SmoothCameraFollow.target	smoothcamerafollow.html#target	
Pathfinding.Examples.TurnBasedAI.blockManager	turnbasedai.html#blockManager	
Pathfinding.Examples.TurnBasedAI.blocker	turnbasedai.html#blocker	
Pathfinding.Examples.TurnBasedAI.movementPoints	turnbasedai.html#movementPoints	
Pathfinding.Examples.TurnBasedAI.targetNode	turnbasedai.html#targetNode	
Pathfinding.Examples.TurnBasedAI.traversalProvider	turnbasedai.html#traversalProvider	
Pathfinding.Examples.TurnBasedDoor.animator	turnbaseddoor.html#animator	
Pathfinding.Examples.TurnBasedDoor.blocker	turnbaseddoor.html#blocker	
Pathfinding.Examples.TurnBasedDoor.open	turnbaseddoor.html#open	
Pathfinding.Examples.TurnBasedManager.State	turnbasedmanager.html#State	
Pathfinding.Examples.TurnBasedManager.eventSystem	turnbasedmanager.html#eventSystem	
Pathfinding.Examples.TurnBasedManager.layerMask	turnbasedmanager.html#layerMask	
Pathfinding.Examples.TurnBasedManager.movementSpeed	turnbasedmanager.html#movementSpeed	
Pathfinding.Examples.TurnBasedManager.nodePrefab	turnbasedmanager.html#nodePrefab	
Pathfinding.Examples.TurnBasedManager.possibleMoves	turnbasedmanager.html#possibleMoves	
Pathfinding.Examples.TurnBasedManager.selected	turnbasedmanager.html#selected	
Pathfinding.Examples.TurnBasedManager.state	turnbasedmanager.html#state	
Pathfinding.FadeArea.animationSpeed	fadearea.html#animationSpeed	
Pathfinding.FadeArea.areaStyle	fadearea.html#areaStyle	
Pathfinding.FadeArea.editor	fadearea.html#editor	
Pathfinding.FadeArea.fancyEffects	fadearea.html#fancyEffects	Animate dropdowns when they open and close.
Pathfinding.FadeArea.labelStyle	fadearea.html#labelStyle	
Pathfinding.FadeArea.lastRect	fadearea.html#lastRect	
Pathfinding.FadeArea.lastUpdate	fadearea.html#lastUpdate	
Pathfinding.FadeArea.open	fadearea.html#open	Is this area open. \n\nThis is not the same as if any contents are visible, use BeginFade for that.
Pathfinding.FadeArea.value	fadearea.html#value	
Pathfinding.FadeArea.visible	fadearea.html#visible	
Pathfinding.FakeTransform.position	faketransform.html#position	
Pathfinding.FakeTransform.rotation	faketransform.html#rotation	
Pathfinding.FloodPath.TemporaryNodeBit	floodpath.html#TemporaryNodeBit	
Pathfinding.FloodPath.originalStartPoint	floodpath.html#originalStartPoint	
Pathfinding.FloodPath.parents	floodpath.html#parents	
Pathfinding.FloodPath.saveParents	floodpath.html#saveParents	If false, will not save any information. \n\nUsed by some internal parts of the system which doesn't need it.
Pathfinding.FloodPath.startNode	floodpath.html#startNode	
Pathfinding.FloodPath.startPoint	floodpath.html#startPoint	
Pathfinding.FloodPath.validationHash	floodpath.html#validationHash	
Pathfinding.FloodPathConstraint.path	floodpathconstraint.html#path	
Pathfinding.FloodPathTracer.flood	floodpathtracer.html#flood	Reference to the FloodPath which searched the path originally.
Pathfinding.FloodPathTracer.hasEndPoint	floodpathtracer.html#hasEndPoint	Determines if a search for an end node should be done. \n\nSet by different path types. \n\n[more in online documentation]
Pathfinding.FollowerEntity.FollowerEntityMigrations	followerentity.html#FollowerEntityMigrations	
Pathfinding.FollowerEntity.ScratchNNConstraint	followerentity.html#ScratchNNConstraint	Cached NNConstraint, to avoid allocations.
Pathfinding.FollowerEntity.ShapeGizmoColor	followerentity.html#ShapeGizmoColor	
Pathfinding.FollowerEntity.achetypeWorld	followerentity.html#achetypeWorld	
Pathfinding.FollowerEntity.agentCylinderShapeAccessRO	followerentity.html#agentCylinderShapeAccessRO	
Pathfinding.FollowerEntity.agentCylinderShapeAccessRW	followerentity.html#agentCylinderShapeAccessRW	
Pathfinding.FollowerEntity.agentOffMeshLinkTraversalRO	followerentity.html#agentOffMeshLinkTraversalRO	
Pathfinding.FollowerEntity.archetype	followerentity.html#archetype	
Pathfinding.FollowerEntity.autoRepath	followerentity.html#autoRepath	Policy for when the agent recalculates its path. \n\n[more in online documentation]
Pathfinding.FollowerEntity.autoRepathBacking	followerentity.html#autoRepathBacking	
Pathfinding.FollowerEntity.autoRepathPolicyRW	followerentity.html#autoRepathPolicyRW	
Pathfinding.FollowerEntity.canMove	followerentity.html#canMove	Enables or disables movement completely. \n\nIf you want the agent to stand still, but still react to local avoidance and use gravity: use isStopped instead.\n\nDisabling this will remove the SimulateMovement component from the entity, which prevents most systems from running for this entity.\n\nWhen disabled, the velocity property will no longer update.\n\n[more in online documentation]
Pathfinding.FollowerEntity.canSearch	followerentity.html#canSearch	Enables or disables recalculating the path at regular intervals. \n\nSetting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.\n\nNote that this only disables automatic path recalculations. If you call the SearchPath() method a path will still be calculated.\n\n[more in online documentation]
Pathfinding.FollowerEntity.currentNode	followerentity.html#currentNode	Node which the agent is currently traversing. \n\nYou can, for example, use this to make the agent use a different animation when traversing nodes with a specific tag.\n\n[more in online documentation]\nWhen traversing an off-mesh link, this will return the final non-link node in the path before the agent started traversing the link.
Pathfinding.FollowerEntity.debugFlags	followerentity.html#debugFlags	Enables or disables debug drawing for this agent. \n\nThis is a bitmask with multiple flags so that you can choose exactly what you want to debug.\n\n[more in online documentation]
Pathfinding.FollowerEntity.desiredVelocity	followerentity.html#desiredVelocity	Velocity that this agent wants to move with. \n\nIncludes gravity and local avoidance if applicable. In world units per second.\n\n[more in online documentation]
Pathfinding.FollowerEntity.desiredVelocityWithoutLocalAvoidance	followerentity.html#desiredVelocityWithoutLocalAvoidance	Velocity that this agent wants to move with before taking local avoidance into account. \n\nIncludes gravity. In world units per second.\n\nSetting this property will set the current velocity that the agent is trying to move with, including gravity. This can be useful if you want to make the agent come to a complete stop in a single frame or if you want to modify the velocity in some way.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]\n\n\nIf you are not using local avoidance then this property will in almost all cases be identical to desiredVelocity plus some noise due to floating point math.\n\n[more in online documentation]
Pathfinding.FollowerEntity.destination	followerentity.html#destination	Position in the world that this agent should move to. \n\nIf no destination has been set yet, then (+infinity, +infinity, +infinity) will be returned.\n\nSetting this property will immediately try to repair the path if the agent already has a path. This will also immediately update properties like reachedDestination, reachedEndOfPath and remainingDistance.\n\nThe agent may do a full path recalculation if the local repair was not sufficient, but this will at earliest happen in the next simulation step.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.FollowerEntity.destinationFacingDirection	followerentity.html#destinationFacingDirection	Direction the agent will try to face when it reaches the destination. \n\nIf this is zero, the agent will not try to face any particular direction.\n\nThe following video shows three agents, one with no facing direction set, and then two agents with varying values of the lead in radius.  <b>[video in online documentation]</b>\n\n[more in online documentation]
Pathfinding.FollowerEntity.destinationPointAccessRO	followerentity.html#destinationPointAccessRO	
Pathfinding.FollowerEntity.destinationPointAccessRW	followerentity.html#destinationPointAccessRW	
Pathfinding.FollowerEntity.enableGravity	followerentity.html#enableGravity	Enables or disables gravity. \n\nIf gravity is enabled, the agent will accelerate downwards, and use a raycast to check if it should stop falling.\n\nThis has no effect if the agent's orientation is set to YAxisForward (2D mode). Gravity does not really make sense for top-down 2D games. The gravity setting is also hidden from the inspector in this mode.\n\n[more in online documentation]
Pathfinding.FollowerEntity.enableLocalAvoidance	followerentity.html#enableLocalAvoidance	True if local avoidance is enabled for this agent. \n\nEnabling this will automatically add a Pathfinding.ECS.RVO.RVOAgent component to the entity.\n\n[more in online documentation]
Pathfinding.FollowerEntity.endOfPath	followerentity.html#endOfPath	End point of path the agent is currently following. \n\nIf the agent has no path (or if it's not calculated yet), this will return the destination instead. If the agent has no destination it will return the agent's current position.\n\nThe end of the path is usually identical or very close to the destination, but it may differ if the path for example was blocked by a wall, so that the agent couldn't get any closer.\n\n[more in online documentation]
Pathfinding.FollowerEntity.entity	followerentity.html#entity	Entity which this movement script represents. \n\nAn entity will be created when this script is enabled, and destroyed when this script is disabled.\n\nCheck the class documentation to see which components it usually has, and what systems typically affect it.
Pathfinding.FollowerEntity.entityExists	followerentity.html#entityExists	True if this component's entity exists. \n\nThis is typically true if the component is active and enabled and the game is running.\n\n[more in online documentation]
Pathfinding.FollowerEntity.entityStorageCache	followerentity.html#entityStorageCache	
Pathfinding.FollowerEntity.groundMask	followerentity.html#groundMask	Determines which layers the agent will stand on. \n\nThe agent will use a raycast each frame to check if it should stop falling.\n\nThis layer mask should ideally not contain the agent's own layer, if the agent has a collider, as this may cause it to try to stand on top of itself.
Pathfinding.FollowerEntity.hasPath	followerentity.html#hasPath	True if this agent currently has a valid path that it follows. \n\nThis is true if the agent has a path and the path is not stale.\n\nA path may become stale if the graph is updated close to the agent and it hasn't had time to recalculate its path yet.
Pathfinding.FollowerEntity.height	followerentity.html#height	Height of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nThis value is used for various heuristics, and for visualization purposes. For example, the destination is only considered reached if the destination is not above the agent's head, and it's not more than half the agent's height below its feet.\n\nIf local lavoidance is enabled, this is also used to filter out collisions with agents and obstacles that are too far above or below the agent.
Pathfinding.FollowerEntity.indicesScratch	followerentity.html#indicesScratch	
Pathfinding.FollowerEntity.isStopped	followerentity.html#isStopped	Gets or sets if the agent should stop moving. \n\nIf this is set to true the agent will immediately start to slow down as quickly as it can to come to a full stop. The agent will still react to local avoidance and gravity (if applicable), but it will not try to move in any particular direction.\n\nThe current path of the agent will not be cleared, so when this is set to false again the agent will continue moving along the previous path.\n\nThis is a purely user-controlled parameter, so for example it is not set automatically when the agent stops moving because it has reached the target. Use reachedEndOfPath for that.\n\nIf this property is set to true while the agent is traversing an off-mesh link (RichAI script only), then the agent will continue traversing the link and stop once it has completed it.\n\n[more in online documentation]\nThe steeringTarget property will continue to indicate the point which the agent would move towards if it would not be stopped.
Pathfinding.FollowerEntity.isTraversingOffMeshLink	followerentity.html#isTraversingOffMeshLink	True if the agent is currently traversing an off-mesh link. \n\n[more in online documentation]
Pathfinding.FollowerEntity.localTransformAccessRO	followerentity.html#localTransformAccessRO	
Pathfinding.FollowerEntity.localTransformAccessRW	followerentity.html#localTransformAccessRW	
Pathfinding.FollowerEntity.managedState	followerentity.html#managedState	
Pathfinding.FollowerEntity.managedStateAccessRO	followerentity.html#managedStateAccessRO	
Pathfinding.FollowerEntity.managedStateAccessRW	followerentity.html#managedStateAccessRW	
Pathfinding.FollowerEntity.maxRotationSpeed	followerentity.html#maxRotationSpeed	Maximum rotation speed in degrees per second. \n\nIf the agent would have to rotate faster than this, it will instead slow down to get more time to rotate.\n\nThe agent may want to rotate faster than rotationSpeed if there's not enough space, so that it has to move in a more narrow arc. It may also want to rotate faster if it is very close to its destination and it wants to make sure it ends up on the right spot without any circling.\n\nIt is recommended to keep this at a value slightly larger than rotationSpeed.\n\n[more in online documentation]
Pathfinding.FollowerEntity.maxSpeed	followerentity.html#maxSpeed	Max speed in world units per second.
Pathfinding.FollowerEntity.movement	followerentity.html#movement	
Pathfinding.FollowerEntity.movementControlAccessRO	followerentity.html#movementControlAccessRO	
Pathfinding.FollowerEntity.movementControlAccessRW	followerentity.html#movementControlAccessRW	
Pathfinding.FollowerEntity.movementOutputAccessRW	followerentity.html#movementOutputAccessRW	
Pathfinding.FollowerEntity.movementOverrides	followerentity.html#movementOverrides	Provides callbacks during various parts of the movement calculations. \n\nWith this property you can register callbacks that will be called during various parts of the movement calculations. These can be used to modify movement of the agent.\n\nThe following example demonstrates how one can hook into one of the available phases and modify the agent's movement. In this case, the movement is modified to become wavy.\n\n <b>[video in online documentation]</b>\n\n<b>[code in online documentation]</b>\n\n- <b>BeforeControl:</b> Called before the agent's movement is calculated. At this point, the agent has a valid path, and the next corner that is moving towards has been calculated.\n\n- <b>AfterControl:</b> Called after the agent's desired movement is calculated. The agent has stored its desired movement in the MovementControl component. Local avoidance has not yet run.\n\n- <b>BeforeMovement:</b> Called right before the agent's movement is applied. At this point the agent's final movement (including local avoidance) is stored in the ResolvedMovement component, which you may modify.\n\n\n\n[more in online documentation]\nThe callbacks may be called multiple times per frame, if the fps is low, or if the time scale is high. It may also be called less than once per frame if the fps is very high. Each callback is provided with a <b>dt</b> parameter, which is the time in seconds since the last simulation step. You should prefer using this instead of Time.deltaTime.\n\n[more in online documentation]
Pathfinding.FollowerEntity.movementPlane	followerentity.html#movementPlane	The plane the agent is moving in. \n\nThis is typically the ground plane, which will be the XZ plane in a 3D game, and the XY plane in a 2D game. Ultimately it depends on the graph orientation.\n\nIf you are doing pathfinding on a spherical world (see Spherical Worlds), the the movement plane will be the tangent plane of the sphere at the agent's position.
Pathfinding.FollowerEntity.movementPlaneAccessRO	followerentity.html#movementPlaneAccessRO	
Pathfinding.FollowerEntity.movementPlaneAccessRW	followerentity.html#movementPlaneAccessRW	
Pathfinding.FollowerEntity.movementPlaneSource	followerentity.html#movementPlaneSource	How to calculate which direction is "up" for the agent. \n\nIn almost all cases, you should use the <b>Graph</b> option. This will make the agent use the graph's natural "up" direction. However, if you are using a spherical world, or a world with some other strange shape, then you may want to use the NavmeshNormal or Raycast options.\n\n[more in online documentation]
Pathfinding.FollowerEntity.movementPlaneSourceBacking	followerentity.html#movementPlaneSourceBacking	
Pathfinding.FollowerEntity.movementSettings	followerentity.html#movementSettings	Various movement settings. \n\nSome of these settings are exposed on the FollowerEntity directly. For example maxSpeed.\n\n[more in online documentation]
Pathfinding.FollowerEntity.movementSettingsAccessRO	followerentity.html#movementSettingsAccessRO	
Pathfinding.FollowerEntity.movementSettingsAccessRW	followerentity.html#movementSettingsAccessRW	
Pathfinding.FollowerEntity.movementStateAccessRO	followerentity.html#movementStateAccessRO	
Pathfinding.FollowerEntity.movementStateAccessRW	followerentity.html#movementStateAccessRW	
Pathfinding.FollowerEntity.movementStatisticsAccessRW	followerentity.html#movementStatisticsAccessRW	
Pathfinding.FollowerEntity.nextCornersScratch	followerentity.html#nextCornersScratch	
Pathfinding.FollowerEntity.offMeshLink	followerentity.html#offMeshLink	The off-mesh link that the agent is currently traversing. \n\nThis will be a default OffMeshLinks.OffMeshLinkTracer if the agent is not traversing an off-mesh link (the OffMeshLinks.OffMeshLinkTracer.link field will be null).\n\n[more in online documentation]
Pathfinding.FollowerEntity.onSearchPath	followerentity.html#onSearchPath	Called when the agent recalculates its path. \n\nThis is called both for automatic path recalculations (see canSearch) and manual ones (see SearchPath).\n\n[more in online documentation]
Pathfinding.FollowerEntity.onTraverseOffMeshLink	followerentity.html#onTraverseOffMeshLink	Callback to be called when an agent starts traversing an off-mesh link. \n\nThe handler will be called when the agent starts traversing an off-mesh link. It allows you to to control the agent for the full duration of the link traversal.\n\nUse the passed context struct to get information about the link and to control the agent.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]\nYou can alternatively set the corresponding property property on the off-mesh link ( NodeLink2.onTraverseOffMeshLink) to specify a callback for a specific off-mesh link.\n\n[more in online documentation]
Pathfinding.FollowerEntity.orientation	followerentity.html#orientation	Determines which direction the agent moves in. \n\nFor 3D games you most likely want the ZAxisIsForward option as that is the convention for 3D games.\n\nFor 2D games you most likely want the YAxisIsForward option as that is the convention for 2D games.\n\nWhen using ZAxisForard, the +Z axis will be the forward direction of the agent, +Y will be upwards, and +X will be the right direction.\n\nWhen using YAxisForward, the +Y axis will be the forward direction of the agent, +Z will be upwards, and +X will be the right direction.\n\n <b>[image in online documentation]</b>
Pathfinding.FollowerEntity.orientationBacking	followerentity.html#orientationBacking	Determines which direction the agent moves in. \n\n[more in online documentation]
Pathfinding.FollowerEntity.pathPending	followerentity.html#pathPending	True if a path is currently being calculated.
Pathfinding.FollowerEntity.pathfindingSettings	followerentity.html#pathfindingSettings	Pathfinding settings. \n\nThe settings in this struct controls how the agent calculates paths to its destination.\n\nThis is analogous to the Seeker component used for other movement scripts.\n\n[more in online documentation]
Pathfinding.FollowerEntity.position	followerentity.html#position	Position of the agent. \n\nIn world space. \n\n[more in online documentation]\nIf you want to move the agent you may use Teleport or Move.
Pathfinding.FollowerEntity.positionSmoothing	followerentity.html#positionSmoothing	How much to smooth the visual position of the agent. \n\nThis does not affect movement, but smoothes out the position of the agent visually.\n\nRecommended values are between 0.0 and 0.5. A value of zero will disable smoothing completely.\n\nThis will make the agent seem to lag slightly behind the internal position of the agent. It may also cut corners slightly.\n\nThe unit for this field is seconds.
Pathfinding.FollowerEntity.radius	followerentity.html#radius	Radius of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nNote that this does not affect pathfinding in any way. The graph used completely determines where the agent can move.\n\n[more in online documentation]
Pathfinding.FollowerEntity.reachedCrowdedEndOfPath	followerentity.html#reachedCrowdedEndOfPath	Like reachedEndOfPath, but will also return true if the end of the path is crowded, and this agent has stopped because it cannot get closer. \n\nThis is only relevant if the agent is using local avoidance. Otherwise, this will be identical to reachedEndOfPath.\n\nIf the agent has a stale path (e.g. because the destination changed significantly, or a graph update happened near the agent), false will be returned until the path has been recalculated (typically in the next one or two frames).\n\nYou can see a visualization of this state by enabling "Reached State" in the Local Avoidance Debug Rendering field.\n\n[more in online documentation]\nIn the video below, the agents will get a red ring around them when this property is true.\n\n <b>[video in online documentation]</b>\n\n[more in online documentation]
Pathfinding.FollowerEntity.reachedDestination	followerentity.html#reachedDestination	True if the ai has reached the destination. \n\nThe agent considers the destination reached when it is within stopDistance world units from the destination. Additionally, the destination must not be above the agent's head, and it must not be more than half the agent's height below its feet.\n\nIf a facing direction was specified when setting the destination, this will only return true once the agent is approximately facing the correct orientation.\n\nThis value will be updated immediately when the destination is changed.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.FollowerEntity.reachedEndOfPath	followerentity.html#reachedEndOfPath	True if the agent has reached the end of the current path. \n\nThe agent considers the end of the path reached when it is within stopDistance world units from the end of the path. Additionally, the end of the path must not be above the agent's head, and it must not be more than half the agent's height below its feet.\n\nIf a facing direction was specified when setting the destination, this will only return true once the agent is approximately facing the correct orientation.\n\nThis value will be updated immediately when the destination is changed.\n\n[more in online documentation]
Pathfinding.FollowerEntity.readyToTraverseOffMeshLinkRW	followerentity.html#readyToTraverseOffMeshLinkRW	
Pathfinding.FollowerEntity.remainingDistance	followerentity.html#remainingDistance	Approximate remaining distance along the current path to the end of the path. \n\nThe agent does not know the true distance at all times, so this is an approximation. It tends to be a bit lower than the true distance.\n\n[more in online documentation]\nThis value will update immediately if the destination property is changed, or if the agent is moved using the position property or the Teleport method.\n\nIf the agent has no path, or if the current path is stale (e.g. if the graph has been updated close to the agent, and it hasn't had time to recalculate its path), this will return positive infinity.\n\n[more in online documentation]
Pathfinding.FollowerEntity.resolvedMovementAccessRO	followerentity.html#resolvedMovementAccessRO	
Pathfinding.FollowerEntity.resolvedMovementAccessRW	followerentity.html#resolvedMovementAccessRW	
Pathfinding.FollowerEntity.rotation	followerentity.html#rotation	Rotation of the agent. \n\nIn world space.\n\nThe entity internally always treats the Z axis as forward, but this property respects the orientation field. So it will return either a rotation with the Y axis as forward, or Z axis as forward, depending on the orientation field.\n\n[more in online documentation]\nThis will return the agent's rotation even if updateRotation is false.\n\n[more in online documentation]
Pathfinding.FollowerEntity.rotationSmoothing	followerentity.html#rotationSmoothing	How much to smooth the visual rotation of the agent. \n\nThis does not affect movement, but smoothes out how the agent rotates visually.\n\nRecommended values are between 0.0 and 0.5. A value of zero will disable smoothing completely.\n\nThe smoothing is done primarily using an exponential moving average, but with a small linear term to make the rotation converge faster when the agent is almost facing the desired direction.\n\nAdding smoothing will make the visual rotation of the agent lag a bit behind the actual rotation. Too much smoothing may make the agent seem sluggish, and appear to move sideways.\n\nThe unit for this field is seconds.
Pathfinding.FollowerEntity.rotationSpeed	followerentity.html#rotationSpeed	Desired rotation speed in degrees per second. \n\nIf the agent is in an open area and gets a new destination directly behind itself, it will start to rotate around with exactly this rotation speed.\n\nThe agent will slow down its rotation speed as it approaches its desired facing direction. So for example, when it is only 90 degrees away from its desired facing direction, it will only rotate with about half this speed.\n\n[more in online documentation]
Pathfinding.FollowerEntity.rvoSettings	followerentity.html#rvoSettings	Local avoidance settings.
Pathfinding.FollowerEntity.scratchReferenceCount	followerentity.html#scratchReferenceCount	
Pathfinding.FollowerEntity.shape	followerentity.html#shape	
Pathfinding.FollowerEntity.steeringTarget	followerentity.html#steeringTarget	Point on the path which the agent is currently moving towards. \n\nThis is usually a point a small distance ahead of the agent or the end of the path.\n\nIf the agent does not have a path at the moment, then the agent's current position will be returned.
Pathfinding.FollowerEntity.stopDistance	followerentity.html#stopDistance	How far away from the destination should the agent aim to stop, in world units. \n\nIf the agent is within this distance from the destination point it will be considered to have reached the destination.\n\nEven if you want the agent to stop precisely at a given point, it is recommended to keep this slightly above zero. If it is exactly zero, the agent may have a hard time deciding that it has actually reached the end of the path, due to floating point errors and such.\n\n[more in online documentation]
Pathfinding.FollowerEntity.syncPosition	followerentity.html#syncPosition	Determines if the character's position should be coupled to the Transform's position. \n\nIf false then all movement calculations will happen as usual, but the GameObject that this component is attached to will not move. Instead, only the position property and the internal entity's position will change.\n\nThis is useful if you want to control the movement of the character using some other means, such as root motion, but still want the AI to move freely.\n\n[more in online documentation]
Pathfinding.FollowerEntity.syncRotation	followerentity.html#syncRotation	Determines if the character's rotation should be coupled to the Transform's rotation. \n\nIf false then all movement calculations will happen as usual, but the GameObject that this component is attached to will not rotate. Instead, only the rotation property and the internal entity's rotation will change.\n\nThis is particularly useful for 2D games where you want the Transform to stay in the same orientation, and instead swap out the displayed sprite to indicate the direction the character is facing.\n\nYou can enable PIDMovement.DebugFlags.Rotation in debugFlags to draw a gizmos arrow in the scene view to indicate the agent's internal rotation.\n\n[more in online documentation]
Pathfinding.FollowerEntity.tr	followerentity.html#tr	Cached transform component.
Pathfinding.FollowerEntity.updatePosition	followerentity.html#updatePosition	Determines if the character's position should be coupled to the Transform's position. \n\nIf false then all movement calculations will happen as usual, but the GameObject that this component is attached to will not move. Instead, only the position property and the internal entity's position will change.\n\nThis is useful if you want to control the movement of the character using some other means, such as root motion, but still want the AI to move freely.\n\n[more in online documentation]
Pathfinding.FollowerEntity.updateRotation	followerentity.html#updateRotation	Determines if the character's rotation should be coupled to the Transform's rotation. \n\nIf false then all movement calculations will happen as usual, but the GameObject that this component is attached to will not rotate. Instead, only the rotation property and the internal entity's rotation will change.\n\nThis is particularly useful for 2D games where you want the Transform to stay in the same orientation, and instead swap out the displayed sprite to indicate the direction the character is facing.\n\nYou can enable PIDMovement.DebugFlags.Rotation in debugFlags to draw a gizmos arrow in the scene view to indicate the agent's internal rotation.\n\n[more in online documentation]
Pathfinding.FollowerEntity.velocity	followerentity.html#velocity	Actual velocity that the agent is moving with. \n\nIn world units per second.\n\nThis is useful for, for example, selecting which animations to play, and at what speeds.\n\n[more in online documentation]
Pathfinding.FollowerEntityEditor.debug	followerentityeditor.html#debug	
Pathfinding.FollowerEntityEditor.legend	followerentityeditor.html#legend	
Pathfinding.FollowerEntityEditor.tagPenaltiesOpen	followerentityeditor.html#tagPenaltiesOpen	
Pathfinding.Funnel.FunnelPortalIndexMask	funnel.html#FunnelPortalIndexMask	
Pathfinding.Funnel.FunnelPortals.left	funnelportals.html#left	
Pathfinding.Funnel.FunnelPortals.right	funnelportals.html#right	
Pathfinding.Funnel.FunnelState.leftFunnel	funnelstate.html#leftFunnel	Left side of the funnel.
Pathfinding.Funnel.FunnelState.projectionAxis	funnelstate.html#projectionAxis	If set to anything other than (0,0,0), then all portals will be projected on a plane with this normal. \n\nThis is used to make the funnel fit a rotated graph better. It is ideally used for grid graphs, but navmesh/recast graphs are probably better off with it set to zero.\n\nThe vector should be normalized (unless zero), in world space, and should never be changed after the first portal has been added (unless the funnel is cleared first).
Pathfinding.Funnel.FunnelState.rightFunnel	funnelstate.html#rightFunnel	Right side of the funnel.
Pathfinding.Funnel.FunnelState.unwrappedPortals	funnelstate.html#unwrappedPortals	Unwrapped version of the funnel portals in 2D space. \n\nThe input is a funnel like in the image below. It may be rotated and twisted.  <b>[image in online documentation]</b><b>[image in online documentation]</b>\n\nThis array is used as a cache and the unwrapped portals are calculated on demand. Thus it may not contain all portals.
Pathfinding.Funnel.PartType	funnel.html#PartType	The type of a PathPart.
Pathfinding.Funnel.PathPart.endIndex	pathpart.html#endIndex	Index of the last node in this part.
Pathfinding.Funnel.PathPart.endPoint	pathpart.html#endPoint	Exact end-point of this part or off-mesh link.
Pathfinding.Funnel.PathPart.startIndex	pathpart.html#startIndex	Index of the first node in this part.
Pathfinding.Funnel.PathPart.startPoint	pathpart.html#startPoint	Exact start-point of this part or off-mesh link.
Pathfinding.Funnel.PathPart.type	pathpart.html#type	If this is an off-mesh link or a sequence of nodes in a single graph.
Pathfinding.Funnel.RightSideBit	funnel.html#RightSideBit	
Pathfinding.FunnelModifier.FunnelQuality	funnelmodifier.html#FunnelQuality	
Pathfinding.FunnelModifier.Order	funnelmodifier.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.FunnelModifier.accountForGridPenalties	funnelmodifier.html#accountForGridPenalties	When using a grid graph, take penalties, tag penalties and ITraversalProvider penalties into account. \n\nEnabling this is quite slow. It can easily make the modifier take twice the amount of time to run. So unless you are using penalties/tags/ITraversalProvider penalties that you need to take into account when simplifying the path, you should leave this disabled.
Pathfinding.FunnelModifier.quality	funnelmodifier.html#quality	Determines if funnel simplification is used. \n\nWhen using the low quality setting only the funnel algorithm is used but when the high quality setting an additional step is done to simplify the path even more.\n\nOn tiled recast/navmesh graphs, but sometimes on normal ones as well, it can be good to simplify the funnel as a post-processing step to make the paths straighter.\n\nThis has a moderate performance impact during frames when a path calculation is completed. This is why it is disabled by default. For any units that you want high quality movement for you should enable it.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.FunnelModifier.splitAtEveryPortal	funnelmodifier.html#splitAtEveryPortal	Insert a vertex every time the path crosses a portal instead of only at the corners of the path. \n\nThe resulting path will have exactly one vertex per portal if this is enabled. This may introduce vertices with the same position in the output (esp. in corners where many portals meet).  <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GUIUtilityx.colors	guiutilityx.html#colors	
Pathfinding.GlobalNodeStorage.DebugPathNode.fractionAlongEdge	debugpathnode.html#fractionAlongEdge	
Pathfinding.GlobalNodeStorage.DebugPathNode.g	debugpathnode.html#g	
Pathfinding.GlobalNodeStorage.DebugPathNode.h	debugpathnode.html#h	
Pathfinding.GlobalNodeStorage.DebugPathNode.parentIndex	debugpathnode.html#parentIndex	
Pathfinding.GlobalNodeStorage.DebugPathNode.pathID	debugpathnode.html#pathID	
Pathfinding.GlobalNodeStorage.IndexedStack.Count	indexedstack.html#Count	
Pathfinding.GlobalNodeStorage.IndexedStack.buffer	indexedstack.html#buffer	
Pathfinding.GlobalNodeStorage.InitialTemporaryNodes	globalnodestorage.html#InitialTemporaryNodes	
Pathfinding.GlobalNodeStorage.JobAllocateNodes.allowBoundsChecks	joballocatenodes2.html#allowBoundsChecks	
Pathfinding.GlobalNodeStorage.JobAllocateNodes.count	joballocatenodes2.html#count	
Pathfinding.GlobalNodeStorage.JobAllocateNodes.createNode	joballocatenodes2.html#createNode	
Pathfinding.GlobalNodeStorage.JobAllocateNodes.nodeStorage	joballocatenodes2.html#nodeStorage	
Pathfinding.GlobalNodeStorage.JobAllocateNodes.result	joballocatenodes2.html#result	
Pathfinding.GlobalNodeStorage.JobAllocateNodes.variantsPerNode	joballocatenodes2.html#variantsPerNode	
Pathfinding.GlobalNodeStorage.PathfindingThreadData.debugPathNodes	pathfindingthreaddata.html#debugPathNodes	
Pathfinding.GlobalNodeStorage.PathfindingThreadData.pathNodes	pathfindingthreaddata.html#pathNodes	
Pathfinding.GlobalNodeStorage.astar	globalnodestorage.html#astar	
Pathfinding.GlobalNodeStorage.destroyedNodesVersion	globalnodestorage.html#destroyedNodesVersion	Number of nodes that have been destroyed in total.
Pathfinding.GlobalNodeStorage.lastAllocationJob	globalnodestorage.html#lastAllocationJob	
Pathfinding.GlobalNodeStorage.nextNodeIndex	globalnodestorage.html#nextNodeIndex	Holds the next node index which has not been used by any previous node. \n\n[more in online documentation]
Pathfinding.GlobalNodeStorage.nodeIndexPools	globalnodestorage.html#nodeIndexPools	Holds indices for nodes that have been destroyed. \n\nTo avoid trashing a lot of memory structures when nodes are frequently deleted and created, node indices are reused.\n\nThere's one pool for each possible number of node variants (1, 2 and 3).
Pathfinding.GlobalNodeStorage.nodes	globalnodestorage.html#nodes	Maps from NodeIndex to node.
Pathfinding.GlobalNodeStorage.pathfindingThreadData	globalnodestorage.html#pathfindingThreadData	
Pathfinding.GlobalNodeStorage.reservedPathNodeData	globalnodestorage.html#reservedPathNodeData	The number of nodes for which path node data has been reserved. \n\nWill be at least as high as nextNodeIndex
Pathfinding.GlobalNodeStorage.temporaryNodeCount	globalnodestorage.html#temporaryNodeCount	
Pathfinding.GraphDebugMode	pathfinding.html#GraphDebugMode	How to visualize the graphs in the editor.
Pathfinding.GraphEditor.editor	grapheditor.html#editor	
Pathfinding.GraphEditor.fadeArea	grapheditor.html#fadeArea	Stores if the graph is visible or not in the inspector.
Pathfinding.GraphEditor.infoFadeArea	grapheditor.html#infoFadeArea	Stores if the graph info box is visible or not in the inspector.
Pathfinding.GraphEditorBase.target	grapheditorbase.html#target	NavGraph this editor is exposing.
Pathfinding.GraphHitInfo.distance	graphhitinfo.html#distance	Distance from origin to point.
Pathfinding.GraphHitInfo.node	graphhitinfo.html#node	Node which contained the edge which was hit. \n\nIf the linecast did not hit anything then this will be set to the last node along the line's path (the one which contains the endpoint).\n\nFor layered grid graphs the linecast will return true (i.e: no free line of sight) if, when walking the graph, we ended up at the right X,Z coordinate for the end node, but the end node was on a different level (e.g the floor below or above in a building). In this case no node edge was really hit so this field will still be null.\n\nIf the origin was inside an unwalkable node, then this field will be set to that node.\n\nIf no node could be found which contained the origin, then this field will be set to null.
Pathfinding.GraphHitInfo.origin	graphhitinfo.html#origin	Start of the segment/ray. \n\nNote that the point passed to the Linecast method will be clamped to the surface on the navmesh, but it will be identical when seen from above.
Pathfinding.GraphHitInfo.point	graphhitinfo.html#point	Hit point. \n\nThis is typically a point on the border of the navmesh.\n\nIn case no obstacle was hit then this will be set to the endpoint of the segment.\n\nIf the origin was inside an unwalkable node, then this will be set to the origin point.
Pathfinding.GraphHitInfo.tangent	graphhitinfo.html#tangent	Tangent of the edge which was hit. \n\n <b>[image in online documentation]</b>\n\nIf nothing was hit, this will be Vector3.zero.
Pathfinding.GraphHitInfo.tangentOrigin	graphhitinfo.html#tangentOrigin	Where the tangent starts. \n\ntangentOrigin and tangent together actually describes the edge which was hit.  <b>[image in online documentation]</b>\n\nIf nothing was hit, this will be Vector3.zero.
Pathfinding.GraphMask.everything	graphmask.html#everything	A mask containing every graph.
Pathfinding.GraphMask.value	graphmask.html#value	Bitmask representing the mask.
Pathfinding.GraphMaskDrawer.graphLabels	graphmaskdrawer.html#graphLabels	
Pathfinding.GraphModifier.EventType	graphmodifier.html#EventType	GraphModifier event type.
Pathfinding.GraphModifier.next	graphmodifier.html#next	
Pathfinding.GraphModifier.prev	graphmodifier.html#prev	
Pathfinding.GraphModifier.root	graphmodifier.html#root	All active graph modifiers.
Pathfinding.GraphModifier.uniqueID	graphmodifier.html#uniqueID	Unique persistent ID for this component, used for serialization.
Pathfinding.GraphModifier.usedIDs	graphmodifier.html#usedIDs	Maps persistent IDs to the component that uses it.
Pathfinding.GraphNode.Area	graphnode.html#Area	Connected component that contains the node. \n\nThis is visualized in the scene view as differently colored nodes (if the graph coloring mode is set to 'Areas'). Each area represents a set of nodes such that there is no valid path between nodes of different colors.\n\n[more in online documentation]
Pathfinding.GraphNode.Destroyed	graphnode.html#Destroyed	
Pathfinding.GraphNode.DestroyedNodeIndex	graphnode.html#DestroyedNodeIndex	
Pathfinding.GraphNode.Flags	graphnode.html#Flags	Holds various bitpacked variables. \n\nBit 0: Walkable Bits 1 through 17: HierarchicalNodeIndex Bit 18: IsHierarchicalNodeDirty Bits 19 through 23: Tag Bits 24 through 31: GraphIndex\n\n[more in online documentation]
Pathfinding.GraphNode.FlagsGraphMask	graphnode.html#FlagsGraphMask	Mask of graph index bits. \n\n[more in online documentation]
Pathfinding.GraphNode.FlagsGraphOffset	graphnode.html#FlagsGraphOffset	Start of graph index bits. \n\n[more in online documentation]
Pathfinding.GraphNode.FlagsHierarchicalIndexOffset	graphnode.html#FlagsHierarchicalIndexOffset	Start of hierarchical node index bits. \n\n[more in online documentation]
Pathfinding.GraphNode.FlagsTagMask	graphnode.html#FlagsTagMask	Mask of tag bits. \n\n[more in online documentation]
Pathfinding.GraphNode.FlagsTagOffset	graphnode.html#FlagsTagOffset	Start of tag bits. \n\n[more in online documentation]
Pathfinding.GraphNode.FlagsWalkableMask	graphnode.html#FlagsWalkableMask	Mask of the walkable bit. \n\n[more in online documentation]
Pathfinding.GraphNode.FlagsWalkableOffset	graphnode.html#FlagsWalkableOffset	Position of the walkable bit. \n\n[more in online documentation]
Pathfinding.GraphNode.Graph	graphnode.html#Graph	Graph which this node belongs to. \n\nIf you know the node belongs to a particular graph type, you can cast it to that type: <b>[code in online documentation]</b>\n\nWill return null if the node has been destroyed.
Pathfinding.GraphNode.GraphIndex	graphnode.html#GraphIndex	Graph which contains this node. \n\n[more in online documentation]
Pathfinding.GraphNode.HierarchicalDirtyMask	graphnode.html#HierarchicalDirtyMask	Mask of the IsHierarchicalNodeDirty bit. \n\n[more in online documentation]
Pathfinding.GraphNode.HierarchicalDirtyOffset	graphnode.html#HierarchicalDirtyOffset	Start of IsHierarchicalNodeDirty bits. \n\n[more in online documentation]
Pathfinding.GraphNode.HierarchicalIndexMask	graphnode.html#HierarchicalIndexMask	Mask of hierarchical node index bits. \n\n[more in online documentation]
Pathfinding.GraphNode.HierarchicalNodeIndex	graphnode.html#HierarchicalNodeIndex	Hierarchical Node that contains this node. \n\nThe graph is divided into clusters of small hierarchical nodes in which there is a path from every node to every other node. This structure is used to speed up connected component calculations which is used to quickly determine if a node is reachable from another node.\n\n[more in online documentation]
Pathfinding.GraphNode.InvalidGraphIndex	graphnode.html#InvalidGraphIndex	
Pathfinding.GraphNode.InvalidNodeIndex	graphnode.html#InvalidNodeIndex	
Pathfinding.GraphNode.IsHierarchicalNodeDirty	graphnode.html#IsHierarchicalNodeDirty	Some internal bookkeeping.
Pathfinding.GraphNode.MaxGraphIndex	graphnode.html#MaxGraphIndex	Max number of graphs-1.
Pathfinding.GraphNode.MaxHierarchicalNodeIndex	graphnode.html#MaxHierarchicalNodeIndex	
Pathfinding.GraphNode.MaxTagIndex	graphnode.html#MaxTagIndex	Max number of tags - 1. \n\nAlways a power of 2 minus one
Pathfinding.GraphNode.NodeIndex	graphnode.html#NodeIndex	Internal unique index. \n\nEvery node will get a unique index. This index is not necessarily correlated with e.g the position of the node in the graph.
Pathfinding.GraphNode.NodeIndexMask	graphnode.html#NodeIndexMask	
Pathfinding.GraphNode.PathNodeVariants	graphnode.html#PathNodeVariants	How many path node variants should be created for each node. \n\nThis should be a constant for each node type.\n\nTypically this is 1, but for example the triangle mesh node type has 3 variants, one for each edge.\n\n[more in online documentation]
Pathfinding.GraphNode.Penalty	graphnode.html#Penalty	Penalty cost for walking on this node. \n\nThis can be used to make it harder/slower to walk over specific nodes. A cost of 1000 (Int3.Precision) corresponds to the cost of moving 1 world unit.\n\n[more in online documentation]
Pathfinding.GraphNode.Tag	graphnode.html#Tag	Node tag. \n\n[more in online documentation]
Pathfinding.GraphNode.TemporaryFlag1	graphnode.html#TemporaryFlag1	Temporary flag for internal purposes. \n\nMay only be used in the Unity thread. Must be reset to false after every use.
Pathfinding.GraphNode.TemporaryFlag1Mask	graphnode.html#TemporaryFlag1Mask	
Pathfinding.GraphNode.TemporaryFlag2	graphnode.html#TemporaryFlag2	Temporary flag for internal purposes. \n\nMay only be used in the Unity thread. Must be reset to false after every use.
Pathfinding.GraphNode.TemporaryFlag2Mask	graphnode.html#TemporaryFlag2Mask	
Pathfinding.GraphNode.Walkable	graphnode.html#Walkable	True if the node is traversable. \n\n[more in online documentation]
Pathfinding.GraphNode.flags	graphnode.html#flags	Bitpacked field holding several pieces of data. \n\n[more in online documentation]
Pathfinding.GraphNode.nodeIndex	graphnode.html#nodeIndex	Internal unique index. \n\nAlso stores some bitpacked values such as TemporaryFlag1 and TemporaryFlag2.
Pathfinding.GraphNode.penalty	graphnode.html#penalty	Penalty cost for walking on this node. \n\nThis can be used to make it harder/slower to walk over certain nodes.\n\nA penalty of 1000 (Int3.Precision) corresponds to the cost of walking one world unit.\n\n[more in online documentation]
Pathfinding.GraphNode.position	graphnode.html#position	Position of the node in world space. \n\n[more in online documentation]
Pathfinding.GraphUpdateObject.GraphUpdateData.nodeIndices	graphupdatedata.html#nodeIndices	Node indices to update. \n\nRemaining nodes should be left alone. Additionally, if math.any(nodeNormals[i]) is false, then the node should not be updated, since it is not a valid node.
Pathfinding.GraphUpdateObject.GraphUpdateData.nodeNormals	graphupdatedata.html#nodeNormals	
Pathfinding.GraphUpdateObject.GraphUpdateData.nodePenalties	graphupdatedata.html#nodePenalties	
Pathfinding.GraphUpdateObject.GraphUpdateData.nodePositions	graphupdatedata.html#nodePositions	
Pathfinding.GraphUpdateObject.GraphUpdateData.nodeTags	graphupdatedata.html#nodeTags	
Pathfinding.GraphUpdateObject.GraphUpdateData.nodeWalkable	graphupdatedata.html#nodeWalkable	
Pathfinding.GraphUpdateObject.JobGraphUpdate.bounds	jobgraphupdate.html#bounds	
Pathfinding.GraphUpdateObject.JobGraphUpdate.data	jobgraphupdate.html#data	
Pathfinding.GraphUpdateObject.JobGraphUpdate.modifyTag	jobgraphupdate.html#modifyTag	
Pathfinding.GraphUpdateObject.JobGraphUpdate.modifyWalkability	jobgraphupdate.html#modifyWalkability	
Pathfinding.GraphUpdateObject.JobGraphUpdate.penaltyDelta	jobgraphupdate.html#penaltyDelta	
Pathfinding.GraphUpdateObject.JobGraphUpdate.shape	jobgraphupdate.html#shape	
Pathfinding.GraphUpdateObject.JobGraphUpdate.tagValue	jobgraphupdate.html#tagValue	
Pathfinding.GraphUpdateObject.JobGraphUpdate.walkabilityValue	jobgraphupdate.html#walkabilityValue	
Pathfinding.GraphUpdateObject.STAGE_ABORTED	graphupdateobject.html#STAGE_ABORTED	
Pathfinding.GraphUpdateObject.STAGE_APPLIED	graphupdateobject.html#STAGE_APPLIED	
Pathfinding.GraphUpdateObject.STAGE_CREATED	graphupdateobject.html#STAGE_CREATED	
Pathfinding.GraphUpdateObject.STAGE_PENDING	graphupdateobject.html#STAGE_PENDING	
Pathfinding.GraphUpdateObject.addPenalty	graphupdateobject.html#addPenalty	Penalty to add to the nodes. \n\nA penalty of 1000 is equivalent to the cost of moving 1 world unit.
Pathfinding.GraphUpdateObject.bounds	graphupdateobject.html#bounds	The bounds to update nodes within. \n\nDefined in world space.
Pathfinding.GraphUpdateObject.internalStage	graphupdateobject.html#internalStage	Info about if a graph update has been applied or not. \n\nEither an enum (see STAGE_CREATED and associated constants) or a non-negative count of the number of graphs that are waiting to apply this graph update.
Pathfinding.GraphUpdateObject.modifyTag	graphupdateobject.html#modifyTag	If true, all nodes' <b>tag</b> will be set to setTag.
Pathfinding.GraphUpdateObject.modifyWalkability	graphupdateobject.html#modifyWalkability	If true, all nodes' <b>walkable</b> variable will be set to setWalkability. \n\nIt is not recommended to combine this with updatePhysics since then you will just overwrite what updatePhysics calculated.
Pathfinding.GraphUpdateObject.nnConstraint	graphupdateobject.html#nnConstraint	NNConstraint to use. \n\nThe Pathfinding.NNConstraint.SuitableGraph function will be called on the NNConstraint to enable filtering of which graphs to update.\n\n[more in online documentation]\n  [more in online documentation]
Pathfinding.GraphUpdateObject.resetPenaltyOnPhysics	graphupdateobject.html#resetPenaltyOnPhysics	Reset penalties to their initial values when updating grid graphs and updatePhysics is true. \n\nIf you want to keep old penalties even when you update the graph you may want to disable this option.\n\nThe images below shows two overlapping graph update objects, the right one happened to be applied before the left one. They both have updatePhysics = true and are set to increase the penalty of the nodes by some amount.\n\nThe first image shows the result when resetPenaltyOnPhysics is false. Both penalties are added correctly.  <b>[image in online documentation]</b>\n\nThis second image shows when resetPenaltyOnPhysics is set to true. The first GUO is applied correctly, but then the second one (the left one) is applied and during its updating, it resets the penalties first and then adds penalty to the nodes. The result is that the penalties from both GUOs are not added together. The green patch in at the border is there because physics recalculation (recalculation of the position of the node, checking for obstacles etc.) affects a slightly larger area than the original GUO bounds because of the Grid Graph -&gt; Collision Testing -&gt; Diameter setting (it is enlarged by that value). So some extra nodes have their penalties reset.\n\n <b>[image in online documentation]</b>
Pathfinding.GraphUpdateObject.setTag	graphupdateobject.html#setTag	If modifyTag is true, all nodes' <b>tag</b> will be set to this value.
Pathfinding.GraphUpdateObject.setWalkability	graphupdateobject.html#setWalkability	If modifyWalkability is true, the nodes' <b>walkable</b> variable will be set to this value.
Pathfinding.GraphUpdateObject.shape	graphupdateobject.html#shape	A shape can be specified if a bounds object does not give enough precision. \n\nNote that if you set this, you should set the bounds so that it encloses the shape because the bounds will be used as an initial fast check for which nodes that should be updated.
Pathfinding.GraphUpdateObject.stage	graphupdateobject.html#stage	Info about if a graph update has been applied or not.
Pathfinding.GraphUpdateObject.trackChangedNodes	graphupdateobject.html#trackChangedNodes	Track which nodes are changed and save backup data. \n\nUsed internally to revert changes if needed.\n\n[more in online documentation]
Pathfinding.GraphUpdateObject.updateErosion	graphupdateobject.html#updateErosion	Update Erosion for GridGraphs. \n\nWhen enabled, erosion will be recalculated for grid graphs after the GUO has been applied.\n\nIn the below image you can see the different effects you can get with the different values.\n\nThe first image shows the graph when no GUO has been applied. The blue box is not identified as an obstacle by the graph, the reason there are unwalkable nodes around it is because there is a height difference (nodes are placed on top of the box) so erosion will be applied (an erosion value of 2 is used in this graph). The orange box is identified as an obstacle, so the area of unwalkable nodes around it is a bit larger since both erosion and collision has made nodes unwalkable.\n\nThe GUO used simply sets walkability to true, i.e making all nodes walkable.\n\n <b>[image in online documentation]</b>\n\nWhen updateErosion=True, the reason the blue box still has unwalkable nodes around it is because there is still a height difference so erosion will still be applied. The orange box on the other hand has no height difference and all nodes are set to walkable.\n\nWhen updateErosion=False, all nodes walkability are simply set to be walkable in this example.\n\n[more in online documentation]
Pathfinding.GraphUpdateObject.updatePhysics	graphupdateobject.html#updatePhysics	Use physics checks to update nodes. \n\nWhen updating a grid graph and this is true, the nodes' position and walkability will be updated using physics checks with settings from "Collision Testing" and "Height Testing".\n\nWhen updating a PointGraph, setting this to true will make it re-evaluate all connections in the graph which passes through the bounds.\n\nThis has no effect when updating GridGraphs if modifyWalkability is turned on. You should not combine updatePhysics and modifyWalkability.\n\nOn RecastGraphs, having this enabled will trigger a complete recalculation of all tiles intersecting the bounds. This is quite slow (but powerful). If you only want to update e.g penalty on existing nodes, leave it disabled.
Pathfinding.GraphUpdateProcessor.IsAnyGraphUpdateInProgress	graphupdateprocessor.html#IsAnyGraphUpdateInProgress	Returns if any graph updates are in progress.
Pathfinding.GraphUpdateProcessor.IsAnyGraphUpdateQueued	graphupdateprocessor.html#IsAnyGraphUpdateQueued	Returns if any graph updates are waiting to be applied.
Pathfinding.GraphUpdateProcessor.MarkerApply	graphupdateprocessor.html#MarkerApply	
Pathfinding.GraphUpdateProcessor.MarkerCalculate	graphupdateprocessor.html#MarkerCalculate	
Pathfinding.GraphUpdateProcessor.MarkerSleep	graphupdateprocessor.html#MarkerSleep	
Pathfinding.GraphUpdateProcessor.anyGraphUpdateInProgress	graphupdateprocessor.html#anyGraphUpdateInProgress	Used for IsAnyGraphUpdateInProgress.
Pathfinding.GraphUpdateProcessor.astar	graphupdateprocessor.html#astar	Holds graphs that can be updated.
Pathfinding.GraphUpdateProcessor.graphUpdateQueue	graphupdateprocessor.html#graphUpdateQueue	Queue containing all waiting graph update queries. \n\nAdd to this queue by using AddToQueue. \n\n[more in online documentation]
Pathfinding.GraphUpdateProcessor.pendingGraphUpdates	graphupdateprocessor.html#pendingGraphUpdates	
Pathfinding.GraphUpdateProcessor.pendingPromises	graphupdateprocessor.html#pendingPromises	
Pathfinding.GraphUpdateScene.GizmoColorSelected	graphupdatescene.html#GizmoColorSelected	
Pathfinding.GraphUpdateScene.GizmoColorUnselected	graphupdatescene.html#GizmoColorUnselected	
Pathfinding.GraphUpdateScene.applyOnScan	graphupdatescene.html#applyOnScan	Apply this graph update object whenever a graph is rescanned.
Pathfinding.GraphUpdateScene.applyOnStart	graphupdatescene.html#applyOnStart	Apply this graph update object on start.
Pathfinding.GraphUpdateScene.convex	graphupdatescene.html#convex	Use the convex hull of the points instead of the original polygon. \n\n[more in online documentation]
Pathfinding.GraphUpdateScene.convexPoints	graphupdatescene.html#convexPoints	Private cached convex hull of the points.
Pathfinding.GraphUpdateScene.firstApplied	graphupdatescene.html#firstApplied	Has apply been called yet. \n\nUsed to prevent applying twice when both applyOnScan and applyOnStart are enabled
Pathfinding.GraphUpdateScene.legacyMode	graphupdatescene.html#legacyMode	Emulates behavior from before version 4.0.
Pathfinding.GraphUpdateScene.legacyUseWorldSpace	graphupdatescene.html#legacyUseWorldSpace	Use world space for coordinates. \n\nIf true, the shape will not follow when moving around the transform.
Pathfinding.GraphUpdateScene.minBoundsHeight	graphupdatescene.html#minBoundsHeight	Minumum height of the bounds of the resulting Graph Update Object. \n\nUseful when all points are laid out on a plane but you still need a bounds with a height greater than zero since a zero height graph update object would usually result in no nodes being updated.
Pathfinding.GraphUpdateScene.modifyTag	graphupdatescene.html#modifyTag	Should the tags of the nodes be modified. \n\nIf enabled, set all nodes' tags to setTag
Pathfinding.GraphUpdateScene.modifyWalkability	graphupdatescene.html#modifyWalkability	If true, then all affected nodes will be made walkable or unwalkable according to setWalkability.
Pathfinding.GraphUpdateScene.penaltyDelta	graphupdatescene.html#penaltyDelta	Penalty to add to nodes. \n\nUsually you need quite large values, at least 1000-10000. A higher penalty means that agents will try to avoid those nodes more.\n\nBe careful when setting negative values since if a node gets a negative penalty it will underflow and instead get really large. In most cases a warning will be logged if that happens.\n\n[more in online documentation]
Pathfinding.GraphUpdateScene.points	graphupdatescene.html#points	Points which define the region to update.
Pathfinding.GraphUpdateScene.resetPenaltyOnPhysics	graphupdatescene.html#resetPenaltyOnPhysics	Reset penalties to their initial values when updating grid graphs and updatePhysics is true. \n\nIf you want to keep old penalties even when you update the graph you may want to disable this option.\n\nThe images below shows two overlapping graph update objects, the right one happened to be applied before the left one. They both have updatePhysics = true and are set to increase the penalty of the nodes by some amount.\n\nThe first image shows the result when resetPenaltyOnPhysics is false. Both penalties are added correctly.  <b>[image in online documentation]</b>\n\nThis second image shows when resetPenaltyOnPhysics is set to true. The first GUO is applied correctly, but then the second one (the left one) is applied and during its updating, it resets the penalties first and then adds penalty to the nodes. The result is that the penalties from both GUOs are not added together. The green patch in at the border is there because physics recalculation (recalculation of the position of the node, checking for obstacles etc.) affects a slightly larger area than the original GUO bounds because of the Grid Graph -&gt; Collision Testing -&gt; Diameter setting (it is enlarged by that value). So some extra nodes have their penalties reset.\n\n <b>[image in online documentation]</b>
Pathfinding.GraphUpdateScene.setTag	graphupdatescene.html#setTag	If modifyTag is enabled, set all nodes' tags to this value.
Pathfinding.GraphUpdateScene.setTagCompatibility	graphupdatescene.html#setTagCompatibility	
Pathfinding.GraphUpdateScene.setTagInvert	graphupdatescene.html#setTagInvert	Private cached inversion of setTag. \n\nUsed for InvertSettings()
Pathfinding.GraphUpdateScene.setWalkability	graphupdatescene.html#setWalkability	Nodes will be made walkable or unwalkable according to this value if modifyWalkability is true.
Pathfinding.GraphUpdateScene.updateErosion	graphupdatescene.html#updateErosion	Update Erosion for GridGraphs. \n\nWhen enabled, erosion will be recalculated for grid graphs after the GUO has been applied.\n\nIn the below image you can see the different effects you can get with the different values.\n\nThe first image shows the graph when no GUO has been applied. The blue box is not identified as an obstacle by the graph, the reason there are unwalkable nodes around it is because there is a height difference (nodes are placed on top of the box) so erosion will be applied (an erosion value of 2 is used in this graph). The orange box is identified as an obstacle, so the area of unwalkable nodes around it is a bit larger since both erosion and collision has made nodes unwalkable.\n\nThe GUO used simply sets walkability to true, i.e making all nodes walkable.\n\n <b>[image in online documentation]</b>\n\nWhen updateErosion=True, the reason the blue box still has unwalkable nodes around it is because there is still a height difference so erosion will still be applied. The orange box on the other hand has no height difference and all nodes are set to walkable.\n\nWhen updateErosion=False, all nodes walkability are simply set to be walkable in this example.\n\n[more in online documentation]
Pathfinding.GraphUpdateScene.updatePhysics	graphupdatescene.html#updatePhysics	Update node's walkability and connectivity using physics functions. \n\nFor grid graphs, this will update the node's position and walkability exactly like when doing a scan of the graph. If enabled for grid graphs, modifyWalkability will be ignored.\n\nFor Point Graphs, this will recalculate all connections which passes through the bounds of the resulting Graph Update Object using raycasts (if enabled).
Pathfinding.GraphUpdateSceneEditor.PointColor	graphupdatesceneeditor.html#PointColor	
Pathfinding.GraphUpdateSceneEditor.PointSelectedColor	graphupdatesceneeditor.html#PointSelectedColor	
Pathfinding.GraphUpdateSceneEditor.pointGizmosRadius	graphupdatesceneeditor.html#pointGizmosRadius	
Pathfinding.GraphUpdateSceneEditor.scripts	graphupdatesceneeditor.html#scripts	
Pathfinding.GraphUpdateSceneEditor.selectedPoint	graphupdatesceneeditor.html#selectedPoint	
Pathfinding.GraphUpdateShape.BurstShape.Everything	burstshape.html#Everything	Shape that contains everything.
Pathfinding.GraphUpdateShape.BurstShape.containsEverything	burstshape.html#containsEverything	
Pathfinding.GraphUpdateShape.BurstShape.forward	burstshape.html#forward	
Pathfinding.GraphUpdateShape.BurstShape.origin	burstshape.html#origin	
Pathfinding.GraphUpdateShape.BurstShape.points	burstshape.html#points	
Pathfinding.GraphUpdateShape.BurstShape.right	burstshape.html#right	
Pathfinding.GraphUpdateShape._convex	graphupdateshape.html#_convex	
Pathfinding.GraphUpdateShape._convexPoints	graphupdateshape.html#_convexPoints	
Pathfinding.GraphUpdateShape._points	graphupdateshape.html#_points	
Pathfinding.GraphUpdateShape.convex	graphupdateshape.html#convex	Sets if the convex hull of the points should be calculated. \n\nConvex hulls are faster but non-convex hulls can be used to specify more complicated shapes.
Pathfinding.GraphUpdateShape.forward	graphupdateshape.html#forward	
Pathfinding.GraphUpdateShape.minimumHeight	graphupdateshape.html#minimumHeight	
Pathfinding.GraphUpdateShape.origin	graphupdateshape.html#origin	
Pathfinding.GraphUpdateShape.points	graphupdateshape.html#points	Gets or sets the points of the polygon in the shape. \n\nThese points should be specified in clockwise order. Will automatically calculate the convex hull if convex is set to true
Pathfinding.GraphUpdateShape.right	graphupdateshape.html#right	
Pathfinding.GraphUpdateShape.up	graphupdateshape.html#up	
Pathfinding.GraphUpdateStage	pathfinding.html#GraphUpdateStage	Info about if a graph update has been applied or not.
Pathfinding.GraphUpdateThreading	pathfinding.html#GraphUpdateThreading	
Pathfinding.Graphs.Grid.ColliderType	grid.html#ColliderType	Determines collision check shape. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.RaycastErrorMargin	graphcollision.html#RaycastErrorMargin	Offset to apply after each raycast to make sure we don't hit the same point again in CheckHeightAll.
Pathfinding.Graphs.Grid.GraphCollision.collisionCheck	graphcollision.html#collisionCheck	Toggle collision check.
Pathfinding.Graphs.Grid.GraphCollision.collisionOffset	graphcollision.html#collisionOffset	Height above the ground that collision checks should be done. \n\nFor example, if the ground was found at y=0, collisionOffset = 2 type = Capsule and height = 3 then the physics system will be queried to see if there are any colliders in a capsule for which the bottom sphere that is made up of is centered at y=2 and the top sphere has its center at y=2+3=5.\n\nIf type = Sphere then the sphere's center would be at y=2 in this case.
Pathfinding.Graphs.Grid.GraphCollision.contactFilter	graphcollision.html#contactFilter	Used for 2D collision queries.
Pathfinding.Graphs.Grid.GraphCollision.diameter	graphcollision.html#diameter	Diameter of capsule or sphere when checking for collision. \n\nWhen checking for collisions the system will check if any colliders overlap a specific shape at the node's position. The shape is determined by the type field.\n\nA diameter of 1 means that the shape has a diameter equal to the node's width, or in other words it is equal to nodeSize .\n\nIf type is set to Ray, this does not affect anything.\n\n <b>[image in online documentation]</b>
Pathfinding.Graphs.Grid.GraphCollision.dummyArray	graphcollision.html#dummyArray	Just so that the Physics2D.OverlapPoint method has some buffer to store things in. \n\nWe never actually read from this array, so we don't even care if this is thread safe.
Pathfinding.Graphs.Grid.GraphCollision.finalRadius	graphcollision.html#finalRadius	diameter * scale * 0.5. \n\nWhere <b>scale</b> usually is nodeSize  \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.finalRaycastRadius	graphcollision.html#finalRaycastRadius	thickRaycastDiameter * scale * 0.5. \n\nWhere <b>scale</b> usually is nodeSize  \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.fromHeight	graphcollision.html#fromHeight	The height to check from when checking height ('ray length' in the inspector). \n\nAs the image below visualizes, different ray lengths can make the ray hit different things. The distance is measured up from the graph plane.\n\n <b>[image in online documentation]</b>
Pathfinding.Graphs.Grid.GraphCollision.height	graphcollision.html#height	Height of capsule or length of ray when checking for collision. \n\nIf type is set to Sphere, this does not affect anything.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.heightCheck	graphcollision.html#heightCheck	Toggle height check. \n\nIf false, the grid will be flat.\n\nThis setting will be ignored when 2D physics is used.
Pathfinding.Graphs.Grid.GraphCollision.heightMask	graphcollision.html#heightMask	Layers to be included in the height check.
Pathfinding.Graphs.Grid.GraphCollision.hitBuffer	graphcollision.html#hitBuffer	Internal buffer used by CheckHeightAll.
Pathfinding.Graphs.Grid.GraphCollision.mask	graphcollision.html#mask	Layers to be treated as obstacles.
Pathfinding.Graphs.Grid.GraphCollision.rayDirection	graphcollision.html#rayDirection	Direction of the ray when checking for collision. \n\nIf type is not Ray, this does not affect anything\n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.thickRaycast	graphcollision.html#thickRaycast	Toggles thick raycast. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.thickRaycastDiameter	graphcollision.html#thickRaycastDiameter	Diameter of the thick raycast in nodes. \n\n1 equals nodeSize
Pathfinding.Graphs.Grid.GraphCollision.type	graphcollision.html#type	Collision shape to use. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.unwalkableWhenNoGround	graphcollision.html#unwalkableWhenNoGround	Make nodes unwalkable when no ground was found with the height raycast. \n\nIf height raycast is turned off, this doesn't affect anything.
Pathfinding.Graphs.Grid.GraphCollision.up	graphcollision.html#up	Direction to use as <b>UP</b>. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.upheight	graphcollision.html#upheight	up * height. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GraphCollision.use2D	graphcollision.html#use2D	Use Unity 2D Physics API. \n\nIf enabled, the 2D Physics API will be used, and if disabled, the 3D Physics API will be used.\n\nThis changes the collider types (see type) from 3D versions to their corresponding 2D versions. For example the sphere shape becomes a circle.\n\nThe heightCheck setting will be ignored when 2D physics is used.\n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphNodeData.LightReader.nodePositions	lightreader.html#nodePositions	
Pathfinding.Graphs.Grid.GridGraphNodeData.LightReader.nodeWalkable	lightreader.html#nodeWalkable	
Pathfinding.Graphs.Grid.GridGraphNodeData.LightReader.nodes	lightreader.html#nodes	
Pathfinding.Graphs.Grid.GridGraphNodeData.allocationMethod	gridgraphnodedata.html#allocationMethod	
Pathfinding.Graphs.Grid.GridGraphNodeData.bounds	gridgraphnodedata.html#bounds	Bounds for the part of the graph that this data represents. \n\nFor example if the first layer of a layered grid graph is being updated between x=10 and x=20, z=5 and z=15 then this will be IntBounds(xmin=10, ymin=0, zmin=5, xmax=20, ymax=0, zmax=15)
Pathfinding.Graphs.Grid.GridGraphNodeData.connections	gridgraphnodedata.html#connections	Bitpacked connections of all nodes. \n\nConnections are stored in different formats depending on layeredDataLayout. You can use LayeredGridAdjacencyMapper and FlatGridAdjacencyMapper to access connections for the different data layouts.\n\nData is valid in these passes:\n- BeforeCollision: Invalid\n\n- BeforeConnections: Invalid\n\n- AfterConnections: Valid\n\n- AfterErosion: Valid (but will be overwritten)\n\n- PostProcess: Valid
Pathfinding.Graphs.Grid.GridGraphNodeData.layeredDataLayout	gridgraphnodedata.html#layeredDataLayout	True if the data may have multiple layers. \n\nFor layered data the nodes are laid out as `data[y*width*depth + z*width + x]`. For non-layered data the nodes are laid out as `data[z*width + x]` (which is equivalent to the above layout assuming y=0).\n\nThis also affects how node connections are stored. You can use LayeredGridAdjacencyMapper and FlatGridAdjacencyMapper to access connections for the different data layouts.
Pathfinding.Graphs.Grid.GridGraphNodeData.layers	gridgraphnodedata.html#layers	Number of layers that the data contains. \n\nFor a non-layered grid graph this will always be 1.
Pathfinding.Graphs.Grid.GridGraphNodeData.normals	gridgraphnodedata.html#normals	Normals of all nodes. \n\nIf height testing is disabled the normal will be (0,1,0) for all nodes. If a node doesn't exist (only happens in layered grid graphs) or if the height raycast didn't hit anything then the normal will be (0,0,0).\n\nData is valid in these passes:\n- BeforeCollision: Valid\n\n- BeforeConnections: Valid\n\n- AfterConnections: Valid\n\n- AfterErosion: Valid\n\n- PostProcess: Valid
Pathfinding.Graphs.Grid.GridGraphNodeData.numNodes	gridgraphnodedata.html#numNodes	
Pathfinding.Graphs.Grid.GridGraphNodeData.penalties	gridgraphnodedata.html#penalties	Bitpacked connections of all nodes. \n\nData is valid in these passes:\n- BeforeCollision: Valid\n\n- BeforeConnections: Valid\n\n- AfterConnections: Valid\n\n- AfterErosion: Valid\n\n- PostProcess: Valid
Pathfinding.Graphs.Grid.GridGraphNodeData.positions	gridgraphnodedata.html#positions	Positions of all nodes. \n\nData is valid in these passes:\n- BeforeCollision: Valid\n\n- BeforeConnections: Valid\n\n- AfterConnections: Valid\n\n- AfterErosion: Valid\n\n- PostProcess: Valid
Pathfinding.Graphs.Grid.GridGraphNodeData.tags	gridgraphnodedata.html#tags	Tags of all nodes. \n\nData is valid in these passes:\n- BeforeCollision: Valid (but if erosion uses tags then it will be overwritten later)\n\n- BeforeConnections: Valid (but if erosion uses tags then it will be overwritten later)\n\n- AfterConnections: Valid (but if erosion uses tags then it will be overwritten later)\n\n- AfterErosion: Valid\n\n- PostProcess: Valid
Pathfinding.Graphs.Grid.GridGraphNodeData.walkable	gridgraphnodedata.html#walkable	Walkability of all nodes before erosion happens. \n\nData is valid in these passes:\n- BeforeCollision: Valid (it will be combined with collision testing later)\n\n- BeforeConnections: Valid\n\n- AfterConnections: Valid\n\n- AfterErosion: Valid\n\n- PostProcess: Valid
Pathfinding.Graphs.Grid.GridGraphNodeData.walkableWithErosion	gridgraphnodedata.html#walkableWithErosion	Walkability of all nodes after erosion happens. \n\nThis is the final walkability of the nodes. If no erosion is used then the data will just be copied from the walkable array.\n\nData is valid in these passes:\n- BeforeCollision: Invalid\n\n- BeforeConnections: Invalid\n\n- AfterConnections: Invalid\n\n- AfterErosion: Valid\n\n- PostProcess: Valid
Pathfinding.Graphs.Grid.GridGraphScanData.bounds	gridgraphscandata.html#bounds	Bounds of the data arrays. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.dependencyTracker	gridgraphscandata.html#dependencyTracker	Tracks dependencies between jobs to allow parallelism without tediously specifying dependencies manually. \n\nAlways use when scheduling jobs.
Pathfinding.Graphs.Grid.GridGraphScanData.heightHits	gridgraphscandata.html#heightHits	Raycasts hits used for height testing. \n\nThis data is only valid if height testing is enabled, otherwise the array is uninitialized (heightHits.IsCreated will be false).\n\nData is valid in these passes:\n- BeforeCollision: Valid (if height testing is enabled)\n\n- BeforeConnections: Valid (if height testing is enabled)\n\n- AfterConnections: Valid (if height testing is enabled)\n\n- AfterErosion: Valid (if height testing is enabled)\n\n- PostProcess: Valid (if height testing is enabled)\n\n\n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.heightHitsBounds	gridgraphscandata.html#heightHitsBounds	Bounds for the heightHits array. \n\nDuring an update, the scan data may contain more nodes than we are doing height testing for. For a few nodes around the update, the data will be read from the existing graph, instead. This is done for performance. This means that there may not be any height testing information these nodes. However, all nodes that will be written to will always have height testing information.
Pathfinding.Graphs.Grid.GridGraphScanData.layeredDataLayout	gridgraphscandata.html#layeredDataLayout	True if the data may have multiple layers. \n\nFor layered data the nodes are laid out as `data[y*width*depth + z*width + x]`. For non-layered data the nodes are laid out as `data[z*width + x]` (which is equivalent to the above layout assuming y=0).\n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodeConnections	gridgraphscandata.html#nodeConnections	Node connections. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodeNormals	gridgraphscandata.html#nodeNormals	Node normals. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodePenalties	gridgraphscandata.html#nodePenalties	Node penalties. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodePositions	gridgraphscandata.html#nodePositions	Node positions. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodeTags	gridgraphscandata.html#nodeTags	Node tags. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodeWalkable	gridgraphscandata.html#nodeWalkable	Node walkability. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodeWalkableWithErosion	gridgraphscandata.html#nodeWalkableWithErosion	Node walkability with erosion. \n\n[more in online documentation]
Pathfinding.Graphs.Grid.GridGraphScanData.nodes	gridgraphscandata.html#nodes	Data for all nodes in the graph update that is being calculated.
Pathfinding.Graphs.Grid.GridGraphScanData.transform	gridgraphscandata.html#transform	Transforms graph-space to world space.
Pathfinding.Graphs.Grid.GridGraphScanData.up	gridgraphscandata.html#up	The up direction of the graph, in world space.
Pathfinding.Graphs.Grid.Jobs.JobAllocateNodes.active	joballocatenodes.html#active	
Pathfinding.Graphs.Grid.Jobs.JobAllocateNodes.dataBounds	joballocatenodes.html#dataBounds	
Pathfinding.Graphs.Grid.Jobs.JobAllocateNodes.newGridNodeDelegate	joballocatenodes.html#newGridNodeDelegate	
Pathfinding.Graphs.Grid.Jobs.JobAllocateNodes.nodeArrayBounds	joballocatenodes.html#nodeArrayBounds	
Pathfinding.Graphs.Grid.Jobs.JobAllocateNodes.nodeNormals	joballocatenodes.html#nodeNormals	
Pathfinding.Graphs.Grid.Jobs.JobAllocateNodes.nodes	joballocatenodes.html#nodes	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.allowBoundsChecks	jobcalculategridconnections.html#allowBoundsChecks	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.arrayBounds	jobcalculategridconnections.html#arrayBounds	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.bounds	jobcalculategridconnections.html#bounds	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.characterHeight	jobcalculategridconnections.html#characterHeight	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.cutCorners	jobcalculategridconnections.html#cutCorners	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.graphToWorld	jobcalculategridconnections.html#graphToWorld	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.layeredDataLayout	jobcalculategridconnections.html#layeredDataLayout	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.maxStepHeight	jobcalculategridconnections.html#maxStepHeight	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.maxStepUsesSlope	jobcalculategridconnections.html#maxStepUsesSlope	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.neighbours	jobcalculategridconnections.html#neighbours	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.nodeConnections	jobcalculategridconnections.html#nodeConnections	All bitpacked node connections.
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.nodeNormals	jobcalculategridconnections.html#nodeNormals	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.nodePositions	jobcalculategridconnections.html#nodePositions	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.nodeWalkable	jobcalculategridconnections.html#nodeWalkable	
Pathfinding.Graphs.Grid.Jobs.JobCalculateGridConnections.use2D	jobcalculategridconnections.html#use2D	
Pathfinding.Graphs.Grid.Jobs.JobCheckCollisions.collision	jobcheckcollisions.html#collision	
Pathfinding.Graphs.Grid.Jobs.JobCheckCollisions.collisionResult	jobcheckcollisions.html#collisionResult	
Pathfinding.Graphs.Grid.Jobs.JobCheckCollisions.nodePositions	jobcheckcollisions.html#nodePositions	
Pathfinding.Graphs.Grid.Jobs.JobCheckCollisions.startIndex	jobcheckcollisions.html#startIndex	
Pathfinding.Graphs.Grid.Jobs.JobColliderHitsToBooleans.hits	jobcolliderhitstobooleans.html#hits	
Pathfinding.Graphs.Grid.Jobs.JobColliderHitsToBooleans.result	jobcolliderhitstobooleans.html#result	
Pathfinding.Graphs.Grid.Jobs.JobCopyBuffers.bounds	jobcopybuffers.html#bounds	
Pathfinding.Graphs.Grid.Jobs.JobCopyBuffers.copyPenaltyAndTags	jobcopybuffers.html#copyPenaltyAndTags	
Pathfinding.Graphs.Grid.Jobs.JobCopyBuffers.input	jobcopybuffers.html#input	
Pathfinding.Graphs.Grid.Jobs.JobCopyBuffers.output	jobcopybuffers.html#output	
Pathfinding.Graphs.Grid.Jobs.JobErosion.bounds	joberosion.html#bounds	
Pathfinding.Graphs.Grid.Jobs.JobErosion.erosion	joberosion.html#erosion	
Pathfinding.Graphs.Grid.Jobs.JobErosion.erosionStartTag	joberosion.html#erosionStartTag	
Pathfinding.Graphs.Grid.Jobs.JobErosion.erosionTagsPrecedenceMask	joberosion.html#erosionTagsPrecedenceMask	
Pathfinding.Graphs.Grid.Jobs.JobErosion.erosionUsesTags	joberosion.html#erosionUsesTags	
Pathfinding.Graphs.Grid.Jobs.JobErosion.hexagonNeighbourIndices	joberosion.html#hexagonNeighbourIndices	
Pathfinding.Graphs.Grid.Jobs.JobErosion.neighbours	joberosion.html#neighbours	
Pathfinding.Graphs.Grid.Jobs.JobErosion.nodeConnections	joberosion.html#nodeConnections	
Pathfinding.Graphs.Grid.Jobs.JobErosion.nodeTags	joberosion.html#nodeTags	
Pathfinding.Graphs.Grid.Jobs.JobErosion.nodeWalkable	joberosion.html#nodeWalkable	
Pathfinding.Graphs.Grid.Jobs.JobErosion.outNodeWalkable	joberosion.html#outNodeWalkable	
Pathfinding.Graphs.Grid.Jobs.JobErosion.writeMask	joberosion.html#writeMask	
Pathfinding.Graphs.Grid.Jobs.JobFilterDiagonalConnections.allowBoundsChecks	jobfilterdiagonalconnections.html#allowBoundsChecks	
Pathfinding.Graphs.Grid.Jobs.JobFilterDiagonalConnections.cutCorners	jobfilterdiagonalconnections.html#cutCorners	
Pathfinding.Graphs.Grid.Jobs.JobFilterDiagonalConnections.neighbours	jobfilterdiagonalconnections.html#neighbours	
Pathfinding.Graphs.Grid.Jobs.JobFilterDiagonalConnections.nodeConnections	jobfilterdiagonalconnections.html#nodeConnections	All bitpacked node connections.
Pathfinding.Graphs.Grid.Jobs.JobFilterDiagonalConnections.slice	jobfilterdiagonalconnections.html#slice	
Pathfinding.Graphs.Grid.Jobs.JobMergeRaycastCollisionHits.hit1	jobmergeraycastcollisionhits.html#hit1	
Pathfinding.Graphs.Grid.Jobs.JobMergeRaycastCollisionHits.hit2	jobmergeraycastcollisionhits.html#hit2	
Pathfinding.Graphs.Grid.Jobs.JobMergeRaycastCollisionHits.result	jobmergeraycastcollisionhits.html#result	
Pathfinding.Graphs.Grid.Jobs.JobNodeGridLayout.bounds	jobnodegridlayout.html#bounds	
Pathfinding.Graphs.Grid.Jobs.JobNodeGridLayout.graphToWorld	jobnodegridlayout.html#graphToWorld	
Pathfinding.Graphs.Grid.Jobs.JobNodeGridLayout.nodePositions	jobnodegridlayout.html#nodePositions	
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.characterHeight	jobnodewalkability.html#characterHeight	For layered grid graphs, if there's a node above another node closer than this distance, the lower node will be made unwalkable.
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.layerStride	jobnodewalkability.html#layerStride	Number of nodes in each layer.
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.maxSlope	jobnodewalkability.html#maxSlope	Max slope in degrees.
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.nodeNormals	jobnodewalkability.html#nodeNormals	
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.nodePositions	jobnodewalkability.html#nodePositions	
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.nodeWalkable	jobnodewalkability.html#nodeWalkable	
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.unwalkableWhenNoGround	jobnodewalkability.html#unwalkableWhenNoGround	If true, nodes will be made unwalkable if no ground was found under them.
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.up	jobnodewalkability.html#up	Normalized up direction of the graph.
Pathfinding.Graphs.Grid.Jobs.JobNodeWalkability.useRaycastNormal	jobnodewalkability.html#useRaycastNormal	If true, use the normal of the raycast hit to check if the ground is flat enough to stand on. \n\nAny nodes with a steeper slope than maxSlope will be made unwalkable.
Pathfinding.Graphs.Grid.Jobs.JobPrepareCapsuleCommands.commands	jobpreparecapsulecommands.html#commands	
Pathfinding.Graphs.Grid.Jobs.JobPrepareCapsuleCommands.direction	jobpreparecapsulecommands.html#direction	
Pathfinding.Graphs.Grid.Jobs.JobPrepareCapsuleCommands.mask	jobpreparecapsulecommands.html#mask	
Pathfinding.Graphs.Grid.Jobs.JobPrepareCapsuleCommands.originOffset	jobpreparecapsulecommands.html#originOffset	
Pathfinding.Graphs.Grid.Jobs.JobPrepareCapsuleCommands.origins	jobpreparecapsulecommands.html#origins	
Pathfinding.Graphs.Grid.Jobs.JobPrepareCapsuleCommands.physicsScene	jobpreparecapsulecommands.html#physicsScene	
Pathfinding.Graphs.Grid.Jobs.JobPrepareCapsuleCommands.radius	jobpreparecapsulecommands.html#radius	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycast.bounds	jobpreparegridraycast.html#bounds	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycast.graphToWorld	jobpreparegridraycast.html#graphToWorld	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycast.physicsScene	jobpreparegridraycast.html#physicsScene	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycast.raycastCommands	jobpreparegridraycast.html#raycastCommands	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycast.raycastDirection	jobpreparegridraycast.html#raycastDirection	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycast.raycastMask	jobpreparegridraycast.html#raycastMask	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycast.raycastOffset	jobpreparegridraycast.html#raycastOffset	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.bounds	jobpreparegridraycastthick.html#bounds	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.graphToWorld	jobpreparegridraycastthick.html#graphToWorld	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.physicsScene	jobpreparegridraycastthick.html#physicsScene	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.radius	jobpreparegridraycastthick.html#radius	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.raycastCommands	jobpreparegridraycastthick.html#raycastCommands	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.raycastDirection	jobpreparegridraycastthick.html#raycastDirection	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.raycastMask	jobpreparegridraycastthick.html#raycastMask	
Pathfinding.Graphs.Grid.Jobs.JobPrepareGridRaycastThick.raycastOffset	jobpreparegridraycastthick.html#raycastOffset	
Pathfinding.Graphs.Grid.Jobs.JobPrepareRaycasts.direction	jobprepareraycasts.html#direction	
Pathfinding.Graphs.Grid.Jobs.JobPrepareRaycasts.distance	jobprepareraycasts.html#distance	
Pathfinding.Graphs.Grid.Jobs.JobPrepareRaycasts.mask	jobprepareraycasts.html#mask	
Pathfinding.Graphs.Grid.Jobs.JobPrepareRaycasts.originOffset	jobprepareraycasts.html#originOffset	
Pathfinding.Graphs.Grid.Jobs.JobPrepareRaycasts.origins	jobprepareraycasts.html#origins	
Pathfinding.Graphs.Grid.Jobs.JobPrepareRaycasts.physicsScene	jobprepareraycasts.html#physicsScene	
Pathfinding.Graphs.Grid.Jobs.JobPrepareRaycasts.raycastCommands	jobprepareraycasts.html#raycastCommands	
Pathfinding.Graphs.Grid.Jobs.JobPrepareSphereCommands.commands	jobpreparespherecommands.html#commands	
Pathfinding.Graphs.Grid.Jobs.JobPrepareSphereCommands.mask	jobpreparespherecommands.html#mask	
Pathfinding.Graphs.Grid.Jobs.JobPrepareSphereCommands.originOffset	jobpreparespherecommands.html#originOffset	
Pathfinding.Graphs.Grid.Jobs.JobPrepareSphereCommands.origins	jobpreparespherecommands.html#origins	
Pathfinding.Graphs.Grid.Jobs.JobPrepareSphereCommands.physicsScene	jobpreparespherecommands.html#physicsScene	
Pathfinding.Graphs.Grid.Jobs.JobPrepareSphereCommands.radius	jobpreparespherecommands.html#radius	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.Reader.nodeConnections	reader.html#nodeConnections	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.Reader.nodePenalties	reader.html#nodePenalties	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.Reader.nodePositions	reader.html#nodePositions	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.Reader.nodeTags	reader.html#nodeTags	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.Reader.nodeWalkable	reader.html#nodeWalkable	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.Reader.nodeWalkableWithErosion	reader.html#nodeWalkableWithErosion	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.Reader.nodes	reader.html#nodes	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.allowBoundsChecks	jobreadnodedata.html#allowBoundsChecks	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.graphIndex	jobreadnodedata.html#graphIndex	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.nodeConnections	jobreadnodedata.html#nodeConnections	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.nodePenalties	jobreadnodedata.html#nodePenalties	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.nodePositions	jobreadnodedata.html#nodePositions	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.nodeTags	jobreadnodedata.html#nodeTags	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.nodeWalkable	jobreadnodedata.html#nodeWalkable	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.nodeWalkableWithErosion	jobreadnodedata.html#nodeWalkableWithErosion	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.nodesHandle	jobreadnodedata.html#nodesHandle	
Pathfinding.Graphs.Grid.Jobs.JobReadNodeData.slice	jobreadnodedata.html#slice	
Pathfinding.Graphs.Grid.Jobs.JobRelocateNodes.bounds	jobrelocatenodes.html#bounds	
Pathfinding.Graphs.Grid.Jobs.JobRelocateNodes.graphToWorld	jobrelocatenodes.html#graphToWorld	
Pathfinding.Graphs.Grid.Jobs.JobRelocateNodes.positions	jobrelocatenodes.html#positions	
Pathfinding.Graphs.Grid.Jobs.JobRelocateNodes.previousWorldToGraph	jobrelocatenodes.html#previousWorldToGraph	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.allowBoundsChecks	jobwritenodedata.html#allowBoundsChecks	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.dataBounds	jobwritenodedata.html#dataBounds	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.graphIndex	jobwritenodedata.html#graphIndex	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodeArrayBounds	jobwritenodedata.html#nodeArrayBounds	(width, depth) of the array that the nodesHandle refers to
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodeConnections	jobwritenodedata.html#nodeConnections	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodePenalties	jobwritenodedata.html#nodePenalties	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodePositions	jobwritenodedata.html#nodePositions	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodeTags	jobwritenodedata.html#nodeTags	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodeWalkable	jobwritenodedata.html#nodeWalkable	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodeWalkableWithErosion	jobwritenodedata.html#nodeWalkableWithErosion	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.nodesHandle	jobwritenodedata.html#nodesHandle	
Pathfinding.Graphs.Grid.Jobs.JobWriteNodeData.writeMask	jobwritenodedata.html#writeMask	
Pathfinding.Graphs.Grid.RayDirection	grid.html#RayDirection	Determines collision check ray direction.
Pathfinding.Graphs.Grid.Rules.CustomGridGraphRuleEditorAttribute.name	customgridgraphruleeditorattribute.html#name	
Pathfinding.Graphs.Grid.Rules.CustomGridGraphRuleEditorAttribute.type	customgridgraphruleeditorattribute.html#type	
Pathfinding.Graphs.Grid.Rules.GridGraphRule.Hash	gridgraphrule.html#Hash	Hash of the settings for this rule. \n\nThe Register method will be called again whenever the hash changes. If the hash does not change it is assumed that the Register method does not need to be called again.
Pathfinding.Graphs.Grid.Rules.GridGraphRule.Pass	gridgraphrule.html#Pass	Where in the scanning process a rule will be executed. \n\nCheck the documentation for GridGraphScanData to see which data fields are valid in which passes.
Pathfinding.Graphs.Grid.Rules.GridGraphRule.dirty	gridgraphrule.html#dirty	
Pathfinding.Graphs.Grid.Rules.GridGraphRule.enabled	gridgraphrule.html#enabled	Only enabled rules are executed.
Pathfinding.Graphs.Grid.Rules.GridGraphRules.Context.data	context2.html#data	Data for all the nodes as NativeArrays.
Pathfinding.Graphs.Grid.Rules.GridGraphRules.Context.graph	context2.html#graph	Graph which is being scanned or updated.
Pathfinding.Graphs.Grid.Rules.GridGraphRules.Context.tracker	context2.html#tracker	Tracks dependencies between jobs to allow parallelism without tediously specifying dependencies manually. \n\nAlways use when scheduling jobs.
Pathfinding.Graphs.Grid.Rules.GridGraphRules.jobSystemCallbacks	gridgraphrules.html#jobSystemCallbacks	
Pathfinding.Graphs.Grid.Rules.GridGraphRules.lastHash	gridgraphrules.html#lastHash	
Pathfinding.Graphs.Grid.Rules.GridGraphRules.mainThreadCallbacks	gridgraphrules.html#mainThreadCallbacks	
Pathfinding.Graphs.Grid.Rules.GridGraphRules.rules	gridgraphrules.html#rules	List of all rules.
Pathfinding.Graphs.Grid.Rules.RuleAnglePenalty.JobPenaltyAngle.angleToPenalty	jobpenaltyangle.html#angleToPenalty	
Pathfinding.Graphs.Grid.Rules.RuleAnglePenalty.JobPenaltyAngle.nodeNormals	jobpenaltyangle.html#nodeNormals	
Pathfinding.Graphs.Grid.Rules.RuleAnglePenalty.JobPenaltyAngle.penalty	jobpenaltyangle.html#penalty	
Pathfinding.Graphs.Grid.Rules.RuleAnglePenalty.JobPenaltyAngle.up	jobpenaltyangle.html#up	
Pathfinding.Graphs.Grid.Rules.RuleAnglePenalty.angleToPenalty	ruleanglepenalty.html#angleToPenalty	
Pathfinding.Graphs.Grid.Rules.RuleAnglePenalty.curve	ruleanglepenalty.html#curve	
Pathfinding.Graphs.Grid.Rules.RuleAnglePenalty.penaltyScale	ruleanglepenalty.html#penaltyScale	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.JobElevationPenalty.elevationToPenalty	jobelevationpenalty.html#elevationToPenalty	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.JobElevationPenalty.nodePositions	jobelevationpenalty.html#nodePositions	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.JobElevationPenalty.penalty	jobelevationpenalty.html#penalty	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.JobElevationPenalty.worldToGraph	jobelevationpenalty.html#worldToGraph	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.curve	ruleelevationpenalty.html#curve	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.elevationRange	ruleelevationpenalty.html#elevationRange	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.elevationToPenalty	ruleelevationpenalty.html#elevationToPenalty	
Pathfinding.Graphs.Grid.Rules.RuleElevationPenalty.penaltyScale	ruleelevationpenalty.html#penaltyScale	
Pathfinding.Graphs.Grid.Rules.RulePerLayerModifications.PerLayerRule.action	perlayerrule.html#action	The action to apply to matching nodes.
Pathfinding.Graphs.Grid.Rules.RulePerLayerModifications.PerLayerRule.layer	perlayerrule.html#layer	Layer this rule applies to.
Pathfinding.Graphs.Grid.Rules.RulePerLayerModifications.PerLayerRule.tag	perlayerrule.html#tag	Tag for the RuleAction.SetTag action. \n\nMust be between 0 and Pathfinding.GraphNode.MaxTagIndex
Pathfinding.Graphs.Grid.Rules.RulePerLayerModifications.RuleAction	ruleperlayermodifications.html#RuleAction	
Pathfinding.Graphs.Grid.Rules.RulePerLayerModifications.SetTagBit	ruleperlayermodifications.html#SetTagBit	
Pathfinding.Graphs.Grid.Rules.RulePerLayerModifications.layerRules	ruleperlayermodifications.html#layerRules	
Pathfinding.Graphs.Grid.Rules.RuleTexture.ChannelUse	ruletexture.html#ChannelUse	
Pathfinding.Graphs.Grid.Rules.RuleTexture.Hash	ruletexture.html#Hash	Hash of the settings for this rule. \n\nThe Register method will be called again whenever the hash changes. If the hash does not change it is assumed that the Register method does not need to be called again.
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.bounds	jobtexturepenalty.html#bounds	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.channelDeterminesWalkability	jobtexturepenalty.html#channelDeterminesWalkability	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.channelPenalties	jobtexturepenalty.html#channelPenalties	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.colorData	jobtexturepenalty.html#colorData	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.colorDataSize	jobtexturepenalty.html#colorDataSize	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.nodeNormals	jobtexturepenalty.html#nodeNormals	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.penalty	jobtexturepenalty.html#penalty	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.scale	jobtexturepenalty.html#scale	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePenalty.walkable	jobtexturepenalty.html#walkable	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.bounds	jobtextureposition.html#bounds	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.channelPositionScale	jobtextureposition.html#channelPositionScale	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.colorData	jobtextureposition.html#colorData	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.colorDataSize	jobtextureposition.html#colorDataSize	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.graphToWorld	jobtextureposition.html#graphToWorld	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.nodeNormals	jobtextureposition.html#nodeNormals	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.nodePositions	jobtextureposition.html#nodePositions	
Pathfinding.Graphs.Grid.Rules.RuleTexture.JobTexturePosition.scale	jobtextureposition.html#scale	
Pathfinding.Graphs.Grid.Rules.RuleTexture.ScalingMode	ruletexture.html#ScalingMode	
Pathfinding.Graphs.Grid.Rules.RuleTexture.channelScales	ruletexture.html#channelScales	
Pathfinding.Graphs.Grid.Rules.RuleTexture.channels	ruletexture.html#channels	
Pathfinding.Graphs.Grid.Rules.RuleTexture.colors	ruletexture.html#colors	
Pathfinding.Graphs.Grid.Rules.RuleTexture.nodesPerPixel	ruletexture.html#nodesPerPixel	
Pathfinding.Graphs.Grid.Rules.RuleTexture.scalingMode	ruletexture.html#scalingMode	
Pathfinding.Graphs.Grid.Rules.RuleTexture.texture	ruletexture.html#texture	
Pathfinding.Graphs.Navmesh.CircleGeometryUtilities.circleRadiusAdjustmentFactors	circlegeometryutilities.html#circleRadiusAdjustmentFactors	Cached values for CircleRadiusAdjustmentFactor. \n\nWe can calculate the area of a polygonized circle, and equate that with the area of a unit circle <b>[code in online documentation]</b>\n\nGenerated using the python code: <b>[code in online documentation]</b>\n\nIt would be nice to generate this using a static constructor, but that is not supported by Unity's burst compiler.
Pathfinding.Graphs.Navmesh.ColliderMeshBuilder2D.ShapeMesh.bounds	shapemesh.html#bounds	
Pathfinding.Graphs.Navmesh.ColliderMeshBuilder2D.ShapeMesh.endIndex	shapemesh.html#endIndex	
Pathfinding.Graphs.Navmesh.ColliderMeshBuilder2D.ShapeMesh.matrix	shapemesh.html#matrix	
Pathfinding.Graphs.Navmesh.ColliderMeshBuilder2D.ShapeMesh.startIndex	shapemesh.html#startIndex	
Pathfinding.Graphs.Navmesh.ColliderMeshBuilder2D.ShapeMesh.tag	shapemesh.html#tag	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.BuildNodeTilesOutput.Progress	buildnodetilesoutput.html#Progress	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.BuildNodeTilesOutput.progressSource	buildnodetilesoutput.html#progressSource	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.BuildNodeTilesOutput.tiles	buildnodetilesoutput.html#tiles	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.graphIndex	jobbuildnodes.html#graphIndex	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.graphToWorldSpace	jobbuildnodes.html#graphToWorldSpace	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.initialPenalty	jobbuildnodes.html#initialPenalty	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.maxTileConnectionEdgeDistance	jobbuildnodes.html#maxTileConnectionEdgeDistance	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.recalculateNormals	jobbuildnodes.html#recalculateNormals	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildNodes.tileLayout	jobbuildnodes.html#tileLayout	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.JobTransformTileCoordinates.matrix	jobtransformtilecoordinates.html#matrix	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.JobTransformTileCoordinates.outputVertices	jobtransformtilecoordinates.html#outputVertices	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.JobTransformTileCoordinates.vertices	jobtransformtilecoordinates.html#vertices	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.indices	jobbuildtilemeshfromvertices.html#indices	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.meshToGraph	jobbuildtilemeshfromvertices.html#meshToGraph	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.outputBuffers	jobbuildtilemeshfromvertices.html#outputBuffers	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.recalculateNormals	jobbuildtilemeshfromvertices.html#recalculateNormals	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVertices.vertices	jobbuildtilemeshfromvertices.html#vertices	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerBuildCompactField	jobbuildtilemeshfromvoxels.html#MarkerBuildCompactField	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerBuildConnections	jobbuildtilemeshfromvoxels.html#MarkerBuildConnections	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerBuildContours	jobbuildtilemeshfromvoxels.html#MarkerBuildContours	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerBuildDistanceField	jobbuildtilemeshfromvoxels.html#MarkerBuildDistanceField	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerBuildMesh	jobbuildtilemeshfromvoxels.html#MarkerBuildMesh	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerBuildRegions	jobbuildtilemeshfromvoxels.html#MarkerBuildRegions	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerConvertAreasToTags	jobbuildtilemeshfromvoxels.html#MarkerConvertAreasToTags	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerErodeWalkableArea	jobbuildtilemeshfromvoxels.html#MarkerErodeWalkableArea	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerFilterLedges	jobbuildtilemeshfromvoxels.html#MarkerFilterLedges	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerFilterLowHeightSpans	jobbuildtilemeshfromvoxels.html#MarkerFilterLowHeightSpans	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerRemoveDuplicateVertices	jobbuildtilemeshfromvoxels.html#MarkerRemoveDuplicateVertices	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerTransformTileCoordinates	jobbuildtilemeshfromvoxels.html#MarkerTransformTileCoordinates	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.MarkerVoxelize	jobbuildtilemeshfromvoxels.html#MarkerVoxelize	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.backgroundTraversability	jobbuildtilemeshfromvoxels.html#backgroundTraversability	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.cellHeight	jobbuildtilemeshfromvoxels.html#cellHeight	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.cellSize	jobbuildtilemeshfromvoxels.html#cellSize	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.characterRadiusInVoxels	jobbuildtilemeshfromvoxels.html#characterRadiusInVoxels	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.contourMaxError	jobbuildtilemeshfromvoxels.html#contourMaxError	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.currentTileCounter	jobbuildtilemeshfromvoxels.html#currentTileCounter	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.dimensionMode	jobbuildtilemeshfromvoxels.html#dimensionMode	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.graphSpaceLimits	jobbuildtilemeshfromvoxels.html#graphSpaceLimits	Limits of the graph space bounds for the whole graph on the XZ plane. \n\nUsed to crop the border tiles to exactly the limits of the graph's bounding box.
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.graphToWorldSpace	jobbuildtilemeshfromvoxels.html#graphToWorldSpace	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.inputMeshes	jobbuildtilemeshfromvoxels.html#inputMeshes	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.maxEdgeLength	jobbuildtilemeshfromvoxels.html#maxEdgeLength	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.maxSlope	jobbuildtilemeshfromvoxels.html#maxSlope	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.maxTiles	jobbuildtilemeshfromvoxels.html#maxTiles	Max number of tiles to process in this job.
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.minRegionSize	jobbuildtilemeshfromvoxels.html#minRegionSize	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.outputMeshes	jobbuildtilemeshfromvoxels.html#outputMeshes	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.relevantGraphSurfaceMode	jobbuildtilemeshfromvoxels.html#relevantGraphSurfaceMode	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.relevantGraphSurfaces	jobbuildtilemeshfromvoxels.html#relevantGraphSurfaces	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.tileBorderSizeInVoxels	jobbuildtilemeshfromvoxels.html#tileBorderSizeInVoxels	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.tileBuilder	jobbuildtilemeshfromvoxels.html#tileBuilder	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.tileGraphSpaceBounds	jobbuildtilemeshfromvoxels.html#tileGraphSpaceBounds	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.voxelToTileSpace	jobbuildtilemeshfromvoxels.html#voxelToTileSpace	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.voxelWalkableClimb	jobbuildtilemeshfromvoxels.html#voxelWalkableClimb	
Pathfinding.Graphs.Navmesh.Jobs.JobBuildTileMeshFromVoxels.voxelWalkableHeight	jobbuildtilemeshfromvoxels.html#voxelWalkableHeight	
Pathfinding.Graphs.Navmesh.Jobs.JobCalculateTriangleConnections.TileNodeConnectionsUnsafe.neighbourCounts	tilenodeconnectionsunsafe.html#neighbourCounts	Number of neighbours for each triangle.
Pathfinding.Graphs.Navmesh.Jobs.JobCalculateTriangleConnections.TileNodeConnectionsUnsafe.neighbours	tilenodeconnectionsunsafe.html#neighbours	Stream of packed connection edge infos (from Connection.PackShapeEdgeInfo)
Pathfinding.Graphs.Navmesh.Jobs.JobCalculateTriangleConnections.nodeConnections	jobcalculatetriangleconnections.html#nodeConnections	
Pathfinding.Graphs.Navmesh.Jobs.JobCalculateTriangleConnections.tileMeshes	jobcalculatetriangleconnections.html#tileMeshes	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.ConnectTilesMarker	jobconnecttiles.html#ConnectTilesMarker	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.coordinateSum	jobconnecttiles.html#coordinateSum	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.direction	jobconnecttiles.html#direction	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.maxTileConnectionEdgeDistance	jobconnecttiles.html#maxTileConnectionEdgeDistance	Maximum vertical distance between two tiles to create a connection between them.
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.tileRect	jobconnecttiles.html#tileRect	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.tileWorldSize	jobconnecttiles.html#tileWorldSize	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.tiles	jobconnecttiles.html#tiles	GCHandle referring to a NavmeshTile[] array of size tileRect.Width*tileRect.Height.
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.zOffset	jobconnecttiles.html#zOffset	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTiles.zStride	jobconnecttiles.html#zStride	
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTilesSingle.maxTileConnectionEdgeDistance	jobconnecttilessingle.html#maxTileConnectionEdgeDistance	Maximum vertical distance between two tiles to create a connection between them.
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTilesSingle.tileIndex1	jobconnecttilessingle.html#tileIndex1	Index of the first tile in the tiles array.
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTilesSingle.tileIndex2	jobconnecttilessingle.html#tileIndex2	Index of the second tile in the tiles array.
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTilesSingle.tileWorldSize	jobconnecttilessingle.html#tileWorldSize	Size of a tile in world units.
Pathfinding.Graphs.Navmesh.Jobs.JobConnectTilesSingle.tiles	jobconnecttilessingle.html#tiles	GCHandle referring to a NavmeshTile[] array of size tileRect.Width*tileRect.Height.
Pathfinding.Graphs.Navmesh.Jobs.JobConvertAreasToTags.areas	jobconvertareastotags.html#areas	
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.graphIndex	jobcreatetiles.html#graphIndex	Graph index of the graph that these nodes will be added to.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.graphTileCount	jobcreatetiles.html#graphTileCount	Number of tiles in the graph. \n\nThis may be much bigger than the tileRect that we are actually processing. For example if a graph update is performed, the tileRect will just cover the tiles that are recalculated, while graphTileCount will contain all tiles in the graph.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.graphToWorldSpace	jobcreatetiles.html#graphToWorldSpace	Matrix to convert from graph space to world space.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.initialPenalty	jobcreatetiles.html#initialPenalty	Initial penalty for all nodes in the tile.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.preCutTileMeshes	jobcreatetiles.html#preCutTileMeshes	An array of TileMesh.TileMeshUnsafe of length tileRect.Width*tileRect.Height, or an uninitialized array.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.recalculateNormals	jobcreatetiles.html#recalculateNormals	If true, all triangles will be guaranteed to be laid out in clockwise order. \n\nIf false, their original order will be preserved.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.tileMeshes	jobcreatetiles.html#tileMeshes	An array of TileMesh.TileMeshUnsafe of length tileRect.Width*tileRect.Height.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.tileRect	jobcreatetiles.html#tileRect	Rectangle of tiles that we are processing. \n\n(xmax, ymax) must be smaller than graphTileCount. If for examples graphTileCount is (10, 10) and tileRect is {2, 3, 5, 6} then we are processing tiles (2, 3) to (5, 6) inclusive.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.tileWorldSize	jobcreatetiles.html#tileWorldSize	Size of a tile in world units along the graph's X and Z axes.
Pathfinding.Graphs.Navmesh.Jobs.JobCreateTiles.tiles	jobcreatetiles.html#tiles	An array of NavmeshTile of length tileRect.Width*tileRect.Height. \n\nThis array will be filled with the created tiles.
Pathfinding.Graphs.Navmesh.Jobs.JobTransformTileCoordinates.matrix	jobtransformtilecoordinates2.html#matrix	
Pathfinding.Graphs.Navmesh.Jobs.JobTransformTileCoordinates.vertices	jobtransformtilecoordinates2.html#vertices	
Pathfinding.Graphs.Navmesh.Jobs.JobWriteNodeConnections.nodeConnections	jobwritenodeconnections.html#nodeConnections	Connections for each tile.
Pathfinding.Graphs.Navmesh.Jobs.JobWriteNodeConnections.tiles	jobwritenodeconnections.html#tiles	Array of NavmeshTile.
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.compactVoxelField	tilebuilderburst.html#compactVoxelField	
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.contourVertices	tilebuilderburst.html#contourVertices	
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.contours	tilebuilderburst.html#contours	
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.distanceField	tilebuilderburst.html#distanceField	
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.linkedVoxelField	tilebuilderburst.html#linkedVoxelField	
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.tmpQueue1	tilebuilderburst.html#tmpQueue1	
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.tmpQueue2	tilebuilderburst.html#tmpQueue2	
Pathfinding.Graphs.Navmesh.Jobs.TileBuilderBurst.voxelMesh	tilebuilderburst.html#voxelMesh	
Pathfinding.Graphs.Navmesh.NavmeshTile.bbTree	navmeshtile.html#bbTree	Bounding Box Tree for node lookups.
Pathfinding.Graphs.Navmesh.NavmeshTile.d	navmeshtile.html#d	Depth, in tile coordinates. \n\n[more in online documentation]
Pathfinding.Graphs.Navmesh.NavmeshTile.flag	navmeshtile.html#flag	Temporary flag used for batching.
Pathfinding.Graphs.Navmesh.NavmeshTile.graph	navmeshtile.html#graph	The graph which contains this tile.
Pathfinding.Graphs.Navmesh.NavmeshTile.isCut	navmeshtile.html#isCut	True if this tile may have been cut by NavmeshCuts, or had pieces added by  NavmeshAdd components. \n\nIf true, the preCutVertsInTileSpace, preCutTris and preCutTags fields will be valid.
Pathfinding.Graphs.Navmesh.NavmeshTile.nodes	navmeshtile.html#nodes	All nodes in the tile.
Pathfinding.Graphs.Navmesh.NavmeshTile.preCutTags	navmeshtile.html#preCutTags	
Pathfinding.Graphs.Navmesh.NavmeshTile.preCutTris	navmeshtile.html#preCutTris	
Pathfinding.Graphs.Navmesh.NavmeshTile.preCutVertsInTileSpace	navmeshtile.html#preCutVertsInTileSpace	
Pathfinding.Graphs.Navmesh.NavmeshTile.transform	navmeshtile.html#transform	Transforms coordinates from graph space to world space.
Pathfinding.Graphs.Navmesh.NavmeshTile.tris	navmeshtile.html#tris	All triangle indices in the tile. \n\nOne triangle is 3 indices. The triangles are in the same order as the nodes.\n\nThis represents an allocation using the Persistent allocator.
Pathfinding.Graphs.Navmesh.NavmeshTile.verts	navmeshtile.html#verts	All vertices in the tile. \n\nThe vertices are in world space.\n\nThis represents an allocation using the Persistent allocator.
Pathfinding.Graphs.Navmesh.NavmeshTile.vertsInGraphSpace	navmeshtile.html#vertsInGraphSpace	All vertices in the tile. \n\nThe vertices are in graph space.\n\nThis represents an allocation using the Persistent allocator.
Pathfinding.Graphs.Navmesh.NavmeshTile.w	navmeshtile.html#w	Width, in tile coordinates. \n\n[more in online documentation]
Pathfinding.Graphs.Navmesh.NavmeshTile.x	navmeshtile.html#x	Tile X Coordinate.
Pathfinding.Graphs.Navmesh.NavmeshTile.z	navmeshtile.html#z	Tile Z Coordinate.
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.anyTilesDirty	navmeshupdatesettings.html#anyTilesDirty	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.attachedToGraph	navmeshupdatesettings.html#attachedToGraph	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.clipperLookup	navmeshupdatesettings.html#clipperLookup	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.dirtyTileCoordinates	navmeshupdatesettings.html#dirtyTileCoordinates	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.dirtyTiles	navmeshupdatesettings.html#dirtyTiles	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.enabled	navmeshupdatesettings.html#enabled	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.graph	navmeshupdatesettings.html#graph	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.NavmeshUpdateSettings.tileLayout	navmeshupdatesettings.html#tileLayout	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.astar	navmeshupdates.html#astar	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.lastUpdateTime	navmeshupdates.html#lastUpdateTime	Last time navmesh cuts were applied.
Pathfinding.Graphs.Navmesh.NavmeshUpdates.listeners	navmeshupdates.html#listeners	
Pathfinding.Graphs.Navmesh.NavmeshUpdates.updateInterval	navmeshupdates.html#updateInterval	How often to check if an update needs to be done (real seconds between checks). \n\nFor worlds with a very large number of NavmeshCut objects, it might be bad for performance to do this check every frame. If you think this is a performance penalty, increase this number to check less often.\n\nFor almost all games, this can be kept at 0.\n\nIf negative, no updates will be done. They must be manually triggered using ForceUpdate.\n\n<b>[code in online documentation]</b><b>[image in online documentation]</b>
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.BoxColliderTris	recastmeshgatherer.html#BoxColliderTris	Box Collider triangle indices can be reused for multiple instances. \n\n[more in online documentation]
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.BoxColliderVerts	recastmeshgatherer.html#BoxColliderVerts	Box Collider vertices can be reused for multiple instances. \n\n[more in online documentation]
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.area	gatheredmesh.html#area	Area ID of the mesh. \n\n0 means walkable, and -1 indicates that the mesh should be treated as unwalkable. Other positive values indicate a custom area ID which will create a seam in the navmesh.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.areaIsTag	gatheredmesh.html#areaIsTag	See RasterizationMesh.areaIsTag.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.bounds	gatheredmesh.html#bounds	World bounds of the mesh. \n\nAssumed to already be multiplied with the matrix.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.doubleSided	gatheredmesh.html#doubleSided	See RasterizationMesh.doubleSided.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.flatten	gatheredmesh.html#flatten	See RasterizationMesh.flatten.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.indexEnd	gatheredmesh.html#indexEnd	End index in the triangle array. \n\n-1 indicates the end of the array.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.indexStart	gatheredmesh.html#indexStart	Start index in the triangle array.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.matrix	gatheredmesh.html#matrix	Matrix to transform the vertices by.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.meshDataIndex	gatheredmesh.html#meshDataIndex	Index in the meshData array. \n\nCan be retrieved from the RecastMeshGatherer.AddMeshBuffers method.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.GatheredMesh.solid	gatheredmesh.html#solid	If true then the mesh will be treated as solid and its interior will be unwalkable. \n\nThe unwalkable region will be the minimum to maximum y coordinate in each cell.
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCacheItem.Box	meshcacheitem.html#Box	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCacheItem.mesh	meshcacheitem.html#mesh	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCacheItem.quantizedHeight	meshcacheitem.html#quantizedHeight	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCacheItem.rows	meshcacheitem.html#rows	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCacheItem.type	meshcacheitem.html#type	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCollection.meshes	meshcollection.html#meshes	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCollection.meshesUnreadableAtRuntime	meshcollection.html#meshesUnreadableAtRuntime	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCollection.triangleBuffers	meshcollection.html#triangleBuffers	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshCollection.vertexBuffers	meshcollection.html#vertexBuffers	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.MeshType	recastmeshgatherer.html#MeshType	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.TreeInfo.localScale	treeinfo.html#localScale	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.TreeInfo.submeshes	treeinfo.html#submeshes	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.TreeInfo.supportsRotation	treeinfo.html#supportsRotation	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.bounds	recastmeshgatherer.html#bounds	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.cachedMeshes	recastmeshgatherer.html#cachedMeshes	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.cachedTreePrefabs	recastmeshgatherer.html#cachedTreePrefabs	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.dummyMaterials	recastmeshgatherer.html#dummyMaterials	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.mask	recastmeshgatherer.html#mask	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.maxColliderApproximationError	recastmeshgatherer.html#maxColliderApproximationError	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.meshData	recastmeshgatherer.html#meshData	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.meshes	recastmeshgatherer.html#meshes	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.meshesUnreadableAtRuntime	recastmeshgatherer.html#meshesUnreadableAtRuntime	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.modificationsByLayer	recastmeshgatherer.html#modificationsByLayer	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.modificationsByLayer2D	recastmeshgatherer.html#modificationsByLayer2D	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.physicsScene	recastmeshgatherer.html#physicsScene	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.physicsScene2D	recastmeshgatherer.html#physicsScene2D	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.tagMask	recastmeshgatherer.html#tagMask	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.terrainDownsamplingFactor	recastmeshgatherer.html#terrainDownsamplingFactor	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.triangleBuffers	recastmeshgatherer.html#triangleBuffers	
Pathfinding.Graphs.Navmesh.RecastMeshGatherer.vertexBuffers	recastmeshgatherer.html#vertexBuffers	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.Next	relevantgraphsurface.html#Next	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.Position	relevantgraphsurface.html#Position	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.Prev	relevantgraphsurface.html#Prev	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.Root	relevantgraphsurface.html#Root	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.maxRange	relevantgraphsurface.html#maxRange	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.next	relevantgraphsurface.html#next	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.position	relevantgraphsurface.html#position	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.prev	relevantgraphsurface.html#prev	
Pathfinding.Graphs.Navmesh.RelevantGraphSurface.root	relevantgraphsurface.html#root	
Pathfinding.Graphs.Navmesh.TileBuilder.BucketMapping.bucketRanges	bucketmapping.html#bucketRanges	For each tile, the range of pointers in pointers that correspond to that tile. \n\nThis is a cumulative sum of the number of pointers in each bucket.\n\nBucket <b>i</b> will contain pointers in the range [i &gt; 0 ? bucketRanges[i-1] : 0, bucketRanges[i]).\n\nThe length is the same as the number of tiles.
Pathfinding.Graphs.Navmesh.TileBuilder.BucketMapping.meshes	bucketmapping.html#meshes	All meshes that should be voxelized.
Pathfinding.Graphs.Navmesh.TileBuilder.BucketMapping.pointers	bucketmapping.html#pointers	Indices into the meshes array.
Pathfinding.Graphs.Navmesh.TileBuilder.TileBorderSizeInVoxels	tilebuilder.html#TileBorderSizeInVoxels	Number of extra voxels on each side of a tile to ensure accurate navmeshes near the tile border. \n\nThe width of a tile is expanded by 2 times this value (1x to the left and 1x to the right)
Pathfinding.Graphs.Navmesh.TileBuilder.TileBorderSizeInWorldUnits	tilebuilder.html#TileBorderSizeInWorldUnits	
Pathfinding.Graphs.Navmesh.TileBuilder.TileBuilderOutput.Progress	tilebuilderoutput.html#Progress	
Pathfinding.Graphs.Navmesh.TileBuilder.TileBuilderOutput.currentTileCounter	tilebuilderoutput.html#currentTileCounter	
Pathfinding.Graphs.Navmesh.TileBuilder.TileBuilderOutput.meshesUnreadableAtRuntime	tilebuilderoutput.html#meshesUnreadableAtRuntime	
Pathfinding.Graphs.Navmesh.TileBuilder.TileBuilderOutput.tileMeshes	tilebuilderoutput.html#tileMeshes	
Pathfinding.Graphs.Navmesh.TileBuilder.backgroundTraversability	tilebuilder.html#backgroundTraversability	
Pathfinding.Graphs.Navmesh.TileBuilder.characterRadiusInVoxels	tilebuilder.html#characterRadiusInVoxels	
Pathfinding.Graphs.Navmesh.TileBuilder.collectionSettings	tilebuilder.html#collectionSettings	
Pathfinding.Graphs.Navmesh.TileBuilder.contourMaxError	tilebuilder.html#contourMaxError	
Pathfinding.Graphs.Navmesh.TileBuilder.dimensionMode	tilebuilder.html#dimensionMode	
Pathfinding.Graphs.Navmesh.TileBuilder.maxEdgeLength	tilebuilder.html#maxEdgeLength	
Pathfinding.Graphs.Navmesh.TileBuilder.maxSlope	tilebuilder.html#maxSlope	
Pathfinding.Graphs.Navmesh.TileBuilder.minRegionSize	tilebuilder.html#minRegionSize	
Pathfinding.Graphs.Navmesh.TileBuilder.perLayerModifications	tilebuilder.html#perLayerModifications	
Pathfinding.Graphs.Navmesh.TileBuilder.relevantGraphSurfaceMode	tilebuilder.html#relevantGraphSurfaceMode	
Pathfinding.Graphs.Navmesh.TileBuilder.tileBorderSizeInVoxels	tilebuilder.html#tileBorderSizeInVoxels	
Pathfinding.Graphs.Navmesh.TileBuilder.tileLayout	tilebuilder.html#tileLayout	
Pathfinding.Graphs.Navmesh.TileBuilder.tileRect	tilebuilder.html#tileRect	
Pathfinding.Graphs.Navmesh.TileBuilder.walkableClimb	tilebuilder.html#walkableClimb	
Pathfinding.Graphs.Navmesh.TileBuilder.walkableHeight	tilebuilder.html#walkableHeight	
Pathfinding.Graphs.Navmesh.TileCutter.JobCutTiles.cutCollection	jobcuttiles.html#cutCollection	
Pathfinding.Graphs.Navmesh.TileCutter.JobCutTiles.inputTileMeshes	jobcuttiles.html#inputTileMeshes	
Pathfinding.Graphs.Navmesh.TileCutter.JobCutTiles.outputTileMeshes	jobcuttiles.html#outputTileMeshes	
Pathfinding.Graphs.Navmesh.TileCutter.JobCutTiles.tileTags	jobcuttiles.html#tileTags	
Pathfinding.Graphs.Navmesh.TileCutter.JobCutTiles.tileTriangles	jobcuttiles.html#tileTriangles	
Pathfinding.Graphs.Navmesh.TileCutter.JobCutTiles.tileVertices	jobcuttiles.html#tileVertices	
Pathfinding.Graphs.Navmesh.TileCutter.TileCutterOutput.Progress	tilecutteroutput.html#Progress	
Pathfinding.Graphs.Navmesh.TileCutter.TileCutterOutput.tileMeshes	tilecutteroutput.html#tileMeshes	
Pathfinding.Graphs.Navmesh.TileCutter.cuts	tilecutter.html#cuts	
Pathfinding.Graphs.Navmesh.TileCutter.graph	tilecutter.html#graph	
Pathfinding.Graphs.Navmesh.TileCutter.tileLayout	tilecutter.html#tileLayout	
Pathfinding.Graphs.Navmesh.TileHandler.ContourMeta.cutsAddedGeom	contourmeta.html#cutsAddedGeom	
Pathfinding.Graphs.Navmesh.TileHandler.ContourMeta.isDual	contourmeta.html#isDual	
Pathfinding.Graphs.Navmesh.TileHandler.CopyTriangulationToOutputMarker	tilehandler.html#CopyTriangulationToOutputMarker	
Pathfinding.Graphs.Navmesh.TileHandler.CutCollection.contourVertices	cutcollection.html#contourVertices	Vertices of all cut contours in all tiles Stored in tile space for the tile they belong to.
Pathfinding.Graphs.Navmesh.TileHandler.CutCollection.contours	cutcollection.html#contours	
Pathfinding.Graphs.Navmesh.TileHandler.CutCollection.contoursExtra	cutcollection.html#contoursExtra	
Pathfinding.Graphs.Navmesh.TileHandler.CutCollection.cuttingRequired	cutcollection.html#cuttingRequired	
Pathfinding.Graphs.Navmesh.TileHandler.CutCollection.tileCuts	cutcollection.html#tileCuts	
Pathfinding.Graphs.Navmesh.TileHandler.CutFunctionPtr	tilehandler.html#CutFunctionPtr	
Pathfinding.Graphs.Navmesh.TileHandler.DelegateGCRoot	tilehandler.html#DelegateGCRoot	
Pathfinding.Graphs.Navmesh.TileHandler.EdgeSnappingMaxDistance	tilehandler.html#EdgeSnappingMaxDistance	See SnapEdges.
Pathfinding.Graphs.Navmesh.TileHandler.MarkerAllocate	tilehandler.html#MarkerAllocate	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerClipHorizontal	tilehandler.html#MarkerClipHorizontal	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerClipping	tilehandler.html#MarkerClipping	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerCompress	tilehandler.html#MarkerCompress	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerCopyClippingResult	tilehandler.html#MarkerCopyClippingResult	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerCore	tilehandler.html#MarkerCore	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerEdgeSnapping	tilehandler.html#MarkerEdgeSnapping	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerPrepare	tilehandler.html#MarkerPrepare	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerRefine	tilehandler.html#MarkerRefine	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerRemoveDegenerateLines	tilehandler.html#MarkerRemoveDegenerateLines	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerRemoveDegenerateTriangles	tilehandler.html#MarkerRemoveDegenerateTriangles	
Pathfinding.Graphs.Navmesh.TileHandler.MarkerTriangulate	tilehandler.html#MarkerTriangulate	
Pathfinding.Graphs.Navmesh.TileHandler.Point64Wrapper.x	point64wrapper.html#x	
Pathfinding.Graphs.Navmesh.TileHandler.Point64Wrapper.y	point64wrapper.html#y	
Pathfinding.Graphs.Navmesh.TileHandler.Scale	tilehandler.html#Scale	Scale all coordinates by this value to make intersection calculations more accurate, while clipping. \n\nWhen an intersection is calculated during clipping, it has to be rounded to the nearest integer coordinate. If this intersection is then used to calculate another intersection, the error will accumulate. By scaling up the coordinates, and dividing all coordinates after all clipping is finished, the error is reduced.\n\nThis should be a power of two, for best performance. It should not be too large, as then large coordinates can cause overflows in various calculations.\n\nTo disable, set to 1. But this is not recommended.
Pathfinding.Graphs.Navmesh.TileHandler.TileCuts.contourEndIndex	tilecuts.html#contourEndIndex	
Pathfinding.Graphs.Navmesh.TileHandler.TileCuts.contourStartIndex	tilecuts.html#contourStartIndex	
Pathfinding.Graphs.Navmesh.TileHandler.TileSnappingMaxDistance	tilehandler.html#TileSnappingMaxDistance	See ConvertVerticesAndSnapToTileBoundaries. \n\nThe navmesh cut vertices are snapped to tile borders, if they are within this distance to the edge. This is used to avoid tiiiny slivers of triangles resulting from cuts that are just infringing on a tile. The normal snapping (using EdgeSnappingMaxDistance) cannot be used for tile borders, because that would make the tile borders not be straight anymore.\n\nI don't think there's any technical upper limit to this value. It's a tradeoff between the size of the slivers, and how accurately it matches the original geometry.
Pathfinding.Graphs.Navmesh.TileHandlerCache.cachedClippers	tilehandlercache.html#cachedClippers	
Pathfinding.Graphs.Navmesh.TileLayout.CellHeight	tilelayout.html#CellHeight	Voxel y coordinates will be stored as ushorts which have 65536 values. \n\nLeave a margin to make sure things do not overflow
Pathfinding.Graphs.Navmesh.TileLayout.TileWorldSize	tilelayout.html#TileWorldSize	
Pathfinding.Graphs.Navmesh.TileLayout.TileWorldSizeX	tilelayout.html#TileWorldSizeX	Size of a tile in world units, along the graph's X axis.
Pathfinding.Graphs.Navmesh.TileLayout.TileWorldSizeZ	tilelayout.html#TileWorldSizeZ	Size of a tile in world units, along the graph's Z axis.
Pathfinding.Graphs.Navmesh.TileLayout.cellSize	tilelayout.html#cellSize	Voxel sample size (x,z). \n\nWhen generating a recast graph what happens is that the world is voxelized. You can think of this as constructing an approximation of the world out of lots of boxes. If you have played Minecraft it looks very similar (but with smaller boxes).  <b>[image in online documentation]</b>\n\nLower values will yield higher quality navmeshes, however the graph will be slower to scan.\n\n <b>[image in online documentation]</b>
Pathfinding.Graphs.Navmesh.TileLayout.graphSpaceSize	tilelayout.html#graphSpaceSize	Size in graph space of the whole grid. \n\nIf the original bounding box was not an exact multiple of the tile size, this will be less than the total width of all tiles.
Pathfinding.Graphs.Navmesh.TileLayout.tileCount	tilelayout.html#tileCount	How many tiles there are in the grid.
Pathfinding.Graphs.Navmesh.TileLayout.tileSizeInVoxels	tilelayout.html#tileSizeInVoxels	Size of a tile in voxels along the X and Z axes.
Pathfinding.Graphs.Navmesh.TileLayout.transform	tilelayout.html#transform	Transforms coordinates from graph space to world space.
Pathfinding.Graphs.Navmesh.TileMesh.TileMeshUnsafe.tags	tilemeshunsafe.html#tags	One tag per triangle.
Pathfinding.Graphs.Navmesh.TileMesh.TileMeshUnsafe.triangles	tilemeshunsafe.html#triangles	Three indices per triangle.
Pathfinding.Graphs.Navmesh.TileMesh.TileMeshUnsafe.verticesInTileSpace	tilemeshunsafe.html#verticesInTileSpace	One vertex per triangle.
Pathfinding.Graphs.Navmesh.TileMesh.tags	tilemesh.html#tags	One tag per triangle.
Pathfinding.Graphs.Navmesh.TileMesh.triangles	tilemesh.html#triangles	
Pathfinding.Graphs.Navmesh.TileMesh.verticesInTileSpace	tilemesh.html#verticesInTileSpace	
Pathfinding.Graphs.Navmesh.TileMeshes.tileMeshes	tilemeshes.html#tileMeshes	Tiles laid out row by row.
Pathfinding.Graphs.Navmesh.TileMeshes.tileRect	tilemeshes.html#tileRect	Which tiles in the graph this group of tiles represents.
Pathfinding.Graphs.Navmesh.TileMeshes.tileWorldSize	tilemeshes.html#tileWorldSize	World-space size of each tile.
Pathfinding.Graphs.Navmesh.TileMeshesUnsafe.tileMeshes	tilemeshesunsafe.html#tileMeshes	
Pathfinding.Graphs.Navmesh.TileMeshesUnsafe.tileRect	tilemeshesunsafe.html#tileRect	
Pathfinding.Graphs.Navmesh.TileMeshesUnsafe.tileWorldSize	tilemeshesunsafe.html#tileWorldSize	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CellMinMax.max	cellminmax.html#max	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CellMinMax.min	cellminmax.html#min	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CellMinMax.objectID	cellminmax.html#objectID	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelCell.count	compactvoxelcell.html#count	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelCell.index	compactvoxelcell.html#index	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.MaxLayers	compactvoxelfield.html#MaxLayers	Unmotivated variable, but let's clamp the layers at 65535.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.NotConnected	compactvoxelfield.html#NotConnected	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.UnwalkableArea	compactvoxelfield.html#UnwalkableArea	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.areaTypes	compactvoxelfield.html#areaTypes	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.cells	compactvoxelfield.html#cells	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.depth	compactvoxelfield.html#depth	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.spans	compactvoxelfield.html#spans	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.voxelWalkableHeight	compactvoxelfield.html#voxelWalkableHeight	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelField.width	compactvoxelfield.html#width	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelSpan.con	compactvoxelspan.html#con	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelSpan.h	compactvoxelspan.html#h	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelSpan.reg	compactvoxelspan.html#reg	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.CompactVoxelSpan.y	compactvoxelspan.html#y	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildCompactField.input	jobbuildcompactfield.html#input	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildCompactField.output	jobbuildcompactfield.html#output	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildConnections.field	jobbuildconnections.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildConnections.voxelWalkableClimb	jobbuildconnections.html#voxelWalkableClimb	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildConnections.voxelWalkableHeight	jobbuildconnections.html#voxelWalkableHeight	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildContours.buildFlags	jobbuildcontours.html#buildFlags	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildContours.cellSize	jobbuildcontours.html#cellSize	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildContours.field	jobbuildcontours.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildContours.maxEdgeLength	jobbuildcontours.html#maxEdgeLength	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildContours.maxError	jobbuildcontours.html#maxError	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildContours.outputContours	jobbuildcontours.html#outputContours	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildContours.outputVerts	jobbuildcontours.html#outputVerts	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildDistanceField.field	jobbuilddistancefield.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildDistanceField.output	jobbuilddistancefield.html#output	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildMesh.contourVertices	jobbuildmesh.html#contourVertices	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildMesh.contours	jobbuildmesh.html#contours	contour set to build a mesh from.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildMesh.field	jobbuildmesh.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildMesh.mesh	jobbuildmesh.html#mesh	Results will be written to this mesh.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.RelevantGraphSurfaceInfo.position	relevantgraphsurfaceinfo.html#position	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.RelevantGraphSurfaceInfo.range	relevantgraphsurfaceinfo.html#range	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.borderSize	jobbuildregions.html#borderSize	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.cellHeight	jobbuildregions.html#cellHeight	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.cellSize	jobbuildregions.html#cellSize	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.distanceField	jobbuildregions.html#distanceField	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.dstQue	jobbuildregions.html#dstQue	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.field	jobbuildregions.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.graphSpaceBounds	jobbuildregions.html#graphSpaceBounds	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.graphTransform	jobbuildregions.html#graphTransform	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.minRegionSize	jobbuildregions.html#minRegionSize	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.relevantGraphSurfaceMode	jobbuildregions.html#relevantGraphSurfaceMode	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.relevantGraphSurfaces	jobbuildregions.html#relevantGraphSurfaces	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobBuildRegions.srcQue	jobbuildregions.html#srcQue	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobErodeWalkableArea.field	joberodewalkablearea.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobErodeWalkableArea.radius	joberodewalkablearea.html#radius	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobFilterLedges.cellHeight	jobfilterledges.html#cellHeight	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobFilterLedges.cellSize	jobfilterledges.html#cellSize	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobFilterLedges.field	jobfilterledges.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobFilterLedges.voxelWalkableClimb	jobfilterledges.html#voxelWalkableClimb	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobFilterLedges.voxelWalkableHeight	jobfilterledges.html#voxelWalkableHeight	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobFilterLowHeightSpans.field	jobfilterlowheightspans.html#field	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobFilterLowHeightSpans.voxelWalkableHeight	jobfilterlowheightspans.html#voxelWalkableHeight	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.bucket	jobvoxelize.html#bucket	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.cellHeight	jobvoxelize.html#cellHeight	The y-axis cell size to use for fields. \n\n[Limit: &gt; 0] [Units: wu]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.cellSize	jobvoxelize.html#cellSize	The xz-plane cell size to use for fields. \n\n[Limit: &gt; 0] [Units: wu]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.graphSpaceBounds	jobvoxelize.html#graphSpaceBounds	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.graphSpaceLimits	jobvoxelize.html#graphSpaceLimits	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.graphTransform	jobvoxelize.html#graphTransform	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.inputMeshes	jobvoxelize.html#inputMeshes	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.maxSlope	jobvoxelize.html#maxSlope	The maximum slope that is considered walkable. \n\n[Limits: 0 &lt;= value &lt; 90] [Units: Degrees]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.voxelArea	jobvoxelize.html#voxelArea	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.voxelWalkableClimb	jobvoxelize.html#voxelWalkableClimb	Maximum ledge height that is considered to still be traversable. \n\n[Limit: &gt;=0] [Units: vx]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.JobVoxelize.voxelWalkableHeight	jobvoxelize.html#voxelWalkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area to be considered walkable. \n\n[Limit: &gt;= 3] [Units: vx]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.AvgSpanLayerCountEstimate	linkedvoxelfield.html#AvgSpanLayerCountEstimate	Initial estimate on the average number of spans (layers) in the voxel representation. \n\nShould be greater or equal to 1
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.InvalidSpanValue	linkedvoxelfield.html#InvalidSpanValue	Constant for default LinkedVoxelSpan top and bottom values. \n\nIt is important with the U since ~0 != ~0U This can be used to check if a LinkedVoxelSpan is valid and not just the default span
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.MaxHeight	linkedvoxelfield.html#MaxHeight	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.MaxHeightInt	linkedvoxelfield.html#MaxHeightInt	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.depth	linkedvoxelfield.html#depth	The depth of the field along the z-axis. \n\n[Limit: &gt;= 0] [Units: voxels]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.flatten	linkedvoxelfield.html#flatten	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.height	linkedvoxelfield.html#height	The maximum height coordinate. \n\n[Limit: &gt;= 0, &lt;= MaxHeight] [Units: voxels]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.linkedCellMinMax	linkedvoxelfield.html#linkedCellMinMax	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.linkedSpans	linkedvoxelfield.html#linkedSpans	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.removedStack	linkedvoxelfield.html#removedStack	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelField.width	linkedvoxelfield.html#width	The width of the field along the x-axis. \n\n[Limit: &gt;= 0] [Units: voxels]
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelSpan.area	linkedvoxelspan.html#area	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelSpan.bottom	linkedvoxelspan.html#bottom	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelSpan.next	linkedvoxelspan.html#next	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.LinkedVoxelSpan.top	linkedvoxelspan.html#top	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.area	rasterizationmesh.html#area	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.areaIsTag	rasterizationmesh.html#areaIsTag	If true, the area will be interpreted as a node tag and applied to the final nodes.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.bounds	rasterizationmesh.html#bounds	World bounds of the mesh. \n\nAssumed to already be multiplied with the matrix
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.doubleSided	rasterizationmesh.html#doubleSided	If true, both sides of the mesh will be walkable. \n\nIf false, only the side that the normal points towards will be walkable
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.flatten	rasterizationmesh.html#flatten	If true, the mesh will be flattened to the base of the graph during rasterization. \n\nThis is intended for rasterizing 2D meshes which always lie in a single plane.\n\nThis will also cause unwalkable spans have precedence over walkable ones at all times, instead of only when the unwalkable span is sufficiently high up over a walkable span. Since when flattening, "sufficiently high up" makes no sense.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.matrix	rasterizationmesh.html#matrix	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.solid	rasterizationmesh.html#solid	If true then the mesh will be treated as solid and its interior will be unwalkable. \n\nThe unwalkable region will be the minimum to maximum y coordinate in each cell.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.triangles	rasterizationmesh.html#triangles	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.RasterizationMesh.vertices	rasterizationmesh.html#vertices	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelContour.area	voxelcontour.html#area	Area ID of the contour.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelContour.nverts	voxelcontour.html#nverts	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelContour.reg	voxelcontour.html#reg	Region ID of the contour.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelContour.vertexStartIndex	voxelcontour.html#vertexStartIndex	Vertex coordinates, each vertex contains 4 components.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelMesh.areas	voxelmesh.html#areas	Area index for each triangle.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelMesh.tris	voxelmesh.html#tris	Triangles of the mesh. \n\nEach element points to a vertex in the verts array
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelMesh.verts	voxelmesh.html#verts	Vertices of the mesh.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.BorderReg	voxelutilityburst.html#BorderReg	If heightfield region ID has the following bit set, the region is on border area and excluded from many calculations.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.ContourRegMask	voxelutilityburst.html#ContourRegMask	Mask used with contours to extract region id.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.DX	voxelutilityburst.html#DX	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.DZ	voxelutilityburst.html#DZ	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.RC_AREA_BORDER	voxelutilityburst.html#RC_AREA_BORDER	
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.RC_BORDER_VERTEX	voxelutilityburst.html#RC_BORDER_VERTEX	If contour region ID has the following bit set, the vertex will be later removed in order to match the segments and vertices at tile boundaries.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.RC_CONTOUR_TESS_AREA_EDGES	voxelutilityburst.html#RC_CONTOUR_TESS_AREA_EDGES	Tessellate edges between areas.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.RC_CONTOUR_TESS_TILE_EDGES	voxelutilityburst.html#RC_CONTOUR_TESS_TILE_EDGES	Tessellate edges at the border of the tile.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.RC_CONTOUR_TESS_WALL_EDGES	voxelutilityburst.html#RC_CONTOUR_TESS_WALL_EDGES	Tessellate wall edges.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.TagReg	voxelutilityburst.html#TagReg	If a cell region has this bit set then The remaining region bits (see TagRegMask) will be used for the node's tag.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.TagRegMask	voxelutilityburst.html#TagRegMask	All bits in the region which will be interpreted as a tag.
Pathfinding.Graphs.Navmesh.Voxelization.Burst.VoxelUtilityBurst.VERTEX_BUCKET_COUNT	voxelutilityburst.html#VERTEX_BUCKET_COUNT	
Pathfinding.Graphs.Navmesh.Voxelization.Int3PolygonClipper.clipPolygonCache	int3polygonclipper.html#clipPolygonCache	
Pathfinding.Graphs.Navmesh.Voxelization.VoxelPolygonClipper.n	voxelpolygonclipper.html#n	
Pathfinding.Graphs.Navmesh.Voxelization.VoxelPolygonClipper.this[int i]	voxelpolygonclipper.html#thisinti	
Pathfinding.Graphs.Navmesh.Voxelization.VoxelPolygonClipper.x	voxelpolygonclipper.html#x	
Pathfinding.Graphs.Navmesh.Voxelization.VoxelPolygonClipper.y	voxelpolygonclipper.html#y	
Pathfinding.Graphs.Navmesh.Voxelization.VoxelPolygonClipper.z	voxelpolygonclipper.html#z	
Pathfinding.Graphs.Util.EuclideanEmbedding.EuclideanEmbeddingSearchPath.costIndexStride	euclideanembeddingsearchpath.html#costIndexStride	
Pathfinding.Graphs.Util.EuclideanEmbedding.EuclideanEmbeddingSearchPath.costs	euclideanembeddingsearchpath.html#costs	
Pathfinding.Graphs.Util.EuclideanEmbedding.EuclideanEmbeddingSearchPath.furthestNode	euclideanembeddingsearchpath.html#furthestNode	
Pathfinding.Graphs.Util.EuclideanEmbedding.EuclideanEmbeddingSearchPath.furthestNodeScore	euclideanembeddingsearchpath.html#furthestNodeScore	
Pathfinding.Graphs.Util.EuclideanEmbedding.EuclideanEmbeddingSearchPath.pivotIndex	euclideanembeddingsearchpath.html#pivotIndex	
Pathfinding.Graphs.Util.EuclideanEmbedding.EuclideanEmbeddingSearchPath.startNode	euclideanembeddingsearchpath.html#startNode	
Pathfinding.Graphs.Util.EuclideanEmbedding.costs	euclideanembedding.html#costs	Costs laid out as n*[int],n*[int],n*[int] where n is the number of pivot points. \n\nEach node has n integers which is the cost from that node to the pivot node. They are at around the same place in the array for simplicity and for cache locality.\n\ncost(nodeIndex, pivotIndex) = costs[nodeIndex*pivotCount+pivotIndex]
Pathfinding.Graphs.Util.EuclideanEmbedding.dirty	euclideanembedding.html#dirty	
Pathfinding.Graphs.Util.EuclideanEmbedding.mode	euclideanembedding.html#mode	If heuristic optimization should be used and how to place the pivot points. \n\n[more in online documentation]
Pathfinding.Graphs.Util.EuclideanEmbedding.pivotCount	euclideanembedding.html#pivotCount	
Pathfinding.Graphs.Util.EuclideanEmbedding.pivotPointRoot	euclideanembedding.html#pivotPointRoot	All children of this transform will be used as pivot points.
Pathfinding.Graphs.Util.EuclideanEmbedding.pivots	euclideanembedding.html#pivots	
Pathfinding.Graphs.Util.EuclideanEmbedding.ra	euclideanembedding.html#ra	
Pathfinding.Graphs.Util.EuclideanEmbedding.rc	euclideanembedding.html#rc	
Pathfinding.Graphs.Util.EuclideanEmbedding.rval	euclideanembedding.html#rval	
Pathfinding.Graphs.Util.EuclideanEmbedding.seed	euclideanembedding.html#seed	
Pathfinding.Graphs.Util.EuclideanEmbedding.spreadOutCount	euclideanembedding.html#spreadOutCount	
Pathfinding.Graphs.Util.HeuristicOptimizationMode	util.html#HeuristicOptimizationMode	
Pathfinding.GridGraph.CombinedGridGraphUpdatePromise.promises	combinedgridgraphupdatepromise.html#promises	
Pathfinding.GridGraph.Depth	gridgraph.html#Depth	
Pathfinding.GridGraph.FixedPrecisionScale	gridgraph.html#FixedPrecisionScale	Scaling used for the coordinates in the Linecast methods that take normalized points using integer coordinates. \n\nTo convert from world space, each coordinate is multiplied by this factor and then rounded to the nearest integer.\n\nTypically you do not need to use this constant yourself, instead use the Linecast overloads that do not take integer coordinates.
Pathfinding.GridGraph.GridGraphMovePromise.dx	gridgraphmovepromise.html#dx	
Pathfinding.GridGraph.GridGraphMovePromise.dz	gridgraphmovepromise.html#dz	
Pathfinding.GridGraph.GridGraphMovePromise.graph	gridgraphmovepromise.html#graph	
Pathfinding.GridGraph.GridGraphMovePromise.promises	gridgraphmovepromise.html#promises	
Pathfinding.GridGraph.GridGraphMovePromise.rects	gridgraphmovepromise.html#rects	
Pathfinding.GridGraph.GridGraphMovePromise.startingSize	gridgraphmovepromise.html#startingSize	
Pathfinding.GridGraph.GridGraphSnapshot.graph	gridgraphsnapshot.html#graph	
Pathfinding.GridGraph.GridGraphSnapshot.nodes	gridgraphsnapshot.html#nodes	
Pathfinding.GridGraph.GridGraphUpdatePromise.CostEstimate	gridgraphupdatepromise.html#CostEstimate	
Pathfinding.GridGraph.GridGraphUpdatePromise.NodesHolder.nodes	nodesholder.html#nodes	
Pathfinding.GridGraph.GridGraphUpdatePromise.allocationMethod	gridgraphupdatepromise.html#allocationMethod	
Pathfinding.GridGraph.GridGraphUpdatePromise.context	gridgraphupdatepromise.html#context	
Pathfinding.GridGraph.GridGraphUpdatePromise.dependencyTracker	gridgraphupdatepromise.html#dependencyTracker	
Pathfinding.GridGraph.GridGraphUpdatePromise.emptyUpdate	gridgraphupdatepromise.html#emptyUpdate	
Pathfinding.GridGraph.GridGraphUpdatePromise.fullRecalculationBounds	gridgraphupdatepromise.html#fullRecalculationBounds	
Pathfinding.GridGraph.GridGraphUpdatePromise.graph	gridgraphupdatepromise.html#graph	
Pathfinding.GridGraph.GridGraphUpdatePromise.graphUpdateObject	gridgraphupdatepromise.html#graphUpdateObject	
Pathfinding.GridGraph.GridGraphUpdatePromise.isFinalUpdate	gridgraphupdatepromise.html#isFinalUpdate	
Pathfinding.GridGraph.GridGraphUpdatePromise.nodeArrayBounds	gridgraphupdatepromise.html#nodeArrayBounds	
Pathfinding.GridGraph.GridGraphUpdatePromise.nodes	gridgraphupdatepromise.html#nodes	
Pathfinding.GridGraph.GridGraphUpdatePromise.nodesDependsOn	gridgraphupdatepromise.html#nodesDependsOn	
Pathfinding.GridGraph.GridGraphUpdatePromise.ownsJobDependencyTracker	gridgraphupdatepromise.html#ownsJobDependencyTracker	
Pathfinding.GridGraph.GridGraphUpdatePromise.readBounds	gridgraphupdatepromise.html#readBounds	
Pathfinding.GridGraph.GridGraphUpdatePromise.recalculationMode	gridgraphupdatepromise.html#recalculationMode	
Pathfinding.GridGraph.GridGraphUpdatePromise.rect	gridgraphupdatepromise.html#rect	
Pathfinding.GridGraph.GridGraphUpdatePromise.transform	gridgraphupdatepromise.html#transform	
Pathfinding.GridGraph.GridGraphUpdatePromise.writeMaskBounds	gridgraphupdatepromise.html#writeMaskBounds	
Pathfinding.GridGraph.HexagonConnectionMask	gridgraph.html#HexagonConnectionMask	Mask based on <b>hexagonNeighbourIndices</b>. \n\nThis indicates which connections (out of the 8 standard ones) should be enabled for hexagonal graphs.\n\n<b>[code in online documentation]</b>
Pathfinding.GridGraph.LayerCount	gridgraph.html#LayerCount	Number of layers in the graph. \n\nFor grid graphs this is always 1, for layered grid graphs it can be higher. The nodes array has the size width*depth*layerCount.
Pathfinding.GridGraph.MaxLayers	gridgraph.html#MaxLayers	
Pathfinding.GridGraph.RecalculationMode	gridgraph.html#RecalculationMode	
Pathfinding.GridGraph.StandardDimetricAngle	gridgraph.html#StandardDimetricAngle	Commonly used value for isometricAngle.
Pathfinding.GridGraph.StandardIsometricAngle	gridgraph.html#StandardIsometricAngle	Commonly used value for isometricAngle.
Pathfinding.GridGraph.TextureData.ChannelUse	texturedata.html#ChannelUse	
Pathfinding.GridGraph.TextureData.channels	texturedata.html#channels	
Pathfinding.GridGraph.TextureData.data	texturedata.html#data	
Pathfinding.GridGraph.TextureData.enabled	texturedata.html#enabled	
Pathfinding.GridGraph.TextureData.factors	texturedata.html#factors	
Pathfinding.GridGraph.TextureData.source	texturedata.html#source	
Pathfinding.GridGraph.Width	gridgraph.html#Width	
Pathfinding.GridGraph.allNeighbourIndices	gridgraph.html#allNeighbourIndices	Which neighbours are going to be used when neighbours=8.
Pathfinding.GridGraph.aspectRatio	gridgraph.html#aspectRatio	Scaling of the graph along the X axis. \n\nThis should be used if you want different scales on the X and Y axis of the grid\n\nThis option is only visible in the inspector if the graph shape is set to isometric or advanced.
Pathfinding.GridGraph.axisAlignedNeighbourIndices	gridgraph.html#axisAlignedNeighbourIndices	Which neighbours are going to be used when neighbours=4.
Pathfinding.GridGraph.bounds	gridgraph.html#bounds	World bounding box for the graph. \n\nThis always contains the whole graph.\n\n[more in online documentation]
Pathfinding.GridGraph.center	gridgraph.html#center	Center point of the grid in world space. \n\nThe graph can be positioned anywhere in the world.\n\n[more in online documentation]
Pathfinding.GridGraph.collision	gridgraph.html#collision	Settings on how to check for walkability and height.
Pathfinding.GridGraph.cutCorners	gridgraph.html#cutCorners	If disabled, will not cut corners on obstacles. \n\nIf this is true, and neighbours is set to <b>Eight</b>, obstacle corners are allowed to be cut by a connection.\n\n <b>[image in online documentation]</b>
Pathfinding.GridGraph.depth	gridgraph.html#depth	Depth (height) of the grid in nodes. \n\nGrid graphs are typically anywhere from 10-500 nodes wide. But it can go up to 1024 nodes wide by default. Consider using a recast graph instead, if you find yourself needing a very high resolution grid.\n\nThis value will be clamped to at most 1024 unless <b>ASTAR_LARGER_GRIDS</b> has been enabled in the A* Inspector -&gt; Optimizations tab.\n\n[more in online documentation]
Pathfinding.GridGraph.erodeIterations	gridgraph.html#erodeIterations	Number of times to erode the graph. \n\nThe graph can be eroded to add extra margin to obstacles. It is very convenient if your graph contains ledges, and where the walkable nodes without erosion are too close to the edge.\n\nBelow is an image showing a graph with 0, 1 and 2 erosion iterations:  <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridGraph.erosionFirstTag	gridgraph.html#erosionFirstTag	Tag to start from when using tags for erosion. \n\n[more in online documentation]
Pathfinding.GridGraph.erosionTagsPrecedenceMask	gridgraph.html#erosionTagsPrecedenceMask	Bitmask for which tags can be overwritten by erosion tags. \n\nWhen erosionUseTags is enabled, nodes near unwalkable nodes will be marked with tags. However, if these nodes already have tags, you may want the custom tag to take precedence. This mask controls which tags are allowed to be replaced by the new erosion tags.\n\nIn the image below, erosion has applied tags which have overwritten both the base tag (tag 0) and the custom tag set on the nodes (shown in red).  <b>[image in online documentation]</b>\n\nIn the image below, erosion has applied tags, but it was not allowed to overwrite the custom tag set on the nodes (shown in red).  <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridGraph.erosionUseTags	gridgraph.html#erosionUseTags	Use tags instead of walkability for erosion. \n\nTags will be used for erosion instead of marking nodes as unwalkable. The nodes will be marked with tags in an increasing order starting with the tag erosionFirstTag. Debug with the Tags mode to see the effect. With this enabled you can in effect set how close different AIs are allowed to get to walls using the Valid Tags field on the Seeker component.  <b>[image in online documentation]</b><b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridGraph.hexagonNeighbourIndices	gridgraph.html#hexagonNeighbourIndices	Which neighbours are going to be used when neighbours=6.
Pathfinding.GridGraph.inspectorGridMode	gridgraph.html#inspectorGridMode	Determines the layout of the grid graph inspector in the Unity Editor. \n\nA grid graph can be set up as a normal grid, isometric grid or hexagonal grid. Each of these modes use a slightly different inspector layout. When changing the shape in the inspector, it will automatically set other relevant fields to appropriate values. For example, when setting the shape to hexagonal it will automatically set the neighbours field to Six.\n\nThis field is only used in the editor, it has no effect on the rest of the game whatsoever.\n\nIf you want to change the grid shape like in the inspector you can use the SetGridShape method.
Pathfinding.GridGraph.inspectorHexagonSizeMode	gridgraph.html#inspectorHexagonSizeMode	Determines how the size of each hexagon is set in the inspector. \n\nFor hexagons the normal nodeSize field doesn't really correspond to anything specific on the hexagon's geometry, so this enum is used to give the user the opportunity to adjust more concrete dimensions of the hexagons without having to pull out a calculator to calculate all the square roots and complicated conversion factors.\n\nThis field is only used in the graph inspector, the nodeSize field will always use the same internal units. If you want to set the node size through code then you can use ConvertHexagonSizeToNodeSize.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridGraph.is2D	gridgraph.html#is2D	Get or set if the graph should be in 2D mode. \n\n[more in online documentation]
Pathfinding.GridGraph.isScanned	gridgraph.html#isScanned	True if the graph has been scanned and contains nodes. \n\nGraphs are typically scanned when the game starts, but they can also be scanned manually.\n\nIf a graph has not been scanned, it does not contain any nodes and it not possible to use it for pathfinding.\n\n[more in online documentation]
Pathfinding.GridGraph.isometricAngle	gridgraph.html#isometricAngle	Angle in degrees to use for the isometric projection. \n\nIf you are making a 2D isometric game, you may want to use this parameter to adjust the layout of the graph to match your game. This will essentially scale the graph along one of its diagonals to produce something like this:\n\nA perspective view of an isometric graph.  <b>[image in online documentation]</b>\n\nA top down view of an isometric graph. Note that the graph is entirely 2D, there is no perspective in this image.  <b>[image in online documentation]</b>\n\nFor commonly used values see StandardIsometricAngle and StandardDimetricAngle.\n\nUsually the angle that you want to use is either 30 degrees (alternatively 90-30 = 60 degrees) or atan(1/sqrt(2)) which is approximately 35.264 degrees (alternatively 90 - 35.264 = 54.736 degrees). You might also want to rotate the graph plus or minus 45 degrees around the Y axis to get the oritientation required for your game.\n\nYou can read more about it on the wikipedia page linked below.\n\n[more in online documentation]\nThis option is only visible in the inspector if the graph shape is set to isometric or advanced.
Pathfinding.GridGraph.maxClimb	gridgraph.html#maxClimb	The max y coordinate difference between two nodes to enable a connection. \n\n[more in online documentation]
Pathfinding.GridGraph.maxSlope	gridgraph.html#maxSlope	The max slope in degrees for a node to be walkable.
Pathfinding.GridGraph.maxStepHeight	gridgraph.html#maxStepHeight	The max y coordinate difference between two nodes to enable a connection. \n\nSet to 0 to ignore the value.\n\nThis affects for example how the graph is generated around ledges and stairs.\n\n[more in online documentation]
Pathfinding.GridGraph.maxStepUsesSlope	gridgraph.html#maxStepUsesSlope	Take the slope into account for maxStepHeight. \n\nWhen this is enabled the normals of the terrain will be used to make more accurate estimates of how large the steps are between adjacent nodes.\n\nWhen this is disabled then calculated step between two nodes is their y coordinate difference. This may be inaccurate, especially at the start of steep slopes.\n\n <b>[image in online documentation]</b>\n\nIn the image below you can see an example of what happens near a ramp. In the topmost image the ramp is not connected with the rest of the graph which is obviously not what we want. In the middle image an attempt has been made to raise the max step height while keeping maxStepUsesSlope disabled. However this causes too many connections to be added. The agent should not be able to go up the ramp from the side. Finally in the bottommost image the maxStepHeight has been restored to the original value but maxStepUsesSlope has been enabled. This configuration handles the ramp in a much smarter way. Note that all the values in the image are just example values, they may be different for your scene.  <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridGraph.neighbourCosts	gridgraph.html#neighbourCosts	Costs to neighbour nodes. \n\nSee neighbourOffsets.
Pathfinding.GridGraph.neighbourOffsets	gridgraph.html#neighbourOffsets	Index offset to get neighbour nodes. \n\nAdded to a node's index to get a neighbour node index.\n\n<b>[code in online documentation]</b>
Pathfinding.GridGraph.neighbourXOffsets	gridgraph.html#neighbourXOffsets	Offsets in the X direction for neighbour nodes. \n\nOnly 1, 0 or -1
Pathfinding.GridGraph.neighbourZOffsets	gridgraph.html#neighbourZOffsets	Offsets in the Z direction for neighbour nodes. \n\nOnly 1, 0 or -1
Pathfinding.GridGraph.neighbours	gridgraph.html#neighbours	Number of neighbours for each node. \n\nEither four, six, eight connections per node.\n\nSix connections is primarily for hexagonal graphs.
Pathfinding.GridGraph.newGridNodeDelegate	gridgraph.html#newGridNodeDelegate	Delegate which creates and returns a single instance of the node type for this graph. \n\nThis may be set in the constructor for graphs inheriting from the GridGraph to change the node type of the graph.
Pathfinding.GridGraph.nodeData	gridgraph.html#nodeData	Internal data for each node. \n\nIt also contains some data not stored in the node objects, such as normals for the surface of the graph. These normals need to be saved when the maxStepUsesSlope option is enabled for graph updates to work.
Pathfinding.GridGraph.nodeDataRef	gridgraph.html#nodeDataRef	
Pathfinding.GridGraph.nodeSize	gridgraph.html#nodeSize	Size of one node in world units. \n\nFor a grid layout, this is the length of the sides of the grid squares.\n\nFor a hexagonal layout, this value does not correspond to any specific dimension of the hexagon. Instead you can convert it to a dimension on a hexagon using ConvertNodeSizeToHexagonSize.\n\n[more in online documentation]
Pathfinding.GridGraph.nodes	gridgraph.html#nodes	All nodes in this graph. \n\nNodes are laid out row by row.\n\nThe first node has grid coordinates X=0, Z=0, the second one X=1, Z=0\n\nthe last one has grid coordinates X=width-1, Z=depth-1.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridGraph.penaltyAngle	gridgraph.html#penaltyAngle	[more in online documentation]
Pathfinding.GridGraph.penaltyAngleFactor	gridgraph.html#penaltyAngleFactor	How much penalty is applied depending on the slope of the terrain. \n\nAt a 90 degree slope (not that exactly 90 degree slopes can occur, but almost 90 degree), this penalty is applied. At a 45 degree slope, half of this is applied and so on. Note that you may require very large values, a value of 1000 is equivalent to the cost of moving 1 world unit.\n\n[more in online documentation]
Pathfinding.GridGraph.penaltyAnglePower	gridgraph.html#penaltyAnglePower	How much extra to penalize very steep angles. \n\n[more in online documentation]
Pathfinding.GridGraph.penaltyPosition	gridgraph.html#penaltyPosition	Use position (y-coordinate) to calculate penalty. \n\n[more in online documentation]
Pathfinding.GridGraph.penaltyPositionFactor	gridgraph.html#penaltyPositionFactor	Scale factor for penalty when calculating from position. \n\n[more in online documentation]
Pathfinding.GridGraph.penaltyPositionOffset	gridgraph.html#penaltyPositionOffset	Offset for the position when calculating penalty. \n\n[more in online documentation]
Pathfinding.GridGraph.rotation	gridgraph.html#rotation	Rotation of the grid in degrees. \n\nThe nodes are laid out along the X and Z axes of the rotation.\n\nFor a 2D game, the rotation will typically be set to (-90, 270, 90). If the graph is aligned with the XY plane, the inspector will automatically switch to 2D mode.\n\n[more in online documentation]
Pathfinding.GridGraph.rules	gridgraph.html#rules	Additional rules to use when scanning the grid graph. \n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridGraph.showMeshOutline	gridgraph.html#showMeshOutline	Show an outline of the grid nodes in the Unity Editor.
Pathfinding.GridGraph.showMeshSurface	gridgraph.html#showMeshSurface	Show the surface of the graph. \n\nEach node will be drawn as a square (unless e.g hexagon graph mode has been enabled).
Pathfinding.GridGraph.showNodeConnections	gridgraph.html#showNodeConnections	Show the connections between the grid nodes in the Unity Editor.
Pathfinding.GridGraph.size	gridgraph.html#size	Size of the grid. \n\nWill always be positive and larger than nodeSize. \n\n[more in online documentation]
Pathfinding.GridGraph.textureData	gridgraph.html#textureData	Holds settings for using a texture as source for a grid graph. \n\nTexure data can be used for fine grained control over how the graph will look. It can be used for positioning, penalty and walkability control.\n\nBelow is a screenshot of a grid graph with a penalty map applied. It has the effect of the AI taking the longer path along the green (low penalty) areas.\n\n <b>[image in online documentation]</b>[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.GridGraph.transform	gridgraph.html#transform	Determines how the graph transforms graph space to world space. \n\n[more in online documentation]
Pathfinding.GridGraph.unclampedSize	gridgraph.html#unclampedSize	Size of the grid. \n\nCan be negative or smaller than nodeSize
Pathfinding.GridGraph.uniformEdgeCosts	gridgraph.html#uniformEdgeCosts	If true, all edge costs will be set to the same value. \n\nIf false, diagonals will cost more. This is useful for a hexagon graph where the diagonals are actually the same length as the normal edges (since the graph has been skewed)\n\nIf the graph is set to hexagonal in the inspector, this will be automatically set to true.
Pathfinding.GridGraph.useRaycastNormal	gridgraph.html#useRaycastNormal	Use heigh raycasting normal for max slope calculation. \n\nTrue if maxSlope is less than 90 degrees.
Pathfinding.GridGraph.width	gridgraph.html#width	Width of the grid in nodes. \n\nGrid graphs are typically anywhere from 10-500 nodes wide. But it can go up to 1024 nodes wide by default. Consider using a recast graph instead, if you find yourself needing a very high resolution grid.\n\nThis value will be clamped to at most 1024 unless <b>ASTAR_LARGER_GRIDS</b> has been enabled in the A* Inspector -&gt; Optimizations tab.\n\n[more in online documentation]
Pathfinding.GridGraphEditor.GridPivot	gridgrapheditor.html#GridPivot	
Pathfinding.GridGraphEditor.arcBuffer	gridgrapheditor.html#arcBuffer	
Pathfinding.GridGraphEditor.cachedSceneGridLayouts	gridgrapheditor.html#cachedSceneGridLayouts	
Pathfinding.GridGraphEditor.cachedSceneGridLayoutsTimestamp	gridgrapheditor.html#cachedSceneGridLayoutsTimestamp	
Pathfinding.GridGraphEditor.collisionPreviewOpen	gridgrapheditor.html#collisionPreviewOpen	Shows the preview for the collision testing options. \n\n <b>[image in online documentation]</b>\n\nOn the left you can see a top-down view of the graph with a grid of nodes. On the right you can see a side view of the graph. The white line at the bottom is the base of the graph, with node positions indicated using small dots. When using 2D physics, only the top-down view is visible.\n\nThe green shape indicates the shape that will be used for collision checking.
Pathfinding.GridGraphEditor.gridPivotSelectBackground	gridgrapheditor.html#gridPivotSelectBackground	Cached gui style.
Pathfinding.GridGraphEditor.gridPivotSelectButton	gridgrapheditor.html#gridPivotSelectButton	Cached gui style.
Pathfinding.GridGraphEditor.handlePoints	gridgrapheditor.html#handlePoints	
Pathfinding.GridGraphEditor.hexagonSizeContents	gridgrapheditor.html#hexagonSizeContents	
Pathfinding.GridGraphEditor.interpolatedGridWidthInNodes	gridgrapheditor.html#interpolatedGridWidthInNodes	
Pathfinding.GridGraphEditor.isMouseDown	gridgrapheditor.html#isMouseDown	
Pathfinding.GridGraphEditor.lastTime	gridgrapheditor.html#lastTime	
Pathfinding.GridGraphEditor.lineBuffer	gridgrapheditor.html#lineBuffer	
Pathfinding.GridGraphEditor.lockStyle	gridgrapheditor.html#lockStyle	Cached gui style.
Pathfinding.GridGraphEditor.locked	gridgrapheditor.html#locked	
Pathfinding.GridGraphEditor.pivot	gridgrapheditor.html#pivot	
Pathfinding.GridGraphEditor.ruleEditorInstances	gridgrapheditor.html#ruleEditorInstances	
Pathfinding.GridGraphEditor.ruleEditors	gridgrapheditor.html#ruleEditors	
Pathfinding.GridGraphEditor.ruleHeaders	gridgrapheditor.html#ruleHeaders	
Pathfinding.GridGraphEditor.ruleTypes	gridgrapheditor.html#ruleTypes	
Pathfinding.GridGraphEditor.savedDimensions	gridgrapheditor.html#savedDimensions	
Pathfinding.GridGraphEditor.savedNodeSize	gridgrapheditor.html#savedNodeSize	
Pathfinding.GridGraphEditor.savedTransform	gridgrapheditor.html#savedTransform	
Pathfinding.GridGraphEditor.selectedTilemap	gridgrapheditor.html#selectedTilemap	
Pathfinding.GridGraphEditor.showExtra	gridgrapheditor.html#showExtra	
Pathfinding.GridHitInfo.direction	gridhitinfo.html#direction	Direction from the node to the edge that was hit. \n\nThis will be in the range of 0 to 4 (exclusive) or -1 if no particular edge was hit.\n\n[more in online documentation]
Pathfinding.GridHitInfo.node	gridhitinfo.html#node	The node which contained the edge that was hit. \n\nThis may be null in case no particular edge was hit.
Pathfinding.GridNode.EdgeNode	gridnode.html#EdgeNode	Work in progress for a feature that required info about which nodes were at the border of the graph. \n\n[more in online documentation]
Pathfinding.GridNode.GridFlagsAxisAlignedConnectionMask	gridnode.html#GridFlagsAxisAlignedConnectionMask	
Pathfinding.GridNode.GridFlagsConnectionBit0	gridnode.html#GridFlagsConnectionBit0	
Pathfinding.GridNode.GridFlagsConnectionMask	gridnode.html#GridFlagsConnectionMask	
Pathfinding.GridNode.GridFlagsConnectionOffset	gridnode.html#GridFlagsConnectionOffset	
Pathfinding.GridNode.GridFlagsEdgeNodeMask	gridnode.html#GridFlagsEdgeNodeMask	
Pathfinding.GridNode.GridFlagsEdgeNodeOffset	gridnode.html#GridFlagsEdgeNodeOffset	
Pathfinding.GridNode.HasAnyGridConnections	gridnode.html#HasAnyGridConnections	True if this node has any grid connections.
Pathfinding.GridNode.HasConnectionsToAllAxisAlignedNeighbours	gridnode.html#HasConnectionsToAllAxisAlignedNeighbours	True if the node has grid connections to all its 4 axis-aligned neighbours. \n\n[more in online documentation]
Pathfinding.GridNode.HasConnectionsToAllEightNeighbours	gridnode.html#HasConnectionsToAllEightNeighbours	True if the node has grid connections to all its 8 neighbours. \n\n[more in online documentation]
Pathfinding.GridNode.InternalGridFlags	gridnode.html#InternalGridFlags	Internal use only.
Pathfinding.GridNode._gridGraphs	gridnode.html#_gridGraphs	
Pathfinding.GridNodeBase.CoordinatesInGrid	gridnodebase.html#CoordinatesInGrid	The X and Z coordinates of the node in the grid. \n\nThe node in the bottom left corner has (x,z) = (0,0) and the one in the opposite corner has (x,z) = (width-1, depth-1)\n\n[more in online documentation]
Pathfinding.GridNodeBase.GridFlagsWalkableErosionMask	gridnodebase.html#GridFlagsWalkableErosionMask	
Pathfinding.GridNodeBase.GridFlagsWalkableErosionOffset	gridnodebase.html#GridFlagsWalkableErosionOffset	
Pathfinding.GridNodeBase.GridFlagsWalkableTmpMask	gridnodebase.html#GridFlagsWalkableTmpMask	
Pathfinding.GridNodeBase.GridFlagsWalkableTmpOffset	gridnodebase.html#GridFlagsWalkableTmpOffset	
Pathfinding.GridNodeBase.HasAnyGridConnections	gridnodebase.html#HasAnyGridConnections	True if this node has any grid connections.
Pathfinding.GridNodeBase.HasConnectionsToAllAxisAlignedNeighbours	gridnodebase.html#HasConnectionsToAllAxisAlignedNeighbours	True if the node has grid connections to all its 4 axis-aligned neighbours. \n\n[more in online documentation]
Pathfinding.GridNodeBase.HasConnectionsToAllEightNeighbours	gridnodebase.html#HasConnectionsToAllEightNeighbours	True if the node has grid connections to all its 8 neighbours. \n\n[more in online documentation]
Pathfinding.GridNodeBase.NodeInGridIndex	gridnodebase.html#NodeInGridIndex	The index of the node in the grid. \n\nThis is x + z*graph.width So you can get the X and Z indices using <b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.GridNodeBase.NodeInGridIndexLayerOffset	gridnodebase.html#NodeInGridIndexLayerOffset	
Pathfinding.GridNodeBase.NodeInGridIndexMask	gridnodebase.html#NodeInGridIndexMask	
Pathfinding.GridNodeBase.TmpWalkable	gridnodebase.html#TmpWalkable	Temporary variable used internally when updating the graph.
Pathfinding.GridNodeBase.WalkableErosion	gridnodebase.html#WalkableErosion	Stores walkability before erosion is applied. \n\nUsed internally when updating the graph.
Pathfinding.GridNodeBase.XCoordinateInGrid	gridnodebase.html#XCoordinateInGrid	X coordinate of the node in the grid. \n\nThe node in the bottom left corner has (x,z) = (0,0) and the one in the opposite corner has (x,z) = (width-1, depth-1)\n\n[more in online documentation]
Pathfinding.GridNodeBase.ZCoordinateInGrid	gridnodebase.html#ZCoordinateInGrid	Z coordinate of the node in the grid. \n\nThe node in the bottom left corner has (x,z) = (0,0) and the one in the opposite corner has (x,z) = (width-1, depth-1)\n\n[more in online documentation]
Pathfinding.GridNodeBase.connections	gridnodebase.html#connections	Custon non-grid connections from this node. \n\n[more in online documentation]\nThis field is removed if the ASTAR_GRID_NO_CUSTOM_CONNECTIONS compiler directive is used. Removing it can save a tiny bit of memory. You can enable the define in the Optimizations tab in the A* inspector. \n\n[more in online documentation]
Pathfinding.GridNodeBase.gridFlags	gridnodebase.html#gridFlags	
Pathfinding.GridNodeBase.nodeInGridIndex	gridnodebase.html#nodeInGridIndex	Bitfield containing the x and z coordinates of the node as well as the layer (for layered grid graphs). \n\n[more in online documentation]
Pathfinding.GridNodeBase.offsetToDirection	gridnodebase.html#offsetToDirection	Converts from dx + 3*dz to a neighbour direction. \n\nUsed by OffsetToConnectionDirection.\n\nAssumes that dx and dz are both in the range [0,2]. \n\n[more in online documentation]
Pathfinding.GridStringPulling.FixedPrecisionScale	gridstringpulling.html#FixedPrecisionScale	
Pathfinding.GridStringPulling.PredicateFailMode	gridstringpulling.html#PredicateFailMode	
Pathfinding.GridStringPulling.TriangleBounds.d1	trianglebounds.html#d1	
Pathfinding.GridStringPulling.TriangleBounds.d2	trianglebounds.html#d2	
Pathfinding.GridStringPulling.TriangleBounds.d3	trianglebounds.html#d3	
Pathfinding.GridStringPulling.TriangleBounds.t1	trianglebounds.html#t1	
Pathfinding.GridStringPulling.TriangleBounds.t2	trianglebounds.html#t2	
Pathfinding.GridStringPulling.TriangleBounds.t3	trianglebounds.html#t3	
Pathfinding.GridStringPulling.directionToCorners	gridstringpulling.html#directionToCorners	Z | |. \n\n3 2 \ | / – - X - —– X / | \ 0 1\n\n| |
Pathfinding.GridStringPulling.marker1	gridstringpulling.html#marker1	
Pathfinding.GridStringPulling.marker2	gridstringpulling.html#marker2	
Pathfinding.GridStringPulling.marker3	gridstringpulling.html#marker3	
Pathfinding.GridStringPulling.marker4	gridstringpulling.html#marker4	
Pathfinding.GridStringPulling.marker5	gridstringpulling.html#marker5	
Pathfinding.GridStringPulling.marker6	gridstringpulling.html#marker6	
Pathfinding.GridStringPulling.marker7	gridstringpulling.html#marker7	
Pathfinding.Heuristic	pathfinding.html#Heuristic	How to estimate the cost of moving to the destination during pathfinding. \n\nThe heuristic is the estimated cost from the current node to the target. The different heuristics have roughly the same performance except not using any heuristic at all ( Heuristic.None) which is usually significantly slower.\n\nIn the image below you can see a comparison of the different heuristic options for an 8-connected grid and for a 4-connected grid. Note that all paths within the green area will all have the same length. The only difference between the heuristics is which of those paths of the same length that will be chosen. Note that while the Diagonal Manhattan and Manhattan options seem to behave very differently on an 8-connected grid they only do it in this case because of very small rounding errors. Usually they behave almost identically on 8-connected grids.\n\n <b>[image in online documentation]</b>\n\nGenerally for a 4-connected grid graph the Manhattan option should be used as it is the true distance on a 4-connected grid. For an 8-connected grid graph the Diagonal Manhattan option is the mathematically most correct option, however the Euclidean option is often preferred, especially if you are simplifying the path afterwards using modifiers.\n\nFor any graph that is not grid based the Euclidean option is the best one to use.\n\n[more in online documentation]
Pathfinding.HeuristicObjective.euclideanEmbeddingCosts	heuristicobjective.html#euclideanEmbeddingCosts	
Pathfinding.HeuristicObjective.euclideanEmbeddingPivots	heuristicobjective.html#euclideanEmbeddingPivots	
Pathfinding.HeuristicObjective.hasHeuristic	heuristicobjective.html#hasHeuristic	
Pathfinding.HeuristicObjective.heuristic	heuristicobjective.html#heuristic	
Pathfinding.HeuristicObjective.heuristicScale	heuristicobjective.html#heuristicScale	
Pathfinding.HeuristicObjective.mn	heuristicobjective.html#mn	
Pathfinding.HeuristicObjective.mx	heuristicobjective.html#mx	
Pathfinding.HeuristicObjective.targetNodeIndex	heuristicobjective.html#targetNodeIndex	
Pathfinding.HierarchicalGraph.HierarhicalNodeData.bounds	hierarhicalnodedata.html#bounds	
Pathfinding.HierarchicalGraph.HierarhicalNodeData.connectionAllocations	hierarhicalnodedata.html#connectionAllocations	
Pathfinding.HierarchicalGraph.HierarhicalNodeData.connectionAllocator	hierarhicalnodedata.html#connectionAllocator	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.Context.children	context.html#children	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.Context.connections	context.html#connections	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.Context.graphindex	context.html#graphindex	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.Context.hierarchicalNodeIndex	context.html#hierarchicalNodeIndex	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.Context.queue	context.html#queue	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.bounds	jobrecalculatecomponents.html#bounds	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.connectionAllocations	jobrecalculatecomponents.html#connectionAllocations	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.dirtiedHierarchicalNodes	jobrecalculatecomponents.html#dirtiedHierarchicalNodes	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.hGraphGC	jobrecalculatecomponents.html#hGraphGC	
Pathfinding.HierarchicalGraph.JobRecalculateComponents.numHierarchicalNodes	jobrecalculatecomponents.html#numHierarchicalNodes	
Pathfinding.HierarchicalGraph.MaxChildrenPerNode	hierarchicalgraph.html#MaxChildrenPerNode	
Pathfinding.HierarchicalGraph.MinChildrenPerNode	hierarchicalgraph.html#MinChildrenPerNode	
Pathfinding.HierarchicalGraph.NumConnectedComponents	hierarchicalgraph.html#NumConnectedComponents	
Pathfinding.HierarchicalGraph.Tiling	hierarchicalgraph.html#Tiling	
Pathfinding.HierarchicalGraph.areas	hierarchicalgraph.html#areas	
Pathfinding.HierarchicalGraph.bounds	hierarchicalgraph.html#bounds	
Pathfinding.HierarchicalGraph.children	hierarchicalgraph.html#children	
Pathfinding.HierarchicalGraph.connectionAllocations	hierarchicalgraph.html#connectionAllocations	
Pathfinding.HierarchicalGraph.connectionAllocator	hierarchicalgraph.html#connectionAllocator	
Pathfinding.HierarchicalGraph.currentConnections	hierarchicalgraph.html#currentConnections	
Pathfinding.HierarchicalGraph.dirtiedHierarchicalNodes	hierarchicalgraph.html#dirtiedHierarchicalNodes	
Pathfinding.HierarchicalGraph.dirty	hierarchicalgraph.html#dirty	
Pathfinding.HierarchicalGraph.dirtyNodes	hierarchicalgraph.html#dirtyNodes	
Pathfinding.HierarchicalGraph.freeNodeIndices	hierarchicalgraph.html#freeNodeIndices	
Pathfinding.HierarchicalGraph.gcHandle	hierarchicalgraph.html#gcHandle	
Pathfinding.HierarchicalGraph.gizmoVersion	hierarchicalgraph.html#gizmoVersion	
Pathfinding.HierarchicalGraph.navmeshEdges	hierarchicalgraph.html#navmeshEdges	
Pathfinding.HierarchicalGraph.nodeStorage	hierarchicalgraph.html#nodeStorage	
Pathfinding.HierarchicalGraph.numHierarchicalNodes	hierarchicalgraph.html#numHierarchicalNodes	Holds areas.Length as a burst-accessible reference.
Pathfinding.HierarchicalGraph.rwLock	hierarchicalgraph.html#rwLock	
Pathfinding.HierarchicalGraph.temporaryQueue	hierarchicalgraph.html#temporaryQueue	
Pathfinding.HierarchicalGraph.temporaryStack	hierarchicalgraph.html#temporaryStack	
Pathfinding.HierarchicalGraph.version	hierarchicalgraph.html#version	
Pathfinding.HierarchicalGraph.versions	hierarchicalgraph.html#versions	
Pathfinding.IAstarAI.canMove	iastarai.html#canMove	Enables or disables movement completely. \n\nIf you want the agent to stand still, but still react to local avoidance and use gravity: use isStopped instead.\n\nThis is also useful if you want to have full control over when the movement calculations run. Take a look at MovementUpdate\n\n[more in online documentation]
Pathfinding.IAstarAI.canSearch	iastarai.html#canSearch	Enables or disables recalculating the path at regular intervals. \n\nSetting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.\n\nNote that this only disables automatic path recalculations. If you call the SearchPath() method a path will still be calculated.\n\n[more in online documentation]
Pathfinding.IAstarAI.desiredVelocity	iastarai.html#desiredVelocity	Velocity that this agent wants to move with. \n\nIncludes gravity and local avoidance if applicable. In world units per second.\n\n[more in online documentation]
Pathfinding.IAstarAI.desiredVelocityWithoutLocalAvoidance	iastarai.html#desiredVelocityWithoutLocalAvoidance	Velocity that this agent wants to move with before taking local avoidance into account. \n\nIncludes gravity. In world units per second.\n\nSetting this property will set the current velocity that the agent is trying to move with, including gravity. This can be useful if you want to make the agent come to a complete stop in a single frame or if you want to modify the velocity in some way.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]\n\n\nIf you are not using local avoidance then this property will in almost all cases be identical to desiredVelocity plus some noise due to floating point math.\n\n[more in online documentation]
Pathfinding.IAstarAI.destination	iastarai.html#destination	Position in the world that this agent should move to. \n\nIf no destination has been set yet, then (+infinity, +infinity, +infinity) will be returned.\n\nNote that setting this property does not immediately cause the agent to recalculate its path. So it may take some time before the agent starts to move towards this point. Most movement scripts have a <b>repathRate</b> field which indicates how often the agent looks for a new path. You can also call the SearchPath method to immediately start to search for a new path. Paths are calculated asynchronously so when an agent starts to search for path it may take a few frames (usually 1 or 2) until the result is available. During this time the pathPending property will return true.\n\nIf you are setting a destination and then want to know when the agent has reached that destination then you could either use reachedDestination (recommended) or check both pathPending and reachedEndOfPath. Check the documentation for the respective fields to learn about their differences.\n\n<b>[code in online documentation]</b><b>[code in online documentation]</b>
Pathfinding.IAstarAI.endOfPath	iastarai.html#endOfPath	End point of path the agent is currently following. \n\nIf the agent has no path (or it might not be calculated yet), this will return the destination instead. If the agent has no destination it will return the agent's current position.\n\nThe end of the path is usually identical or very close to the destination, but it may differ if the path for example was blocked by a wall so that the agent couldn't get any closer.\n\nThis is only updated when the path is recalculated.
Pathfinding.IAstarAI.hasPath	iastarai.html#hasPath	True if this agent currently has a path that it follows.
Pathfinding.IAstarAI.height	iastarai.html#height	Height of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nThis value is currently only used if an RVOController is attached to the same GameObject, otherwise it is only used for drawing nice gizmos in the scene view. However since the height value is used for some things, the radius field is always visible for consistency and easier visualization of the character. That said, it may be used for something in a future release.\n\n[more in online documentation]
Pathfinding.IAstarAI.isStopped	iastarai.html#isStopped	Gets or sets if the agent should stop moving. \n\nIf this is set to true the agent will immediately start to slow down as quickly as it can to come to a full stop. The agent will still react to local avoidance and gravity (if applicable), but it will not try to move in any particular direction.\n\nThe current path of the agent will not be cleared, so when this is set to false again the agent will continue moving along the previous path.\n\nThis is a purely user-controlled parameter, so for example it is not set automatically when the agent stops moving because it has reached the target. Use reachedEndOfPath for that.\n\nIf this property is set to true while the agent is traversing an off-mesh link (RichAI script only), then the agent will continue traversing the link and stop once it has completed it.\n\n[more in online documentation]\nThe steeringTarget property will continue to indicate the point which the agent would move towards if it would not be stopped.
Pathfinding.IAstarAI.maxSpeed	iastarai.html#maxSpeed	Max speed in world units per second.
Pathfinding.IAstarAI.movementPlane	iastarai.html#movementPlane	The plane the agent is moving in. \n\nThis is typically the ground plane, which will be the XZ plane in a 3D game, and the XY plane in a 2D game. Ultimately it depends on the graph orientation.\n\nIf you are doing pathfinding on a spherical world (see Spherical Worlds), the the movement plane will be the tangent plane of the sphere at the agent's position.
Pathfinding.IAstarAI.onSearchPath	iastarai.html#onSearchPath	Called when the agent recalculates its path. \n\nThis is called both for automatic path recalculations (see canSearch) and manual ones (see SearchPath).\n\n[more in online documentation]
Pathfinding.IAstarAI.pathPending	iastarai.html#pathPending	True if a path is currently being calculated.
Pathfinding.IAstarAI.position	iastarai.html#position	Position of the agent. \n\nIn world space. \n\n[more in online documentation]\nIf you want to move the agent you may use Teleport or Move.
Pathfinding.IAstarAI.radius	iastarai.html#radius	Radius of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nNote that this does not affect pathfinding in any way. The graph used completely determines where the agent can move.\n\n[more in online documentation]
Pathfinding.IAstarAI.reachedDestination	iastarai.html#reachedDestination	True if the ai has reached the destination. \n\nThis is a best effort calculation to see if the destination has been reached. For the AIPath/RichAI scripts, this is when the character is within AIPath.endReachedDistance world units from the destination. For the AILerp script it is when the character is at the destination (±a very small margin).\n\nThis value will be updated immediately when the destination is changed (in contrast to reachedEndOfPath), however since path requests are asynchronous it will use an approximation until it sees the real path result. What this property does is to check the distance to the end of the current path, and add to that the distance from the end of the path to the destination (i.e. is assumes it is possible to move in a straight line between the end of the current path to the destination) and then checks if that total distance is less than AIPath.endReachedDistance. This property is therefore only a best effort, but it will work well for almost all use cases.\n\nFurthermore it will not report that the destination is reached if the destination is above the head of the character or more than half the height of the character below its feet (so if you have a multilevel building, it is important that you configure the height of the character correctly).\n\nThe cases which could be problematic are if an agent is standing next to a very thin wall and the destination suddenly changes to the other side of that thin wall. During the time that it takes for the path to be calculated the agent may see itself as alredy having reached the destination because the destination only moved a very small distance (the wall was thin), even though it may actually be quite a long way around the wall to the other side.\n\nIn contrast to reachedEndOfPath, this property is immediately updated when the destination is changed.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.IAstarAI.reachedEndOfPath	iastarai.html#reachedEndOfPath	True if the agent has reached the end of the current path. \n\nNote that setting the destination does not immediately update the path, nor is there any guarantee that the AI will actually be able to reach the destination that you set. The AI will try to get as close as possible. Often you want to use reachedDestination instead which is easier to work with.\n\nIt is very hard to provide a method for detecting if the AI has reached the destination that works across all different games because the destination may not even lie on the navmesh and how that is handled differs from game to game (see also the code snippet in the docs for destination).\n\n[more in online documentation]
Pathfinding.IAstarAI.remainingDistance	iastarai.html#remainingDistance	Approximate remaining distance along the current path to the end of the path. \n\nThe RichAI movement script approximates this distance since it is quite expensive to calculate the real distance. However it will be accurate when the agent is within 1 corner of the destination. You can use GetRemainingPath to calculate the actual remaining path more precisely.\n\nThe AIPath and AILerp scripts use a more accurate distance calculation at all times.\n\nIf the agent does not currently have a path, then positive infinity will be returned.\n\n[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.IAstarAI.rotation	iastarai.html#rotation	Rotation of the agent. \n\nIn world space. \n\n[more in online documentation]
Pathfinding.IAstarAI.steeringTarget	iastarai.html#steeringTarget	Point on the path which the agent is currently moving towards. \n\nThis is usually a point a small distance ahead of the agent or the end of the path.\n\nIf the agent does not have a path at the moment, then the agent's current position will be returned.
Pathfinding.IAstarAI.updatePosition	iastarai.html#updatePosition	Determines if the character's position should be coupled to the Transform's position. \n\nIf false then all movement calculations will happen as usual, but the GameObject that this component is attached to will not move. Instead, only the position property will change.\n\nThis is useful if you want to control the movement of the character using some other means, such as root motion, but still want the AI to move freely.\n\n[more in online documentation]
Pathfinding.IAstarAI.updateRotation	iastarai.html#updateRotation	Determines if the character's rotation should be coupled to the Transform's rotation. \n\nIf false then all movement calculations will happen as usual, but the GameObject that this component is attached to will not rotate. Instead, only the rotation property will change.\n\nThis is particularly useful for 2D games where you want the Transform to stay in the same orientation, and instead swap out the displayed sprite to indicate the direction the character is facing.\n\n[more in online documentation]
Pathfinding.IAstarAI.velocity	iastarai.html#velocity	Actual velocity that the agent is moving with. \n\nIn world units per second.\n\n[more in online documentation]
Pathfinding.IGraphInternals.SerializedEditorSettings	igraphinternals.html#SerializedEditorSettings	
Pathfinding.IGraphUpdatePromise.Progress	igraphupdatepromise.html#Progress	Returns the progress of the update. \n\nThis should be a value between 0 and 1.
Pathfinding.IOffMeshLinkHandler.name	ioffmeshlinkhandler.html#name	Name of the handler. \n\nThis is used to identify the handler in the inspector.
Pathfinding.IPathInternals.PathHandler	ipathinternals.html#PathHandler	
Pathfinding.IPathInternals.Pooled	ipathinternals.html#Pooled	
Pathfinding.IPathModifier.Order	ipathmodifier.html#Order	
Pathfinding.ITransformedGraph.transform	itransformedgraph.html#transform	
Pathfinding.ITraversalProvider.filterDiagonalGridConnections	itraversalprovider.html#filterDiagonalGridConnections	Filter diagonal connections using GridGraph.cutCorners for effects applied by this ITraversalProvider. \n\nThis includes tags and other effects that this ITraversalProvider controls.\n\nThis only has an effect if GridGraph.cutCorners is set to false and your grid has GridGraph.neighbours set to Eight.\n\nTake this example, the grid is completely walkable, but an ITraversalProvider is used to make the nodes marked with '#' as unwalkable. The agent 'S' is in the middle.\n\n<b>[code in online documentation]</b>\n\nIf <b>filterDiagonalGridConnections</b> is false the agent will be free to use the diagonal connections to move away from that spot. However, if <b>filterDiagonalGridConnections</b> is true (the default) then the diagonal connections will be disabled and the agent will be stuck.\n\nTypically, there are a few common use cases:\n- If your ITraversalProvider makes walls and obstacles and you want it to behave identically to obstacles included in the original grid graph scan, then this should be true.\n\n- If your ITraversalProvider is used for agent to agent avoidance and you want them to be able to move around each other more freely, then this should be false.\n\n\n\n[more in online documentation]
Pathfinding.InspectorGridHexagonNodeSize	pathfinding.html#InspectorGridHexagonNodeSize	
Pathfinding.InspectorGridMode	pathfinding.html#InspectorGridMode	
Pathfinding.Int3.FloatPrecision	int3.html#FloatPrecision	Precision as a float
Pathfinding.Int3.Precision	int3.html#Precision	Precision for the integer coordinates. \n\nOne world unit is divided into [value] pieces. A value of 1000 would mean millimeter precision, a value of 1 would mean meter precision (assuming 1 world unit = 1 meter). This value affects the maximum coordinates for nodes as well as how large the cost values are for moving between two nodes. A higher value means that you also have to set all penalty values to a higher value to compensate since the normal cost of moving will be higher.
Pathfinding.Int3.PrecisionFactor	int3.html#PrecisionFactor	1 divided by Precision
Pathfinding.Int3.costMagnitude	int3.html#costMagnitude	Magnitude used for the cost between two nodes. \n\nThe default cost between two nodes can be calculated like this: <b>[code in online documentation]</b>\n\nThis is simply the magnitude, rounded to the nearest integer
Pathfinding.Int3.magnitude	int3.html#magnitude	Returns the magnitude of the vector. \n\nThe magnitude is the 'length' of the vector from 0,0,0 to this point. Can be used for distance calculations: <b>[code in online documentation]</b>
Pathfinding.Int3.sqrMagnitude	int3.html#sqrMagnitude	The squared magnitude of the vector.
Pathfinding.Int3.sqrMagnitudeLong	int3.html#sqrMagnitudeLong	The squared magnitude of the vector.
Pathfinding.Int3.this[int i]	int3.html#thisinti	
Pathfinding.Int3.x	int3.html#x	
Pathfinding.Int3.y	int3.html#y	
Pathfinding.Int3.z	int3.html#z	
Pathfinding.Int3.zero	int3.html#zero	
Pathfinding.IntBounds.max	intbounds.html#max	
Pathfinding.IntBounds.min	intbounds.html#min	
Pathfinding.IntBounds.size	intbounds.html#size	
Pathfinding.IntBounds.volume	intbounds.html#volume	
Pathfinding.IntRect.Area	intrect.html#Area	
Pathfinding.IntRect.Height	intrect.html#Height	
Pathfinding.IntRect.Max	intrect.html#Max	
Pathfinding.IntRect.Min	intrect.html#Min	
Pathfinding.IntRect.Width	intrect.html#Width	
Pathfinding.IntRect.xmax	intrect.html#xmax	
Pathfinding.IntRect.xmin	intrect.html#xmin	
Pathfinding.IntRect.ymax	intrect.html#ymax	
Pathfinding.IntRect.ymin	intrect.html#ymin	
Pathfinding.Jobs.DisposeArena.buffer	disposearena.html#buffer	
Pathfinding.Jobs.DisposeArena.buffer2	disposearena.html#buffer2	
Pathfinding.Jobs.DisposeArena.buffer3	disposearena.html#buffer3	
Pathfinding.Jobs.DisposeArena.gcHandles	disposearena.html#gcHandles	
Pathfinding.Jobs.IJobExtensions.ManagedActionJob.handle	managedactionjob.html#handle	
Pathfinding.Jobs.IJobExtensions.ManagedJob.handle	managedjob.html#handle	
Pathfinding.Jobs.IJobParallelForBatched.allowBoundsChecks	ijobparallelforbatched.html#allowBoundsChecks	
Pathfinding.Jobs.IndexActionJob.action	indexactionjob.html#action	
Pathfinding.Jobs.IndexActionJob.length	indexactionjob.html#length	
Pathfinding.Jobs.JobAND.data	joband.html#data	
Pathfinding.Jobs.JobAND.result	joband.html#result	
Pathfinding.Jobs.JobClampHitToRay.commands	jobclamphittoray.html#commands	
Pathfinding.Jobs.JobClampHitToRay.hits	jobclamphittoray.html#hits	
Pathfinding.Jobs.JobCopy.from	jobcopy.html#from	
Pathfinding.Jobs.JobCopy.to	jobcopy.html#to	
Pathfinding.Jobs.JobCopyHits.hits	jobcopyhits.html#hits	
Pathfinding.Jobs.JobCopyHits.normals	jobcopyhits.html#normals	
Pathfinding.Jobs.JobCopyHits.points	jobcopyhits.html#points	
Pathfinding.Jobs.JobCopyHits.slice	jobcopyhits.html#slice	
Pathfinding.Jobs.JobCopyRectangle.input	jobcopyrectangle.html#input	
Pathfinding.Jobs.JobCopyRectangle.inputSlice	jobcopyrectangle.html#inputSlice	
Pathfinding.Jobs.JobCopyRectangle.output	jobcopyrectangle.html#output	
Pathfinding.Jobs.JobCopyRectangle.outputSlice	jobcopyrectangle.html#outputSlice	
Pathfinding.Jobs.JobDependencyAnalyzer.BufferOffset	jobdependencyanalyzer.html#BufferOffset	Offset to the m_Buffer field inside each NativeArray&lt;T&gt;
Pathfinding.Jobs.JobDependencyAnalyzer.ReflectionData.checkUninitializedRead	reflectiondata.html#checkUninitializedRead	
Pathfinding.Jobs.JobDependencyAnalyzer.ReflectionData.fieldNames	reflectiondata.html#fieldNames	
Pathfinding.Jobs.JobDependencyAnalyzer.ReflectionData.fieldOffsets	reflectiondata.html#fieldOffsets	
Pathfinding.Jobs.JobDependencyAnalyzer.ReflectionData.writes	reflectiondata.html#writes	
Pathfinding.Jobs.JobDependencyAnalyzer.SpanPtrOffset	jobdependencyanalyzer.html#SpanPtrOffset	
Pathfinding.Jobs.JobDependencyAnalyzer.reflectionData	jobdependencyanalyzer.html#reflectionData	
Pathfinding.Jobs.JobDependencyAnalyzerAssociated.jobCounter	jobdependencyanalyzerassociated.html#jobCounter	
Pathfinding.Jobs.JobDependencyAnalyzerAssociated.tempJobDependencyHashes	jobdependencyanalyzerassociated.html#tempJobDependencyHashes	
Pathfinding.Jobs.JobDependencyTracker.AllWritesDependency	jobdependencytracker.html#AllWritesDependency	JobHandle that represents a dependency for all jobs. \n\nAll native arrays that are written (and have been tracked by this tracker) to will have their final results in them when the returned job handle is complete.\n\n[more in online documentation]
Pathfinding.Jobs.JobDependencyTracker.JobInstance.handle	jobinstance.html#handle	
Pathfinding.Jobs.JobDependencyTracker.JobInstance.hash	jobinstance.html#hash	
Pathfinding.Jobs.JobDependencyTracker.JobOverlapCapsuleCommandDummy.commands	joboverlapcapsulecommanddummy.html#commands	
Pathfinding.Jobs.JobDependencyTracker.JobOverlapCapsuleCommandDummy.results	joboverlapcapsulecommanddummy.html#results	
Pathfinding.Jobs.JobDependencyTracker.JobOverlapSphereCommandDummy.commands	joboverlapspherecommanddummy.html#commands	
Pathfinding.Jobs.JobDependencyTracker.JobOverlapSphereCommandDummy.results	joboverlapspherecommanddummy.html#results	
Pathfinding.Jobs.JobDependencyTracker.JobRaycastCommandDummy.commands	jobraycastcommanddummy.html#commands	
Pathfinding.Jobs.JobDependencyTracker.JobRaycastCommandDummy.results	jobraycastcommanddummy.html#results	
Pathfinding.Jobs.JobDependencyTracker.JobSpherecastCommandDummy.commands	jobspherecastcommanddummy.html#commands	
Pathfinding.Jobs.JobDependencyTracker.JobSpherecastCommandDummy.results	jobspherecastcommanddummy.html#results	
Pathfinding.Jobs.JobDependencyTracker.NativeArraySlot.hasWrite	nativearrayslot.html#hasWrite	
Pathfinding.Jobs.JobDependencyTracker.NativeArraySlot.hash	nativearrayslot.html#hash	
Pathfinding.Jobs.JobDependencyTracker.NativeArraySlot.initialized	nativearrayslot.html#initialized	
Pathfinding.Jobs.JobDependencyTracker.NativeArraySlot.lastReads	nativearrayslot.html#lastReads	
Pathfinding.Jobs.JobDependencyTracker.NativeArraySlot.lastWrite	nativearrayslot.html#lastWrite	
Pathfinding.Jobs.JobDependencyTracker.arena	jobdependencytracker.html#arena	
Pathfinding.Jobs.JobDependencyTracker.dependenciesScratchBuffer	jobdependencytracker.html#dependenciesScratchBuffer	
Pathfinding.Jobs.JobDependencyTracker.forceLinearDependencies	jobdependencytracker.html#forceLinearDependencies	
Pathfinding.Jobs.JobDependencyTracker.linearDependencies	jobdependencytracker.html#linearDependencies	
Pathfinding.Jobs.JobDependencyTracker.slots	jobdependencytracker.html#slots	
Pathfinding.Jobs.JobDependencyTracker.supportsMultithreading	jobdependencytracker.html#supportsMultithreading	
Pathfinding.Jobs.JobDependencyTracker.timeSlice	jobdependencytracker.html#timeSlice	
Pathfinding.Jobs.JobHandleWithMainThreadWork.coroutine	jobhandlewithmainthreadwork.html#coroutine	
Pathfinding.Jobs.JobHandleWithMainThreadWork.tracker	jobhandlewithmainthreadwork.html#tracker	
Pathfinding.Jobs.JobMaxHitCount.hits	jobmaxhitcount.html#hits	
Pathfinding.Jobs.JobMaxHitCount.layerStride	jobmaxhitcount.html#layerStride	
Pathfinding.Jobs.JobMaxHitCount.maxHitCount	jobmaxhitcount.html#maxHitCount	
Pathfinding.Jobs.JobMaxHitCount.maxHits	jobmaxhitcount.html#maxHits	
Pathfinding.Jobs.JobMemSet.data	jobmemset.html#data	
Pathfinding.Jobs.JobMemSet.value	jobmemset.html#value	
Pathfinding.Jobs.JobParallelForBatchedExtensions.ParallelForBatchJobStruct.jobReflectionData	parallelforbatchjobstruct.html#jobReflectionData	
Pathfinding.Jobs.JobRaycastAll.JobCombineResults.maxHits	jobcombineresults.html#maxHits	
Pathfinding.Jobs.JobRaycastAll.JobCombineResults.results	jobcombineresults.html#results	
Pathfinding.Jobs.JobRaycastAll.JobCombineResults.semiResults	jobcombineresults.html#semiResults	
Pathfinding.Jobs.JobRaycastAll.JobCreateCommands.commands	jobcreatecommands.html#commands	
Pathfinding.Jobs.JobRaycastAll.JobCreateCommands.minStep	jobcreatecommands.html#minStep	
Pathfinding.Jobs.JobRaycastAll.JobCreateCommands.physicsScene	jobcreatecommands.html#physicsScene	
Pathfinding.Jobs.JobRaycastAll.JobCreateCommands.raycastHits	jobcreatecommands.html#raycastHits	
Pathfinding.Jobs.JobRaycastAll.commands	jobraycastall.html#commands	
Pathfinding.Jobs.JobRaycastAll.maxHits	jobraycastall.html#maxHits	
Pathfinding.Jobs.JobRaycastAll.minStep	jobraycastall.html#minStep	
Pathfinding.Jobs.JobRaycastAll.physicsScene	jobraycastall.html#physicsScene	
Pathfinding.Jobs.JobRaycastAll.results	jobraycastall.html#results	
Pathfinding.Jobs.JobRaycastAll.semiResults	jobraycastall.html#semiResults	
Pathfinding.Jobs.JobRotate3DArray.arr	jobrotate3darray.html#arr	
Pathfinding.Jobs.JobRotate3DArray.dx	jobrotate3darray.html#dx	
Pathfinding.Jobs.JobRotate3DArray.dz	jobrotate3darray.html#dz	
Pathfinding.Jobs.JobRotate3DArray.size	jobrotate3darray.html#size	
Pathfinding.Jobs.LinearDependencies	jobs2.html#LinearDependencies	
Pathfinding.Jobs.Slice3D.coversEverything	slice3d.html#coversEverything	True if the slice covers the whole outer array.
Pathfinding.Jobs.Slice3D.innerStrides	slice3d.html#innerStrides	
Pathfinding.Jobs.Slice3D.int	slice3d.html#int	
Pathfinding.Jobs.Slice3D.length	slice3d.html#length	
Pathfinding.Jobs.Slice3D.outerSize	slice3d.html#outerSize	
Pathfinding.Jobs.Slice3D.outerStartIndex	slice3d.html#outerStartIndex	
Pathfinding.Jobs.Slice3D.outerStrides	slice3d.html#outerStrides	
Pathfinding.Jobs.Slice3D.slice	slice3d.html#slice	
Pathfinding.Jobs.SliceActionJob.action	sliceactionjob.html#action	
Pathfinding.Jobs.SliceActionJob.slice	sliceactionjob.html#slice	
Pathfinding.Jobs.TimeSlice.Infinite	timeslice.html#Infinite	
Pathfinding.Jobs.TimeSlice.endTick	timeslice.html#endTick	
Pathfinding.Jobs.TimeSlice.expired	timeslice.html#expired	
Pathfinding.Jobs.TimeSlice.isInfinite	timeslice.html#isInfinite	
Pathfinding.LayerGridGraph.LayerCount	layergridgraph.html#LayerCount	Number of layers in the graph. \n\nFor grid graphs this is always 1, for layered grid graphs it can be higher. The nodes array has the size width*depth*layerCount.
Pathfinding.LayerGridGraph.MaxLayers	layergridgraph.html#MaxLayers	
Pathfinding.LayerGridGraph.characterHeight	layergridgraph.html#characterHeight	Nodes with a short distance to the node above it will be set unwalkable.
Pathfinding.LayerGridGraph.lastScannedDepth	layergridgraph.html#lastScannedDepth	
Pathfinding.LayerGridGraph.lastScannedWidth	layergridgraph.html#lastScannedWidth	
Pathfinding.LayerGridGraph.layerCount	layergridgraph.html#layerCount	Number of layers. \n\n[more in online documentation]
Pathfinding.LevelGridNode.AllConnectionsMask	levelgridnode.html#AllConnectionsMask	
Pathfinding.LevelGridNode.AxisAlignedConnectionsMask	levelgridnode.html#AxisAlignedConnectionsMask	
Pathfinding.LevelGridNode.ConnectionMask	levelgridnode.html#ConnectionMask	
Pathfinding.LevelGridNode.ConnectionStride	levelgridnode.html#ConnectionStride	
Pathfinding.LevelGridNode.DiagonalConnectionsMask	levelgridnode.html#DiagonalConnectionsMask	
Pathfinding.LevelGridNode.HasAnyGridConnections	levelgridnode.html#HasAnyGridConnections	True if this node has any grid connections.
Pathfinding.LevelGridNode.HasConnectionsToAllAxisAlignedNeighbours	levelgridnode.html#HasConnectionsToAllAxisAlignedNeighbours	True if the node has grid connections to all its 4 axis-aligned neighbours. \n\n[more in online documentation]
Pathfinding.LevelGridNode.HasConnectionsToAllEightNeighbours	levelgridnode.html#HasConnectionsToAllEightNeighbours	True if the node has grid connections to all its 8 neighbours. \n\n[more in online documentation]
Pathfinding.LevelGridNode.LayerCoordinateInGrid	levelgridnode.html#LayerCoordinateInGrid	Layer coordinate of the node in the grid. \n\nIf there are multiple nodes in the same (x,z) cell, then they will be stored in different layers. Together with NodeInGridIndex, you can look up the node in the nodes array <b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.LevelGridNode.MaxLayerCount	levelgridnode.html#MaxLayerCount	Maximum number of layers the layered grid graph supports. \n\nThis can be changed in the A* Inspector -&gt; Optimizations tab by enabling or disabling the ASTAR_LEVELGRIDNODE_MORE_LAYERS option.
Pathfinding.LevelGridNode.MaxNeighbours	levelgridnode.html#MaxNeighbours	
Pathfinding.LevelGridNode.NoConnection	levelgridnode.html#NoConnection	
Pathfinding.LevelGridNode._gridGraphs	levelgridnode.html#_gridGraphs	
Pathfinding.LevelGridNode.gridConnections	levelgridnode.html#gridConnections	
Pathfinding.LevelGridNode.gridGraphs	levelgridnode.html#gridGraphs	
Pathfinding.LinkGraph.LinkGraphUpdatePromise.graph	linkgraphupdatepromise.html#graph	
Pathfinding.LinkGraph.isScanned	linkgraph.html#isScanned	True if the graph has been scanned and contains nodes. \n\nGraphs are typically scanned when the game starts, but they can also be scanned manually.\n\nIf a graph has not been scanned, it does not contain any nodes and it not possible to use it for pathfinding.\n\n[more in online documentation]
Pathfinding.LinkGraph.nodeCount	linkgraph.html#nodeCount	
Pathfinding.LinkGraph.nodes	linkgraph.html#nodes	
Pathfinding.LinkGraph.persistent	linkgraph.html#persistent	True if the graph will be included when serializing graph data. \n\nIf false, the graph will be ignored when saving graph data.\n\nMost graphs are persistent, but the LinkGraph is not persistent because links are always re-created from components at runtime.
Pathfinding.LinkGraph.showInInspector	linkgraph.html#showInInspector	True if the graph should be visible in the editor. \n\nFalse is used for some internal graph types that users don't have to worry about.
Pathfinding.LinkNode.linkConcrete	linknode.html#linkConcrete	
Pathfinding.LinkNode.linkSource	linknode.html#linkSource	
Pathfinding.LinkNode.nodeInGraphIndex	linknode.html#nodeInGraphIndex	
Pathfinding.LocalSpaceGraph.graphTransform	localspacegraph.html#graphTransform	
Pathfinding.LocalSpaceGraph.originalMatrix	localspacegraph.html#originalMatrix	
Pathfinding.LocalSpaceGraph.transformation	localspacegraph.html#transformation	
Pathfinding.MeshNode.connections	meshnode.html#connections	All connections from this node. \n\n[more in online documentation]\n\n\nMay be null if the node has no connections.
Pathfinding.MonoModifier.Order	monomodifier.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.MonoModifier.seeker	monomodifier.html#seeker	
Pathfinding.MoveInCircle.ai	moveincircle.html#ai	
Pathfinding.MoveInCircle.offset	moveincircle.html#offset	Distance between the agent's current position, and the destination it will get. \n\nUse a negative value to make the agent move in the opposite direction around the circle.
Pathfinding.MoveInCircle.radius	moveincircle.html#radius	Radius of the circle.
Pathfinding.MoveInCircle.target	moveincircle.html#target	Target point to rotate around.
Pathfinding.MultiTargetPath.callbacks	multitargetpath.html#callbacks	Callbacks to call for each individual path.
Pathfinding.MultiTargetPath.chosenTarget	multitargetpath.html#chosenTarget	The closest target index (if any target was found)
Pathfinding.MultiTargetPath.endPointKnownBeforeCalculation	multitargetpath.html#endPointKnownBeforeCalculation	True if this path type has a well defined end point, even before calculation starts. \n\nThis is for example true for the ABPath type, but false for the RandomPath type.
Pathfinding.MultiTargetPath.inverted	multitargetpath.html#inverted	False if the path goes from one point to multiple targets. \n\nTrue if it goes from multiple start points to one target point
Pathfinding.MultiTargetPath.nodePaths	multitargetpath.html#nodePaths	Stores all paths to the targets. \n\nElements are null if no path was found
Pathfinding.MultiTargetPath.originalTargetPoints	multitargetpath.html#originalTargetPoints	Target points specified when creating the path. \n\nThese are not snapped to the nearest nodes
Pathfinding.MultiTargetPath.pathsForAll	multitargetpath.html#pathsForAll	If true, a path to all targets will be returned, otherwise just the one to the closest one.
Pathfinding.MultiTargetPath.targetNodeCount	multitargetpath.html#targetNodeCount	Number of target nodes left to find.
Pathfinding.MultiTargetPath.targetNodes	multitargetpath.html#targetNodes	Nearest nodes to the targetPoints.
Pathfinding.MultiTargetPath.targetPathCosts	multitargetpath.html#targetPathCosts	The cost of the calculated path for each target. \n\nWill be 0 if a path was not found.
Pathfinding.MultiTargetPath.targetPoints	multitargetpath.html#targetPoints	Target points specified when creating the path. \n\nThese are snapped to the nearest nodes
Pathfinding.MultiTargetPath.targetsFound	multitargetpath.html#targetsFound	Indicates if the target has been found. \n\nAlso true if the target cannot be reached (is in another area)
Pathfinding.MultiTargetPath.vectorPaths	multitargetpath.html#vectorPaths	Stores all vector paths to the targets. \n\nElements are null if no path was found
Pathfinding.NNConstraint.Default	nnconstraint.html#Default	The default NNConstraint. \n\nEquivalent to new NNConstraint (). This NNConstraint has settings which works for most, it only finds walkable nodes and it constrains distance set by A* Inspector -&gt; Settings -&gt; Max Nearest Node Distance\n\n[more in online documentation]
Pathfinding.NNConstraint.None	nnconstraint.html#None	Returns a constraint which does not filter the results.
Pathfinding.NNConstraint.Walkable	nnconstraint.html#Walkable	An NNConstraint which filters out unwalkable nodes. \n\nThis is the most commonly used NNConstraint.\n\nIt also constrains the nearest node to be within the distance set by A* Inspector -&gt; Settings -&gt; Max Nearest Node Distance
Pathfinding.NNConstraint.area	nnconstraint.html#area	Area ID to constrain to. \n\nWill not affect anything if less than 0 (zero) or if constrainArea is false
Pathfinding.NNConstraint.constrainArea	nnconstraint.html#constrainArea	Only treat nodes in the area area as suitable. \n\nDoes not affect anything if area is less than 0 (zero)
Pathfinding.NNConstraint.constrainDistance	nnconstraint.html#constrainDistance	Constrain distance to node. \n\nUses distance from AstarPath.maxNearestNodeDistance. If this is false, it will completely ignore the distance limit.\n\nIf there are no suitable nodes within the distance limit then the search will terminate with a null node as a result. \n\n[more in online documentation]
Pathfinding.NNConstraint.constrainTags	nnconstraint.html#constrainTags	Sets if tags should be constrained. \n\n[more in online documentation]
Pathfinding.NNConstraint.constrainWalkability	nnconstraint.html#constrainWalkability	Constrain the search to only walkable or unwalkable nodes depending on walkable.
Pathfinding.NNConstraint.distanceMetric	nnconstraint.html#distanceMetric	Determines how to measure distances to the navmesh. \n\nThe default is a euclidean distance, which works well for most things.\n\n[more in online documentation]
Pathfinding.NNConstraint.distanceXZ	nnconstraint.html#distanceXZ	if available, do an XZ check instead of checking on all axes. \n\nThe navmesh/recast graph as well as the grid/layered grid graph supports this.\n\nThis can be important on sloped surfaces. See the image below in which the closest point for each blue point is queried for:  <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.NNConstraint.graphMask	nnconstraint.html#graphMask	Graphs treated as valid to search on. \n\nThis is a bitmask meaning that bit 0 specifies whether or not the first graph in the graphs list should be able to be included in the search, bit 1 specifies whether or not the second graph should be included and so on. <b>[code in online documentation]</b><b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.NNConstraint.tags	nnconstraint.html#tags	Nodes which have any of these tags set are suitable. \n\nThis is a bitmask, i.e bit 0 indicates that tag 0 is good, bit 3 indicates tag 3 is good etc. \n\n[more in online documentation]
Pathfinding.NNConstraint.walkable	nnconstraint.html#walkable	Only search for walkable or unwalkable nodes if constrainWalkability is enabled. \n\nIf true, only walkable nodes will be searched for, otherwise only unwalkable nodes will be searched for. Does not affect anything if constrainWalkability if false.
Pathfinding.NNConstraintWithTraversalProvider.baseConstraint	nnconstraintwithtraversalprovider.html#baseConstraint	
Pathfinding.NNConstraintWithTraversalProvider.isSet	nnconstraintwithtraversalprovider.html#isSet	
Pathfinding.NNConstraintWithTraversalProvider.path	nnconstraintwithtraversalprovider.html#path	
Pathfinding.NNConstraintWithTraversalProvider.traversalProvider	nnconstraintwithtraversalprovider.html#traversalProvider	
Pathfinding.NNInfo.Empty	nninfo.html#Empty	
Pathfinding.NNInfo.clampedPosition	nninfo.html#clampedPosition	Closest point on the navmesh. \n\n[more in online documentation]
Pathfinding.NNInfo.distanceCostSqr	nninfo.html#distanceCostSqr	Cost for picking this node as the closest node. \n\nThis is typically the squared distance from the query point to position.\n\nHowever, it may be different if the NNConstraint used a different cost function. For example, if NNConstraint.distanceMetric is DistanceMetric.ClosestAsSeenFromAbove(), then this value will be the squared distance in the XZ plane.\n\nThis value is not guaranteed to be smaller or equal to the squared euclidean distance from the query point to position. In particular for a navmesh/recast graph with a DistanceMetric.ClosestAsSeenFromAboveSoft NNConstraint it may be slightly greater for some configurations. This is fine because we are only using this value for the rough distance limit performanced by AstarPath.maxNearestNodeDistance, and it's not a problem if it is slightly inaccurate.\n\n[more in online documentation]\nIf node is null, then this value is positive infinity.
Pathfinding.NNInfo.node	nninfo.html#node	Closest node. \n\nMay be null if there was no node which satisfied all constraints of the search.
Pathfinding.NNInfo.position	nninfo.html#position	Closest point on the navmesh. \n\nThis is the query position clamped to the closest point on the node.\n\nIf node is null, then this value is (+inf, +inf, +inf).
Pathfinding.NavGraph.SerializedEditorSettings	navgraph.html#SerializedEditorSettings	
Pathfinding.NavGraph.active	navgraph.html#active	Reference to the AstarPath object in the scene.
Pathfinding.NavGraph.bounds	navgraph.html#bounds	World bounding box for the graph. \n\nThis always contains the whole graph.\n\n[more in online documentation]\nIt is ok for a graph type to return an infinitely large bounding box, but this may make some operations less efficient. The point graph will always return an infinitely large bounding box.
Pathfinding.NavGraph.drawGizmos	navgraph.html#drawGizmos	Enable to draw gizmos in the Unity scene view. \n\nIn the inspector this value corresponds to the state of the 'eye' icon in the top left corner of every graph inspector.
Pathfinding.NavGraph.exists	navgraph.html#exists	True if the graph exists, false if it has been destroyed.
Pathfinding.NavGraph.graphIndex	navgraph.html#graphIndex	Index of the graph, used for identification purposes.
Pathfinding.NavGraph.guid	navgraph.html#guid	Used as an ID of the graph, considered to be unique. \n\n[more in online documentation]
Pathfinding.NavGraph.infoScreenOpen	navgraph.html#infoScreenOpen	Used in the editor to check if the info screen is open. \n\nShould be inside UNITY_EDITOR only #ifs but just in case anyone tries to serialize a NavGraph instance using Unity, I have left it like this as it would otherwise cause a crash when building. Version 3.0.8.1 was released because of this bug only
Pathfinding.NavGraph.initialPenalty	navgraph.html#initialPenalty	Default penalty to apply to all nodes. \n\n[more in online documentation]
Pathfinding.NavGraph.isScanned	navgraph.html#isScanned	True if the graph has been scanned and contains nodes. \n\nGraphs are typically scanned when the game starts, but they can also be scanned manually.\n\nIf a graph has not been scanned, it does not contain any nodes and it not possible to use it for pathfinding.\n\n[more in online documentation]
Pathfinding.NavGraph.name	navgraph.html#name	Name of the graph. \n\nCan be set in the unity editor
Pathfinding.NavGraph.open	navgraph.html#open	Is the graph open in the editor.
Pathfinding.NavGraph.persistent	navgraph.html#persistent	True if the graph will be included when serializing graph data. \n\nIf false, the graph will be ignored when saving graph data.\n\nMost graphs are persistent, but the LinkGraph is not persistent because links are always re-created from components at runtime.
Pathfinding.NavGraph.serializedEditorSettings	navgraph.html#serializedEditorSettings	Used in the Unity editor to store serialized settings for graph inspectors.
Pathfinding.NavGraph.showInInspector	navgraph.html#showInInspector	True if the graph should be visible in the editor. \n\nFalse is used for some internal graph types that users don't have to worry about.
Pathfinding.NavMeshGraph.MaxTileConnectionEdgeDistance	navmeshgraph.html#MaxTileConnectionEdgeDistance	Maximum (vertical) distance between the sides of two nodes for them to be connected across a tile edge. \n\nWhen tiles are connected to each other, the nodes sometimes do not line up perfectly so some allowance must be made to allow tiles that do not match exactly to be connected with each other.
Pathfinding.NavMeshGraph.NavMeshGraphScanPromise.cutSettings	navmeshgraphscanpromise.html#cutSettings	
Pathfinding.NavMeshGraph.NavMeshGraphScanPromise.emptyGraph	navmeshgraphscanpromise.html#emptyGraph	
Pathfinding.NavMeshGraph.NavMeshGraphScanPromise.forcedBoundsSize	navmeshgraphscanpromise.html#forcedBoundsSize	
Pathfinding.NavMeshGraph.NavMeshGraphScanPromise.graph	navmeshgraphscanpromise.html#graph	
Pathfinding.NavMeshGraph.NavMeshGraphScanPromise.tileRect	navmeshgraphscanpromise.html#tileRect	
Pathfinding.NavMeshGraph.NavMeshGraphScanPromise.tiles	navmeshgraphscanpromise.html#tiles	
Pathfinding.NavMeshGraph.NavMeshGraphScanPromise.transform	navmeshgraphscanpromise.html#transform	
Pathfinding.NavMeshGraph.NavMeshGraphUpdatePromise.graph	navmeshgraphupdatepromise.html#graph	
Pathfinding.NavMeshGraph.NavMeshGraphUpdatePromise.graphUpdates	navmeshgraphupdatepromise.html#graphUpdates	
Pathfinding.NavMeshGraph.NavmeshCuttingCharacterRadius	navmeshgraph.html#NavmeshCuttingCharacterRadius	
Pathfinding.NavMeshGraph.RecalculateNormals	navmeshgraph.html#RecalculateNormals	Determines how normals are calculated. \n\nDisable for spherical graphs or other complicated surfaces that allow the agents to e.g walk on walls or ceilings.\n\nBy default the normals of the mesh will be flipped so that they point as much as possible in the upwards direction. The normals are important when connecting adjacent nodes. Two adjacent nodes will only be connected if they are oriented the same way. This is particularly important if you have a navmesh on the walls or even on the ceiling of a room. Or if you are trying to make a spherical navmesh. If you do one of those things then you should set disable this setting and make sure the normals in your source mesh are properly set.\n\nIf you for example take a look at the image below. In the upper case then the nodes on the bottom half of the mesh haven't been connected with the nodes on the upper half because the normals on the lower half will have been modified to point inwards (as that is the direction that makes them face upwards the most) while the normals on the upper half point outwards. This causes the nodes to not connect properly along the seam. When this option is set to false instead the nodes are connected properly as in the original mesh all normals point outwards.  <b>[image in online documentation]</b>\n\nThe default value of this field is true to reduce the risk for errors in the common case. If a mesh is supplied that has all normals pointing downwards and this option is false, then some methods like PointOnNavmesh will not work correctly as they assume that the normals point upwards. For a more complicated surface like a spherical graph those methods make no sense anyway as there is no clear definition of what it means to be "inside" a triangle when there is no clear up direction.
Pathfinding.NavMeshGraph.TileWorldSizeX	navmeshgraph.html#TileWorldSizeX	Size of a tile in world units along the X axis.
Pathfinding.NavMeshGraph.TileWorldSizeZ	navmeshgraph.html#TileWorldSizeZ	Size of a tile in world units along the Z axis.
Pathfinding.NavMeshGraph.bounds	navmeshgraph.html#bounds	World bounding box for the graph. \n\nThis always contains the whole graph.\n\n[more in online documentation]\nIf no mesh has been assigned, this will return a zero sized bounding box at the origin.\n\n <b>[image in online documentation]</b>
Pathfinding.NavMeshGraph.cachedSourceMeshBoundsMin	navmeshgraph.html#cachedSourceMeshBoundsMin	Cached bounding box minimum of sourceMesh. \n\nThis is important when the graph has been saved to a file and is later loaded again, but the original mesh does not exist anymore (or has been moved). In that case we still need to be able to find the bounding box since the CalculateTransform method uses it.
Pathfinding.NavMeshGraph.navmeshCuttingCharacterRadius	navmeshgraph.html#navmeshCuttingCharacterRadius	Radius to use when expanding navmesh cuts. \n\n[more in online documentation]
Pathfinding.NavMeshGraph.offset	navmeshgraph.html#offset	Offset in world space.
Pathfinding.NavMeshGraph.recalculateNormals	navmeshgraph.html#recalculateNormals	Determines how normals are calculated. \n\nDisable for spherical graphs or other complicated surfaces that allow the agents to e.g walk on walls or ceilings.\n\nBy default the normals of the mesh will be flipped so that they point as much as possible in the upwards direction. The normals are important when connecting adjacent nodes. Two adjacent nodes will only be connected if they are oriented the same way. This is particularly important if you have a navmesh on the walls or even on the ceiling of a room. Or if you are trying to make a spherical navmesh. If you do one of those things then you should set disable this setting and make sure the normals in your source mesh are properly set.\n\nIf you for example take a look at the image below. In the upper case then the nodes on the bottom half of the mesh haven't been connected with the nodes on the upper half because the normals on the lower half will have been modified to point inwards (as that is the direction that makes them face upwards the most) while the normals on the upper half point outwards. This causes the nodes to not connect properly along the seam. When this option is set to false instead the nodes are connected properly as in the original mesh all normals point outwards.  <b>[image in online documentation]</b>\n\nThe default value of this field is true to reduce the risk for errors in the common case. If a mesh is supplied that has all normals pointing downwards and this option is false, then some methods like PointOnNavmesh will not work correctly as they assume that the normals point upwards. For a more complicated surface like a spherical graph those methods make no sense anyway as there is no clear definition of what it means to be "inside" a triangle when there is no clear up direction.
Pathfinding.NavMeshGraph.rotation	navmeshgraph.html#rotation	Rotation in degrees.
Pathfinding.NavMeshGraph.scale	navmeshgraph.html#scale	Scale of the graph.
Pathfinding.NavMeshGraph.sourceMesh	navmeshgraph.html#sourceMesh	Mesh to construct navmesh from.
Pathfinding.NavmeshAdd.Center	navmeshadd.html#Center	
Pathfinding.NavmeshAdd.GizmoColor	navmeshadd.html#GizmoColor	
Pathfinding.NavmeshAdd.MeshType	navmeshadd.html#MeshType	
Pathfinding.NavmeshAdd.center	navmeshadd.html#center	
Pathfinding.NavmeshAdd.gizmoBuffer	navmeshadd.html#gizmoBuffer	
Pathfinding.NavmeshAdd.mesh	navmeshadd.html#mesh	Custom mesh to use. \n\nThe contour(s) of the mesh will be extracted. If you get the "max perturbations" error when cutting with this, check the normals on the mesh. They should all point in the same direction. Try flipping them if that does not help.
Pathfinding.NavmeshAdd.meshScale	navmeshadd.html#meshScale	
Pathfinding.NavmeshAdd.rectangleSize	navmeshadd.html#rectangleSize	Size of the rectangle.
Pathfinding.NavmeshAdd.tr	navmeshadd.html#tr	cached transform component
Pathfinding.NavmeshAdd.tris	navmeshadd.html#tris	Cached triangles.
Pathfinding.NavmeshAdd.type	navmeshadd.html#type	
Pathfinding.NavmeshAdd.updateDistance	navmeshadd.html#updateDistance	Distance between positions to require an update of the navmesh. \n\nA smaller distance gives better accuracy, but requires more updates when moving the object over time, so it is often slower.
Pathfinding.NavmeshAdd.updateRotationDistance	navmeshadd.html#updateRotationDistance	How many degrees rotation that is required for an update to the navmesh. \n\nShould be between 0 and 180.
Pathfinding.NavmeshAdd.useRotationAndScale	navmeshadd.html#useRotationAndScale	Includes rotation and scale in calculations. \n\nThis is slower since a lot more matrix multiplications are needed but gives more flexibility.
Pathfinding.NavmeshAdd.verts	navmeshadd.html#verts	Cached vertices.
Pathfinding.NavmeshBase.LinecastShapeEdgeLookup	navmeshbase.html#LinecastShapeEdgeLookup	Used to optimize linecasts by precomputing some values.
Pathfinding.NavmeshBase.MaxTileConnectionEdgeDistance	navmeshbase.html#MaxTileConnectionEdgeDistance	Maximum (vertical) distance between the sides of two nodes for them to be connected across a tile edge. \n\nWhen tiles are connected to each other, the nodes sometimes do not line up perfectly so some allowance must be made to allow tiles that do not match exactly to be connected with each other.
Pathfinding.NavmeshBase.NNConstraintNoneXZ	navmeshbase.html#NNConstraintNoneXZ	Cached NNConstraint.None with distanceXZ=true to reduce allocations.
Pathfinding.NavmeshBase.NavmeshCuttingCharacterRadius	navmeshbase.html#NavmeshCuttingCharacterRadius	
Pathfinding.NavmeshBase.OnRecalculatedTiles	navmeshbase.html#OnRecalculatedTiles	Called when tiles have been completely recalculated. \n\nThis is called after scanning the graph and after performing graph updates that completely recalculate tiles (not ones that simply modify e.g penalties). It is not called after NavmeshCut updates.
Pathfinding.NavmeshBase.RecalculateNormals	navmeshbase.html#RecalculateNormals	Determines how normals are calculated. \n\nDisable for spherical graphs or other complicated surfaces that allow the agents to e.g walk on walls or ceilings.\n\nBy default the normals of the mesh will be flipped so that they point as much as possible in the upwards direction. The normals are important when connecting adjacent nodes. Two adjacent nodes will only be connected if they are oriented the same way. This is particularly important if you have a navmesh on the walls or even on the ceiling of a room. Or if you are trying to make a spherical navmesh. If you do one of those things then you should set disable this setting and make sure the normals in your source mesh are properly set.\n\nIf you for example take a look at the image below. In the upper case then the nodes on the bottom half of the mesh haven't been connected with the nodes on the upper half because the normals on the lower half will have been modified to point inwards (as that is the direction that makes them face upwards the most) while the normals on the upper half point outwards. This causes the nodes to not connect properly along the seam. When this option is set to false instead the nodes are connected properly as in the original mesh all normals point outwards.  <b>[image in online documentation]</b>\n\nThe default value of this field is true to reduce the risk for errors in the common case. If a mesh is supplied that has all normals pointing downwards and this option is false, then some methods like PointOnNavmesh will not work correctly as they assume that the normals point upwards. For a more complicated surface like a spherical graph those methods make no sense anyway as there is no clear definition of what it means to be "inside" a triangle when there is no clear up direction.
Pathfinding.NavmeshBase.TileIndexMask	navmeshbase.html#TileIndexMask	
Pathfinding.NavmeshBase.TileIndexOffset	navmeshbase.html#TileIndexOffset	
Pathfinding.NavmeshBase.TileWorldSizeX	navmeshbase.html#TileWorldSizeX	Size of a tile in world units along the X axis.
Pathfinding.NavmeshBase.TileWorldSizeZ	navmeshbase.html#TileWorldSizeZ	Size of a tile in world units along the Z axis.
Pathfinding.NavmeshBase.VertexIndexMask	navmeshbase.html#VertexIndexMask	
Pathfinding.NavmeshBase.batchNodesToDestroy	navmeshbase.html#batchNodesToDestroy	List of nodes that are going to be destroyed as part of a batch update.
Pathfinding.NavmeshBase.batchPendingNavmeshCutting	navmeshbase.html#batchPendingNavmeshCutting	True if the current batch of tile updates requires navmesh cutting to be done.
Pathfinding.NavmeshBase.batchTileUpdate	navmeshbase.html#batchTileUpdate	Positive if currently updating tiles in a batch.
Pathfinding.NavmeshBase.batchUpdatedTiles	navmeshbase.html#batchUpdatedTiles	List of tiles updating during batch.
Pathfinding.NavmeshBase.enableNavmeshCutting	navmeshbase.html#enableNavmeshCutting	Should navmesh cuts affect this graph. \n\n[more in online documentation]
Pathfinding.NavmeshBase.forcedBoundsSize	navmeshbase.html#forcedBoundsSize	Size of the bounding box.
Pathfinding.NavmeshBase.isScanned	navmeshbase.html#isScanned	True if the graph has been scanned and contains nodes. \n\nGraphs are typically scanned when the game starts, but they can also be scanned manually.\n\nIf a graph has not been scanned, it does not contain any nodes and it not possible to use it for pathfinding.\n\n[more in online documentation]
Pathfinding.NavmeshBase.navmeshUpdateData	navmeshbase.html#navmeshUpdateData	Handles navmesh cutting. \n\n[more in online documentation]
Pathfinding.NavmeshBase.nearestSearchOnlyXZ	navmeshbase.html#nearestSearchOnlyXZ	Perform nearest node searches in XZ space only. \n\nRecomended for single-layered environments. Faster but can be inaccurate esp. in multilayered contexts. You should not use this if the graph is rotated since then the XZ plane no longer corresponds to the ground plane.\n\nThis can be important on sloped surfaces. See the image below in which the closest point for each blue point is queried for:  <b>[image in online documentation]</b>\n\nYou can also control this using a field on an NNConstraint object.\n\n[more in online documentation]
Pathfinding.NavmeshBase.nodeRecyclingHashBuffer	navmeshbase.html#nodeRecyclingHashBuffer	Temporary buffer used in PrepareNodeRecycling.
Pathfinding.NavmeshBase.showMeshOutline	navmeshbase.html#showMeshOutline	Show an outline of the polygons in the Unity Editor. \n\n <b>[image in online documentation]</b>
Pathfinding.NavmeshBase.showMeshSurface	navmeshbase.html#showMeshSurface	Show the surface of the navmesh. \n\n <b>[image in online documentation]</b>
Pathfinding.NavmeshBase.showNodeConnections	navmeshbase.html#showNodeConnections	Show the connections between the polygons in the Unity Editor. \n\n <b>[image in online documentation]</b>
Pathfinding.NavmeshBase.tileXCount	navmeshbase.html#tileXCount	Number of tiles along the X-axis.
Pathfinding.NavmeshBase.tileZCount	navmeshbase.html#tileZCount	Number of tiles along the Z-axis.
Pathfinding.NavmeshBase.tiles	navmeshbase.html#tiles	All tiles. \n\n[more in online documentation]
Pathfinding.NavmeshBase.transform	navmeshbase.html#transform	Determines how the graph transforms graph space to world space. \n\n[more in online documentation]
Pathfinding.NavmeshClamp.prevNode	navmeshclamp.html#prevNode	
Pathfinding.NavmeshClamp.prevPos	navmeshclamp.html#prevPos	
Pathfinding.NavmeshClipper.OnDisableCallback	navmeshclipper.html#OnDisableCallback	Called every time a NavmeshCut/NavmeshAdd component is disabled.
Pathfinding.NavmeshClipper.OnEnableCallback	navmeshclipper.html#OnEnableCallback	Called every time a NavmeshCut/NavmeshAdd component is enabled.
Pathfinding.NavmeshClipper.all	navmeshclipper.html#all	
Pathfinding.NavmeshClipper.allEnabled	navmeshclipper.html#allEnabled	All navmesh clipper components in the scene. \n\nNot ordered in any particular way. \n\n[more in online documentation]
Pathfinding.NavmeshClipper.graphMask	navmeshclipper.html#graphMask	Which graphs that are affected by this component. \n\nYou can use this to make a graph ignore a particular navmesh cut altogether.\n\nNote that navmesh cuts can only affect navmesh/recast graphs.\n\nIf you change this field during runtime you must disable the component and enable it again for the changes to be detected.\n\n[more in online documentation]
Pathfinding.NavmeshClipper.listIndex	navmeshclipper.html#listIndex	
Pathfinding.NavmeshCut.Contour.contour	contour.html#contour	
Pathfinding.NavmeshCut.Contour.ymax	contour.html#ymax	
Pathfinding.NavmeshCut.Contour.ymin	contour.html#ymin	
Pathfinding.NavmeshCut.ContourBurst.endIndex	contourburst.html#endIndex	
Pathfinding.NavmeshCut.ContourBurst.startIndex	contourburst.html#startIndex	
Pathfinding.NavmeshCut.ContourBurst.ymax	contourburst.html#ymax	
Pathfinding.NavmeshCut.ContourBurst.ymin	contourburst.html#ymin	
Pathfinding.NavmeshCut.GizmoColor	navmeshcut.html#GizmoColor	
Pathfinding.NavmeshCut.GizmoColor2	navmeshcut.html#GizmoColor2	
Pathfinding.NavmeshCut.MeshType	navmeshcut.html#MeshType	
Pathfinding.NavmeshCut.RadiusExpansionMode	navmeshcut.html#RadiusExpansionMode	
Pathfinding.NavmeshCut.center	navmeshcut.html#center	
Pathfinding.NavmeshCut.circleRadius	navmeshcut.html#circleRadius	Radius of the circle.
Pathfinding.NavmeshCut.circleResolution	navmeshcut.html#circleResolution	Number of vertices on the circle.
Pathfinding.NavmeshCut.contourTransformationMatrix	navmeshcut.html#contourTransformationMatrix	
Pathfinding.NavmeshCut.cutsAddedGeom	navmeshcut.html#cutsAddedGeom	Cuts geometry added by a NavmeshAdd component. \n\nYou rarely need to change this
Pathfinding.NavmeshCut.edges	navmeshcut.html#edges	Cached variable, to avoid allocations.
Pathfinding.NavmeshCut.height	navmeshcut.html#height	The cut will be extruded to this height.
Pathfinding.NavmeshCut.isDual	navmeshcut.html#isDual	Only makes a split in the navmesh, but does not remove the geometry to make a hole. \n\nThis is slower than a normal cut
Pathfinding.NavmeshCut.lastMesh	navmeshcut.html#lastMesh	
Pathfinding.NavmeshCut.mesh	navmeshcut.html#mesh	Custom mesh to use. \n\nThe contour(s) of the mesh will be extracted. If you get the "max perturbations" error when cutting with this, check the normals on the mesh. They should all point in the same direction. Try flipping them if that does not help.\n\nThis mesh should only be a 2D surface, not a volume.
Pathfinding.NavmeshCut.meshContourVertices	navmeshcut.html#meshContourVertices	
Pathfinding.NavmeshCut.meshContours	navmeshcut.html#meshContours	
Pathfinding.NavmeshCut.meshScale	navmeshcut.html#meshScale	Scale of the custom mesh, if used.
Pathfinding.NavmeshCut.pointers	navmeshcut.html#pointers	Cached variable, to avoid allocations.
Pathfinding.NavmeshCut.radiusExpansionMode	navmeshcut.html#radiusExpansionMode	If the cut should be expanded by the agent radius or not. \n\nSee RadiusExpansionMode for more details.
Pathfinding.NavmeshCut.rectangleSize	navmeshcut.html#rectangleSize	Size of the rectangle.
Pathfinding.NavmeshCut.tr	navmeshcut.html#tr	cached transform component
Pathfinding.NavmeshCut.type	navmeshcut.html#type	Shape of the cut.
Pathfinding.NavmeshCut.updateDistance	navmeshcut.html#updateDistance	How much the cut must move before the navmesh is updated. \n\nA smaller distance gives better accuracy, but requires more updates when moving the object over time, so it is often slower.\n\nEven if the graph update itself is fast, having a low value can make agents have to recalculate their paths a lot more often, leading to lower performance.
Pathfinding.NavmeshCut.updateRotationDistance	navmeshcut.html#updateRotationDistance	How many degrees the object must rotate before the navmesh is updated. \n\nShould be between 0 and 180.
Pathfinding.NavmeshCut.useRotationAndScale	navmeshcut.html#useRotationAndScale	Includes rotation and scale in calculations. \n\nIf this is disabled, the object's rotation and scale is not taken into account when determining the shape of the cut.\n\nEnabling this is a bit slower, since a lot more matrix multiplications are needed.
Pathfinding.NavmeshCutEditor.MeshTypeOptions	navmeshcuteditor.html#MeshTypeOptions	
Pathfinding.NavmeshCutJobs.AngleComparator.origin	anglecomparator.html#origin	
Pathfinding.NavmeshCutJobs.BoxCorners	navmeshcutjobs.html#BoxCorners	
Pathfinding.NavmeshCutJobs.JobCalculateContour.circleRadius	jobcalculatecontour.html#circleRadius	
Pathfinding.NavmeshCutJobs.JobCalculateContour.circleResolution	jobcalculatecontour.html#circleResolution	
Pathfinding.NavmeshCutJobs.JobCalculateContour.height	jobcalculatecontour.html#height	
Pathfinding.NavmeshCutJobs.JobCalculateContour.localToWorldMatrix	jobcalculatecontour.html#localToWorldMatrix	
Pathfinding.NavmeshCutJobs.JobCalculateContour.matrix	jobcalculatecontour.html#matrix	
Pathfinding.NavmeshCutJobs.JobCalculateContour.meshContourVertices	jobcalculatecontour.html#meshContourVertices	
Pathfinding.NavmeshCutJobs.JobCalculateContour.meshContours	jobcalculatecontour.html#meshContours	
Pathfinding.NavmeshCutJobs.JobCalculateContour.meshScale	jobcalculatecontour.html#meshScale	
Pathfinding.NavmeshCutJobs.JobCalculateContour.meshType	jobcalculatecontour.html#meshType	
Pathfinding.NavmeshCutJobs.JobCalculateContour.outputContours	jobcalculatecontour.html#outputContours	
Pathfinding.NavmeshCutJobs.JobCalculateContour.outputVertices	jobcalculatecontour.html#outputVertices	
Pathfinding.NavmeshCutJobs.JobCalculateContour.radiusMargin	jobcalculatecontour.html#radiusMargin	
Pathfinding.NavmeshCutJobs.JobCalculateContour.rectangleSize	jobcalculatecontour.html#rectangleSize	
Pathfinding.NavmeshEdges.JobCalculateObstacles.MarkerBBox	jobcalculateobstacles.html#MarkerBBox	
Pathfinding.NavmeshEdges.JobCalculateObstacles.MarkerCollect	jobcalculateobstacles.html#MarkerCollect	
Pathfinding.NavmeshEdges.JobCalculateObstacles.MarkerObstacles	jobcalculateobstacles.html#MarkerObstacles	
Pathfinding.NavmeshEdges.JobCalculateObstacles.MarkerTrace	jobcalculateobstacles.html#MarkerTrace	
Pathfinding.NavmeshEdges.JobCalculateObstacles.allocationLock	jobcalculateobstacles.html#allocationLock	
Pathfinding.NavmeshEdges.JobCalculateObstacles.bounds	jobcalculateobstacles.html#bounds	
Pathfinding.NavmeshEdges.JobCalculateObstacles.dirtyHierarchicalNodes	jobcalculateobstacles.html#dirtyHierarchicalNodes	
Pathfinding.NavmeshEdges.JobCalculateObstacles.hGraphGC	jobcalculateobstacles.html#hGraphGC	
Pathfinding.NavmeshEdges.JobCalculateObstacles.obstacleVertexGroups	jobcalculateobstacles.html#obstacleVertexGroups	
Pathfinding.NavmeshEdges.JobCalculateObstacles.obstacleVertices	jobcalculateobstacles.html#obstacleVertices	
Pathfinding.NavmeshEdges.JobCalculateObstacles.obstacles	jobcalculateobstacles.html#obstacles	
Pathfinding.NavmeshEdges.JobRecalculateObstaclesBatchCount	navmeshedges.html#JobRecalculateObstaclesBatchCount	
Pathfinding.NavmeshEdges.JobResizeObstacles.numHierarchicalNodes	jobresizeobstacles.html#numHierarchicalNodes	
Pathfinding.NavmeshEdges.JobResizeObstacles.obstacles	jobresizeobstacles.html#obstacles	
Pathfinding.NavmeshEdges.NavmeshBorderData.hierarhicalNodeData	navmeshborderdata.html#hierarhicalNodeData	
Pathfinding.NavmeshEdges.NavmeshBorderData.obstacleData	navmeshborderdata.html#obstacleData	
Pathfinding.NavmeshEdges.allocationLock	navmeshedges.html#allocationLock	
Pathfinding.NavmeshEdges.gizmoVersion	navmeshedges.html#gizmoVersion	
Pathfinding.NavmeshEdges.hierarchicalGraph	navmeshedges.html#hierarchicalGraph	
Pathfinding.NavmeshEdges.obstacleData	navmeshedges.html#obstacleData	
Pathfinding.NavmeshEdges.rwLock	navmeshedges.html#rwLock	
Pathfinding.NavmeshPrefab.SerializeJob.output	serializejob.html#output	
Pathfinding.NavmeshPrefab.SerializeJob.tileMeshesPromise	serializejob.html#tileMeshesPromise	
Pathfinding.NavmeshPrefab.SerializedOutput.Progress	serializedoutput.html#Progress	
Pathfinding.NavmeshPrefab.SerializedOutput.arena	serializedoutput.html#arena	
Pathfinding.NavmeshPrefab.SerializedOutput.data	serializedoutput.html#data	
Pathfinding.NavmeshPrefab.SerializedOutput.promise	serializedoutput.html#promise	
Pathfinding.NavmeshPrefab.applyOnStart	navmeshprefab.html#applyOnStart	If true, the tiles stored in this prefab will be loaded and applied to the first recast graph in the scene when this component is enabled. \n\nIf false, you will have to call the Apply(RecastGraph) method manually.\n\nIf this component is disabled and then enabled again, the tiles will be reloaded.
Pathfinding.NavmeshPrefab.bounds	navmeshprefab.html#bounds	Bounding box for the navmesh to be stored in this prefab. \n\nShould be a multiple of the tile size of the associated recast graph.\n\n[more in online documentation]
Pathfinding.NavmeshPrefab.removeTilesWhenDisabled	navmeshprefab.html#removeTilesWhenDisabled	If true, the tiles that this prefab loaded into the graph will be removed when this component is disabled or destroyed. \n\nIf false, the tiles will remain in the graph.
Pathfinding.NavmeshPrefab.serializedNavmesh	navmeshprefab.html#serializedNavmesh	Reference to the serialized tile data.
Pathfinding.NavmeshPrefab.startHasRun	navmeshprefab.html#startHasRun	
Pathfinding.NavmeshPrefabEditor.pendingScanProgressId	navmeshprefabeditor.html#pendingScanProgressId	
Pathfinding.NodeLink.End	nodelink.html#End	
Pathfinding.NodeLink.Start	nodelink.html#Start	
Pathfinding.NodeLink.costFactor	nodelink.html#costFactor	The connection will be this times harder/slower to traverse. \n\nNote that values lower than one will not always make the pathfinder choose this path instead of another path even though this one should lead to a lower total cost unless you also adjust the Heuristic Scale in A* Inspector -&gt; Settings -&gt; Pathfinding or disable the heuristic altogether.
Pathfinding.NodeLink.deleteConnection	nodelink.html#deleteConnection	Delete existing connection instead of adding one.
Pathfinding.NodeLink.end	nodelink.html#end	End position of the link.
Pathfinding.NodeLink.oneWay	nodelink.html#oneWay	Make a one-way connection.
Pathfinding.NodeLink2.EndTransform	nodelink2.html#EndTransform	
Pathfinding.NodeLink2.GizmosColor	nodelink2.html#GizmosColor	
Pathfinding.NodeLink2.GizmosColorSelected	nodelink2.html#GizmosColorSelected	
Pathfinding.NodeLink2.StartTransform	nodelink2.html#StartTransform	
Pathfinding.NodeLink2.costFactor	nodelink2.html#costFactor	The connection will be this times harder/slower to traverse. \n\nA cost factor of 1 means that the link is equally expensive as moving the same distance on the normal navmesh. But a cost factor greater than 1 means that it is proportionally more expensive.\n\nYou should not use a cost factor less than 1 unless you also change the AstarPath.heuristicScale field (A* Inspector -&gt; Settings -&gt; Pathfinding) to at most the minimum cost factor that you use anywhere in the scene (or disable the heuristic altogether). This is because the pathfinding algorithm assumes that paths are at least as costly as walking just the straight line distance to the target, and if you use a cost factor less than 1, that assumption is no longer true. What then happens is that the pathfinding search may ignore some links because it doesn't even think to search in that direction, even if they would have lead to a lower path cost.\n\n[more in online documentation]\nRead more about this at <a href="https://en.wikipedia.org/wiki/Admissible_heuristic">https://en.wikipedia.org/wiki/Admissible_heuristic</a>.
Pathfinding.NodeLink2.end	nodelink2.html#end	End position of the link.
Pathfinding.NodeLink2.graphMask	nodelink2.html#graphMask	Which graphs this link is allowed to connect. \n\nThe link will always connect the nodes closest to the start and end points on the graphs that it is allowed to connect.
Pathfinding.NodeLink2.isActive	nodelink2.html#isActive	True if the link is connected to the graph. \n\nThis will be true if the link has been successfully connected to the graph, and false if it either has failed, or if the component/gameobject is disabled.\n\nWhen the component is enabled, the link will be scheduled to be added to the graph, it will not take effect immediately. This means that this property will return false until the next time graph updates are processed (usually later this frame, or next frame). To ensure the link is refreshed immediately, you can call AstarPath.active.FlushWorkItems.
Pathfinding.NodeLink2.linkSource	nodelink2.html#linkSource	
Pathfinding.NodeLink2.onTraverseOffMeshLink	nodelink2.html#onTraverseOffMeshLink	Callback to be called when an agent starts traversing an off-mesh link. \n\nThe handler will be called when the agent starts traversing an off-mesh link. It allows you to to control the agent for the full duration of the link traversal.\n\nUse the passed context struct to get information about the link and to control the agent.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]\nYou can alternatively set the corresponding property property on the agent ( FollowerEntity.onTraverseOffMeshLink) to specify a callback for a all off-mesh links.\n\n[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.NodeLink2.onTraverseOffMeshLinkHandler	nodelink2.html#onTraverseOffMeshLinkHandler	
Pathfinding.NodeLink2.oneWay	nodelink2.html#oneWay	Make a one-way connection.
Pathfinding.NodeLink2.pathfindingTag	nodelink2.html#pathfindingTag	The tag to apply to the link. \n\nThis can be used to exclude certain agents from using the link, or make it more expensive to use.\n\n[more in online documentation]
Pathfinding.NodeLink2Editor.HandlerContent	nodelink2editor.html#HandlerContent	
Pathfinding.NodeLink3.EndNode	nodelink3.html#EndNode	
Pathfinding.NodeLink3.EndTransform	nodelink3.html#EndTransform	
Pathfinding.NodeLink3.GizmosColor	nodelink3.html#GizmosColor	
Pathfinding.NodeLink3.GizmosColorSelected	nodelink3.html#GizmosColorSelected	
Pathfinding.NodeLink3.StartNode	nodelink3.html#StartNode	
Pathfinding.NodeLink3.StartTransform	nodelink3.html#StartTransform	
Pathfinding.NodeLink3.clamped1	nodelink3.html#clamped1	
Pathfinding.NodeLink3.clamped2	nodelink3.html#clamped2	
Pathfinding.NodeLink3.connectedNode1	nodelink3.html#connectedNode1	
Pathfinding.NodeLink3.connectedNode2	nodelink3.html#connectedNode2	
Pathfinding.NodeLink3.costFactor	nodelink3.html#costFactor	The connection will be this times harder/slower to traverse. \n\nNote that values lower than one will not always make the pathfinder choose this path instead of another path even though this one should lead to a lower total cost unless you also adjust the Heuristic Scale in A* Inspector -&gt; Settings -&gt; Pathfinding or disable the heuristic altogether.
Pathfinding.NodeLink3.end	nodelink3.html#end	End position of the link.
Pathfinding.NodeLink3.endNode	nodelink3.html#endNode	
Pathfinding.NodeLink3.postScanCalled	nodelink3.html#postScanCalled	
Pathfinding.NodeLink3.reference	nodelink3.html#reference	
Pathfinding.NodeLink3.startNode	nodelink3.html#startNode	
Pathfinding.NodeLink3Node.link	nodelink3node.html#link	
Pathfinding.NodeLink3Node.portalA	nodelink3node.html#portalA	
Pathfinding.NodeLink3Node.portalB	nodelink3node.html#portalB	
Pathfinding.NumNeighbours	pathfinding.html#NumNeighbours	Number of neighbours for a single grid node. \n\n[more in online documentation]
Pathfinding.OffMeshLinks.Anchor.center	anchor.html#center	Where the link connects to the navmesh.
Pathfinding.OffMeshLinks.Anchor.point1	anchor.html#point1	First point on the segment that makes up this anchor.
Pathfinding.OffMeshLinks.Anchor.point2	anchor.html#point2	Second point on the segment that makes up this anchor.
Pathfinding.OffMeshLinks.Anchor.rotation	anchor.html#rotation	Rotation that the character should align itself with when traversing the link.
Pathfinding.OffMeshLinks.Anchor.width	anchor.html#width	Width of the link. \n\n[more in online documentation]
Pathfinding.OffMeshLinks.Directionality	offmeshlinks.html#Directionality	Determines how a link is connected in the graph.
Pathfinding.OffMeshLinks.OffMeshLinkCombined.concrete	offmeshlinkcombined.html#concrete	
Pathfinding.OffMeshLinks.OffMeshLinkCombined.source	offmeshlinkcombined.html#source	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.component	offmeshlinkconcrete.html#component	The Component associated with this link. \n\nTypically this will be a NodeLink2 component. But users can also create their own components and fill out this field as appropriate.\n\nThis field is not used for anything by the pathfinding system itself, it is only used to make it easier for users to find the component associated with a link.\n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.costFactor	offmeshlinkconcrete.html#costFactor	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.directionality	offmeshlinkconcrete.html#directionality	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.end	offmeshlinkconcrete.html#end	The end of the link.
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.endLinkNode	offmeshlinkconcrete.html#endLinkNode	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.endNodes	offmeshlinkconcrete.html#endNodes	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.gameObject	offmeshlinkconcrete.html#gameObject	The GameObject associated with this link. \n\nThis field is not used for anything by the pathfinding system itself, it is only used to make it easier for users to find the GameObject associated with a link.\n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.handler	offmeshlinkconcrete.html#handler	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.source	offmeshlinkconcrete.html#source	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.staleConnections	offmeshlinkconcrete.html#staleConnections	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.start	offmeshlinkconcrete.html#start	The start of the link.
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.startLinkNode	offmeshlinkconcrete.html#startLinkNode	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.startNodes	offmeshlinkconcrete.html#startNodes	
Pathfinding.OffMeshLinks.OffMeshLinkConcrete.tag	offmeshlinkconcrete.html#tag	Tag to apply to this link. \n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkSource.bounds	offmeshlinksource.html#bounds	Bounding box which encapsulates the link and any position on the navmesh it could possibly be connected to. \n\nThis is used to determine which links need to be recalculated when a graph update happens.
Pathfinding.OffMeshLinks.OffMeshLinkSource.component	offmeshlinksource.html#component	The Component associated with this link. \n\nTypically this will be a NodeLink2 component. But users can also create their own components and fill out this field as appropriate.\n\nThis field is not used for anything by the pathfinding system itself, it is only used to make it easier for users to find the component associated with a link.\n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkSource.costFactor	offmeshlinksource.html#costFactor	Multiplies the cost of traversing this link by this amount.
Pathfinding.OffMeshLinks.OffMeshLinkSource.directionality	offmeshlinksource.html#directionality	
Pathfinding.OffMeshLinks.OffMeshLinkSource.end	offmeshlinksource.html#end	The end of the link.
Pathfinding.OffMeshLinks.OffMeshLinkSource.gameObject	offmeshlinksource.html#gameObject	The GameObject associated with this link. \n\nThis field is not used for anything by the pathfinding system itself, it is only used to make it easier for users to find the GameObject associated with a link.\n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkSource.graphMask	offmeshlinksource.html#graphMask	Graph mask for which graphs the link is allowed to connect to. \n\nThe link's endpoints will be connected to the closest valid node on any graph that matches the mask.
Pathfinding.OffMeshLinks.OffMeshLinkSource.handler	offmeshlinksource.html#handler	
Pathfinding.OffMeshLinks.OffMeshLinkSource.maxSnappingDistance	offmeshlinksource.html#maxSnappingDistance	Maximum distance from the start/end points to the navmesh. \n\nIf the distance is greater than this, the link will not be connected to the navmesh.
Pathfinding.OffMeshLinks.OffMeshLinkSource.start	offmeshlinksource.html#start	The start of the link.
Pathfinding.OffMeshLinks.OffMeshLinkSource.status	offmeshlinksource.html#status	
Pathfinding.OffMeshLinks.OffMeshLinkSource.tag	offmeshlinksource.html#tag	Tag to apply to this link. \n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkSource.treeKey	offmeshlinksource.html#treeKey	
Pathfinding.OffMeshLinks.OffMeshLinkStatus	offmeshlinks.html#OffMeshLinkStatus	
Pathfinding.OffMeshLinks.OffMeshLinkTracer.component	offmeshlinktracer.html#component	The Component associated with this link. \n\nTypically this will be a NodeLink2 component. But users can also create their own components and fill out this field as appropriate.\n\nThis field is not used for anything by the pathfinding system itself, it is only used to make it easier for users to find the component associated with a link.\n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkTracer.gameObject	offmeshlinktracer.html#gameObject	The GameObject associated with this link. \n\nThis field is not used for anything by the pathfinding system itself, it is only used to make it easier for users to find the GameObject associated with a link.\n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkTracer.isReverse	offmeshlinktracer.html#isReverse	True if the agent is traversing the off-mesh link from original link's end to its start point. \n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkTracer.link	offmeshlinktracer.html#link	The off-mesh link that the agent is traversing. \n\n[more in online documentation]
Pathfinding.OffMeshLinks.OffMeshLinkTracer.relativeEnd	offmeshlinktracer.html#relativeEnd	The end point of the off-mesh link from the agent's perspective. \n\nThis is the point where the agent will finish traversing the off-mesh link, regardless of if the link is traversed from start to end or from end to start.
Pathfinding.OffMeshLinks.OffMeshLinkTracer.relativeStart	offmeshlinktracer.html#relativeStart	The start point of the off-mesh link from the agent's perspective. \n\nThis is the point where the agent starts traversing the off-mesh link, regardless of if the link is traversed from the start to end or from end to start.
Pathfinding.OffMeshLinks.astar	offmeshlinks.html#astar	
Pathfinding.OffMeshLinks.cachedNNConstraint	offmeshlinks.html#cachedNNConstraint	
Pathfinding.OffMeshLinks.pendingAdd	offmeshlinks.html#pendingAdd	
Pathfinding.OffMeshLinks.tree	offmeshlinks.html#tree	
Pathfinding.OffMeshLinks.updateScheduled	offmeshlinks.html#updateScheduled	
Pathfinding.OptimizationHandler.DefineDefinition.consistent	definedefinition.html#consistent	
Pathfinding.OptimizationHandler.DefineDefinition.description	definedefinition.html#description	
Pathfinding.OptimizationHandler.DefineDefinition.enabled	definedefinition.html#enabled	
Pathfinding.OptimizationHandler.DefineDefinition.name	definedefinition.html#name	
Pathfinding.OptimizationHandler.deprecatedBuildTargets	optimizationhandler.html#deprecatedBuildTargets	Various build targets that Unity have deprecated. \n\nThere is apparently no way to figure out which these are without hard coding them.
Pathfinding.OrientationMode	pathfinding.html#OrientationMode	Determines which direction the agent moves in. \n\nFor 3D games you most likely want the ZAxisIsForward option as that is the convention for 3D games. For 2D games you most likely want the YAxisIsForward option as that is the convention for 2D games.
Pathfinding.PID.AnglePIDControlOutput2D.positionDelta	anglepidcontroloutput2d.html#positionDelta	How much to move in a single time-step. \n\nIn world units.
Pathfinding.PID.AnglePIDControlOutput2D.rotationDelta	anglepidcontroloutput2d.html#rotationDelta	How much to rotate in a single time-step. \n\nIn radians.
Pathfinding.PID.AnglePIDControlOutput2D.targetRotation	anglepidcontroloutput2d.html#targetRotation	
Pathfinding.PID.AnglePIDController.DampingRatio	anglepidcontroller.html#DampingRatio	
Pathfinding.PID.PIDMovement.ALLOWED_OVERLAP_FACTOR	pidmovement.html#ALLOWED_OVERLAP_FACTOR	
Pathfinding.PID.PIDMovement.ControlParams.agentRadius	controlparams.html#agentRadius	
Pathfinding.PID.PIDMovement.ControlParams.closestOnNavmesh	controlparams.html#closestOnNavmesh	
Pathfinding.PID.PIDMovement.ControlParams.debugFlags	controlparams.html#debugFlags	
Pathfinding.PID.PIDMovement.ControlParams.edges	controlparams.html#edges	
Pathfinding.PID.PIDMovement.ControlParams.endOfPath	controlparams.html#endOfPath	
Pathfinding.PID.PIDMovement.ControlParams.facingDirectionAtEndOfPath	controlparams.html#facingDirectionAtEndOfPath	
Pathfinding.PID.PIDMovement.ControlParams.maxDesiredWallDistance	controlparams.html#maxDesiredWallDistance	
Pathfinding.PID.PIDMovement.ControlParams.movementPlane	controlparams.html#movementPlane	
Pathfinding.PID.PIDMovement.ControlParams.nextCorner	controlparams.html#nextCorner	
Pathfinding.PID.PIDMovement.ControlParams.p	controlparams.html#p	
Pathfinding.PID.PIDMovement.ControlParams.remainingDistance	controlparams.html#remainingDistance	
Pathfinding.PID.PIDMovement.ControlParams.rotation	controlparams.html#rotation	
Pathfinding.PID.PIDMovement.ControlParams.speed	controlparams.html#speed	
Pathfinding.PID.PIDMovement.DESTINATION_CLEARANCE_FACTOR	pidmovement.html#DESTINATION_CLEARANCE_FACTOR	
Pathfinding.PID.PIDMovement.DebugFlags	pidmovement.html#DebugFlags	
Pathfinding.PID.PIDMovement.EdgeBuffers.straightRegionEdgesL	edgebuffers.html#straightRegionEdgesL	
Pathfinding.PID.PIDMovement.EdgeBuffers.straightRegionEdgesR	edgebuffers.html#straightRegionEdgesR	
Pathfinding.PID.PIDMovement.EdgeBuffers.triangleRegionEdgesL	edgebuffers.html#triangleRegionEdgesL	
Pathfinding.PID.PIDMovement.EdgeBuffers.triangleRegionEdgesR	edgebuffers.html#triangleRegionEdgesR	
Pathfinding.PID.PIDMovement.MAX_FRACTION_OF_REMAINING_DISTANCE	pidmovement.html#MAX_FRACTION_OF_REMAINING_DISTANCE	
Pathfinding.PID.PIDMovement.MarkerConvertObstacles	pidmovement.html#MarkerConvertObstacles	
Pathfinding.PID.PIDMovement.MarkerOptimizeDirection	pidmovement.html#MarkerOptimizeDirection	
Pathfinding.PID.PIDMovement.MarkerPID	pidmovement.html#MarkerPID	
Pathfinding.PID.PIDMovement.MarkerSidewaysAvoidance	pidmovement.html#MarkerSidewaysAvoidance	
Pathfinding.PID.PIDMovement.MarkerSmallestDistance	pidmovement.html#MarkerSmallestDistance	
Pathfinding.PID.PIDMovement.OPTIMIZATION_ITERATIONS	pidmovement.html#OPTIMIZATION_ITERATIONS	
Pathfinding.PID.PIDMovement.PersistentState.maxDesiredWallDistance	persistentstate.html#maxDesiredWallDistance	
Pathfinding.PID.PIDMovement.STEP_MULTIPLIER	pidmovement.html#STEP_MULTIPLIER	
Pathfinding.PID.PIDMovement.allowRotatingOnSpot	pidmovement.html#allowRotatingOnSpot	If rotation on the spot is allowed or not. \n\nWhen the agent wants to turn significantly, enabling this will make it turn on the spot instead of moving in an arc. This can make for more responsive and natural movement for humanoid characters.
Pathfinding.PID.PIDMovement.allowRotatingOnSpotBacking	pidmovement.html#allowRotatingOnSpotBacking	If rotation on the spot is allowed or not. \n\n1 for allowed, 0 for not allowed.\n\nThat we have to use a byte instead of a boolean is due to a Burst limitation.
Pathfinding.PID.PIDMovement.desiredWallDistance	pidmovement.html#desiredWallDistance	How big of a distance to try to keep from obstacles. \n\nTypically around 1 or 2 times the agent radius is a good value for this.\n\nTry to avoid making it so large that there might not be enough space for the agent to keep this amount of distance from obstacles. It may start to move less optimally if it is not possible to keep this distance.\n\nThis works well in open spaces, but if your game consists of a lot of tight corridors, a low, or zero value may be better.\n\nThis will be multiplied by the agent's scale to get the actual distance.
Pathfinding.PID.PIDMovement.leadInRadiusWhenApproachingDestination	pidmovement.html#leadInRadiusWhenApproachingDestination	How wide of a turn to make when approaching a destination for which a desired facing direction has been set. \n\nThe following video shows three agents, one with no facing direction set, and then two agents with varying values of the lead in radius.  <b>[video in online documentation]</b>\n\nSetting this to zero will make the agent move directly to the end of the path and rotate on the spot to face the desired facing direction, once it is there.\n\nWhen approaching a destination for which no desired facing direction has been set, this field has no effect.\n\n[more in online documentation]\nThis will be multiplied by the agent's scale to get the actual radius.
Pathfinding.PID.PIDMovement.maxOnSpotRotationSpeed	pidmovement.html#maxOnSpotRotationSpeed	Maximum rotation speed in degrees per second while rotating on the spot. \n\nOnly used if allowRotatingOnSpot is enabled.
Pathfinding.PID.PIDMovement.maxRotationSpeed	pidmovement.html#maxRotationSpeed	Maximum rotation speed in degrees per second. \n\nIf the agent would have to rotate faster than this, it will instead slow down to get more time to rotate.\n\nThe agent may want to rotate faster than rotationSpeed if there's not enough space, so that it has to move in a more narrow arc. It may also want to rotate faster if it is very close to its destination and it wants to make sure it ends up on the right spot without any circling.\n\nIt is recommended to keep this at a value slightly larger than rotationSpeed.\n\n[more in online documentation]
Pathfinding.PID.PIDMovement.rotationSpeed	pidmovement.html#rotationSpeed	Desired rotation speed in degrees per second. \n\nIf the agent is in an open area and gets a new destination directly behind itself, it will start to rotate around with exactly this rotation speed.\n\nThe agent will slow down its rotation speed as it approaches its desired facing direction. So for example, when it is only 90 degrees away from its desired facing direction, it will only rotate with about half this speed.\n\n[more in online documentation]
Pathfinding.PID.PIDMovement.slowdownTime	pidmovement.html#slowdownTime	Time for the agent to slow down to a complete stop when it approaches the destination point, in seconds. \n\nOne can calculate the deceleration like: speed/slowdownTime (with units m/s^2).
Pathfinding.PID.PIDMovement.slowdownTimeWhenTurningOnSpot	pidmovement.html#slowdownTimeWhenTurningOnSpot	Time for the agent to slow down to a complete stop when rotating on the spot. \n\nIf set to zero, the agent will instantly stop and start to turn around.\n\nOnly used if allowRotatingOnSpot is enabled.
Pathfinding.PID.PIDMovement.speed	pidmovement.html#speed	Desired speed of the agent in meters per second. \n\nThis will be multiplied by the agent's scale to get the actual speed.
Pathfinding.Path.CompleteState	path.html#CompleteState	Current state of the path.
Pathfinding.Path.MarkerOpenCandidateConnectionsToEnd	path.html#MarkerOpenCandidateConnectionsToEnd	
Pathfinding.Path.MarkerTrace	path.html#MarkerTrace	
Pathfinding.Path.OpenCandidateParams.candidateG	opencandidateparams.html#candidateG	
Pathfinding.Path.OpenCandidateParams.fractionAlongEdge	opencandidateparams.html#fractionAlongEdge	
Pathfinding.Path.OpenCandidateParams.parentPathNode	opencandidateparams.html#parentPathNode	
Pathfinding.Path.OpenCandidateParams.pathID	opencandidateparams.html#pathID	
Pathfinding.Path.OpenCandidateParams.pathNodes	opencandidateparams.html#pathNodes	
Pathfinding.Path.OpenCandidateParams.targetNodeIndex	opencandidateparams.html#targetNodeIndex	
Pathfinding.Path.OpenCandidateParams.targetNodePosition	opencandidateparams.html#targetNodePosition	
Pathfinding.Path.OpenCandidateParams.targetPathNode	opencandidateparams.html#targetPathNode	
Pathfinding.Path.PathHandler	path.html#PathHandler	
Pathfinding.Path.PipelineState	path.html#PipelineState	Returns the state of the path in the pathfinding pipeline.
Pathfinding.Path.Pooled	path.html#Pooled	True if the path is currently pooled. \n\nDo not set this value. Only read. It is used internally.\n\n[more in online documentation]
Pathfinding.Path.ZeroTagPenalties	path.html#ZeroTagPenalties	List of zeroes to use as default tag penalties.
Pathfinding.Path.callback	path.html#callback	Callback to call when the path is complete. \n\nThis is usually sent to the Seeker component which post processes the path and then calls a callback to the script which requested the path
Pathfinding.Path.claimed	path.html#claimed	List of claims on this path with reference objects.
Pathfinding.Path.completeState	path.html#completeState	Backing field for CompleteState.
Pathfinding.Path.duration	path.html#duration	How long it took to calculate this path in milliseconds.
Pathfinding.Path.enabledTags	path.html#enabledTags	Which graph tags are traversable. \n\nThis is a bitmask so -1 = all bits set = all tags traversable. For example, to set bit 5 to true, you would do <b>[code in online documentation]</b><b>[code in online documentation]</b>\n\nThe Seeker has a popup field where you can set which tags to use. \n\n[more in online documentation]
Pathfinding.Path.error	path.html#error	If the path failed, this is true. \n\nThis typically happens if there's no valid node close enough to the start point of the path, or if there's no node close enough to the target point that is reachable from the start point. The errorLog will have more information about what happened.\n\n[more in online documentation]
Pathfinding.Path.errorLog	path.html#errorLog	Additional info on why a path failed. \n\n[more in online documentation]
Pathfinding.Path.hTargetNode	path.html#hTargetNode	Target to use for H score calculation.
Pathfinding.Path.hasBeenReset	path.html#hasBeenReset	True if the Reset function has been called. \n\nUsed to alert users when they are doing something wrong.
Pathfinding.Path.heuristic	path.html#heuristic	Determines which heuristic to use.
Pathfinding.Path.heuristicObjective	path.html#heuristicObjective	Target to use for H score calculations. \n\n[more in online documentation]
Pathfinding.Path.heuristicObjectiveInternal	path.html#heuristicObjectiveInternal	
Pathfinding.Path.heuristicScale	path.html#heuristicScale	Scale of the heuristic values. \n\n[more in online documentation]
Pathfinding.Path.immediateCallback	path.html#immediateCallback	Immediate callback to call when the path is complete. \n\n[more in online documentation]
Pathfinding.Path.internalTagPenalties	path.html#internalTagPenalties	The tag penalties that are actually used. \n\n[more in online documentation]
Pathfinding.Path.nnConstraint	path.html#nnConstraint	Constraint for how to search for nodes.
Pathfinding.Path.path	path.html#path	Holds the path as a GraphNode list. \n\nThese are all nodes that the path traversed, as calculated by the pathfinding algorithm. This may not be the same nodes as the post processed path traverses.\n\n[more in online documentation]
Pathfinding.Path.pathHandler	path.html#pathHandler	Data for the thread calculating this path.
Pathfinding.Path.pathID	path.html#pathID	ID of this path. \n\nUsed to distinguish between different paths
Pathfinding.Path.releasedNotSilent	path.html#releasedNotSilent	True if the path has been released with a non-silent call yet. \n\n[more in online documentation]
Pathfinding.Path.searchedNodes	path.html#searchedNodes	Number of nodes this path has searched.
Pathfinding.Path.tagPenalties	path.html#tagPenalties	Penalties for each tag. \n\nTag 0 which is the default tag, will get a penalty of tagPenalties[0]. These should only be non-negative values since the A* algorithm cannot handle negative penalties.\n\nWhen assigning an array to this property it must have a length of 32.\n\n[more in online documentation]
Pathfinding.Path.traversalProvider	path.html#traversalProvider	Provides additional traversal information to a path request. \n\n[more in online documentation]
Pathfinding.Path.vectorPath	path.html#vectorPath	Holds the (possibly post-processed) path as a Vector3 list. \n\nThis list may be modified by path modifiers to be smoother or simpler compared to the raw path generated by the pathfinding algorithm.\n\n[more in online documentation]
Pathfinding.PathCompleteState	pathfinding.html#PathCompleteState	State of a path request.
Pathfinding.PathEndingCondition.path	pathendingcondition.html#path	Path which this ending condition is used on.
Pathfinding.PathHandler.DebugStringBuilder	pathhandler.html#DebugStringBuilder	StringBuilder that paths can use to build debug strings. \n\nBetter for performance and memory usage to use a single StringBuilder instead of each path creating its own
Pathfinding.PathHandler.PathID	pathhandler.html#PathID	ID for the path currently being calculated or last path that was calculated.
Pathfinding.PathHandler.constraintWrapper	pathhandler.html#constraintWrapper	
Pathfinding.PathHandler.debugPathNodes	pathhandler.html#debugPathNodes	
Pathfinding.PathHandler.heap	pathhandler.html#heap	Binary heap to keep track of nodes on the "Open list". \n\n[more in online documentation]
Pathfinding.PathHandler.nodeStorage	pathhandler.html#nodeStorage	
Pathfinding.PathHandler.numTemporaryNodes	pathhandler.html#numTemporaryNodes	
Pathfinding.PathHandler.pathID	pathhandler.html#pathID	Current PathID. \n\n[more in online documentation]
Pathfinding.PathHandler.pathNodes	pathhandler.html#pathNodes	Reference to the per-node data for this thread. \n\n[more in online documentation]\nBe careful when storing copies of this array, as it may be re-allocated by the AddTemporaryNode method.
Pathfinding.PathHandler.temporaryNodeStartIndex	pathhandler.html#temporaryNodeStartIndex	All path nodes with an index greater or equal to this are temporary nodes that only exist for the duration of a single path. \n\nThis is a copy of NodeStorage.nextNodeIndex. This is used to avoid having to access the NodeStorage while pathfinding as it's an extra indirection.
Pathfinding.PathHandler.temporaryNodes	pathhandler.html#temporaryNodes	
Pathfinding.PathHandler.threadID	pathhandler.html#threadID	
Pathfinding.PathHandler.totalThreadCount	pathhandler.html#totalThreadCount	
Pathfinding.PathLog	pathfinding.html#PathLog	How path results are logged by the system.
Pathfinding.PathModifier.Order	pathmodifier.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.PathModifier.seeker	pathmodifier.html#seeker	
Pathfinding.PathNNConstraint.Walkable	pathnnconstraint.html#Walkable	An NNConstraint which filters out unwalkable nodes. \n\nThis is the most commonly used NNConstraint.\n\nIt also constrains the nearest node to be within the distance set by A* Inspector -&gt; Settings -&gt; Max Nearest Node Distance
Pathfinding.PathNode.Default	pathnode.html#Default	
Pathfinding.PathNode.Flag1Mask	pathnode.html#Flag1Mask	
Pathfinding.PathNode.Flag1Offset	pathnode.html#Flag1Offset	Flag 1 is at bit 30.
Pathfinding.PathNode.Flag2Mask	pathnode.html#Flag2Mask	
Pathfinding.PathNode.Flag2Offset	pathnode.html#Flag2Offset	Flag 2 is at bit 31.
Pathfinding.PathNode.FractionAlongEdgeMask	pathnode.html#FractionAlongEdgeMask	
Pathfinding.PathNode.FractionAlongEdgeOffset	pathnode.html#FractionAlongEdgeOffset	
Pathfinding.PathNode.FractionAlongEdgeQuantization	pathnode.html#FractionAlongEdgeQuantization	
Pathfinding.PathNode.ParentIndexMask	pathnode.html#ParentIndexMask	Parent index uses the first 26 bits.
Pathfinding.PathNode.flag1	pathnode.html#flag1	Use as temporary flag during pathfinding. \n\nPath types can use this during pathfinding to mark nodes. When done, this flag should be reverted to its default state (false) to avoid messing up other pathfinding requests.
Pathfinding.PathNode.flag2	pathnode.html#flag2	Use as temporary flag during pathfinding. \n\nPath types can use this during pathfinding to mark nodes. When done, this flag should be reverted to its default state (false) to avoid messing up other pathfinding requests.
Pathfinding.PathNode.flags	pathnode.html#flags	Bitpacked variable which stores several fields.
Pathfinding.PathNode.fractionAlongEdge	pathnode.html#fractionAlongEdge	
Pathfinding.PathNode.heapIndex	pathnode.html#heapIndex	Index of the node in the binary heap. \n\nThe open list in the A* algorithm is backed by a binary heap. To support fast 'decrease key' operations, the index of the node is saved here.
Pathfinding.PathNode.parentIndex	pathnode.html#parentIndex	
Pathfinding.PathNode.pathID	pathnode.html#pathID	The path request (in this thread, if multithreading is used) which last used this node.
Pathfinding.PathProcessor.GraphUpdateLock.Held	graphupdatelock.html#Held	True while this lock is preventing the pathfinding threads from processing more paths. \n\nNote that the pathfinding threads may not be paused yet (if this lock was obtained using PausePathfinding(false)).
Pathfinding.PathProcessor.GraphUpdateLock.id	graphupdatelock.html#id	
Pathfinding.PathProcessor.GraphUpdateLock.pathProcessor	graphupdatelock.html#pathProcessor	
Pathfinding.PathProcessor.IsUsingMultithreading	pathprocessor.html#IsUsingMultithreading	Returns whether or not multithreading is used.
Pathfinding.PathProcessor.MarkerCalculatePath	pathprocessor.html#MarkerCalculatePath	
Pathfinding.PathProcessor.MarkerPreparePath	pathprocessor.html#MarkerPreparePath	
Pathfinding.PathProcessor.NumThreads	pathprocessor.html#NumThreads	Number of parallel pathfinders. \n\nReturns the number of concurrent processes which can calculate paths at once. When using multithreading, this will be the number of threads, if not using multithreading it is always 1 (since only 1 coroutine is used). \n\n[more in online documentation]
Pathfinding.PathProcessor.OnPathPostSearch	pathprocessor.html#OnPathPostSearch	
Pathfinding.PathProcessor.OnPathPreSearch	pathprocessor.html#OnPathPreSearch	
Pathfinding.PathProcessor.OnQueueUnblocked	pathprocessor.html#OnQueueUnblocked	
Pathfinding.PathProcessor.astar	pathprocessor.html#astar	
Pathfinding.PathProcessor.coroutineReceiver	pathprocessor.html#coroutineReceiver	
Pathfinding.PathProcessor.locks	pathprocessor.html#locks	
Pathfinding.PathProcessor.multithreaded	pathprocessor.html#multithreaded	
Pathfinding.PathProcessor.nextLockID	pathprocessor.html#nextLockID	
Pathfinding.PathProcessor.pathHandlers	pathprocessor.html#pathHandlers	
Pathfinding.PathProcessor.queue	pathprocessor.html#queue	
Pathfinding.PathProcessor.returnQueue	pathprocessor.html#returnQueue	
Pathfinding.PathProcessor.threadCoroutine	pathprocessor.html#threadCoroutine	When no multithreading is used, the IEnumerator is stored here. \n\nWhen no multithreading is used, a coroutine is used instead. It is not directly called with StartCoroutine but a separate function has just a while loop which increments the main IEnumerator. This is done so other functions can step the thread forward at any time, without having to wait for Unity to update it. \n\n[more in online documentation]
Pathfinding.PathProcessor.threads	pathprocessor.html#threads	References to each of the pathfinding threads.
Pathfinding.PathRequestSettings.Default	pathrequestsettings.html#Default	A PathRequestSettings instance with default values for all fields.
Pathfinding.PathRequestSettings.graphMask	pathrequestsettings.html#graphMask	Graphs that this agent can use. \n\nThis field determines which graphs will be considered when searching for the start and end nodes of a path. It is useful in numerous situations, for example if you want to make one graph for small units and one graph for large units, or one graph for people and one graph for ships.\n\nThis is a bitmask so if you for example want to make the agent only use graph index 3 then you can set this to: <b>[code in online documentation]</b>\n\n[more in online documentation]\nNote that this field only stores which graph indices that are allowed. This means that if the graphs change their ordering then this mask may no longer be correct.\n\nIf you know the name of the graph you can use the Pathfinding.GraphMask.FromGraphName method: <b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.PathRequestSettings.tagPenalties	pathrequestsettings.html#tagPenalties	The penalty for each tag. \n\nIf null, all penalties will be treated as zero. Otherwise, the array should always have a length of exactly 32.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.PathRequestSettings.traversableTags	pathrequestsettings.html#traversableTags	The tags which this agent can traverse. \n\nThis is a bitmask. Each bit indicates that the agent can traverse nodes with the corresponding tag. If a bit is not set, the agent will treat it as if it is not traversable.\n\nThe default value is -1, which sets all bits, and indicates that the agent can traverse all tags.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.PathRequestSettings.traversalProvider	pathrequestsettings.html#traversalProvider	Filters which nodes the agent can traverse, and can also add penalties to each traversed node. \n\nIn most common situations, this is left as null (which implies the default traversal provider: DefaultITraversalProvider). But if you need custom pathfinding behavior which cannot be done using the graphMask, tagPenalties and traversableTags, then setting an ITraversalProvider is a great option. It provides you a lot more control over how the pathfinding works.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.PathReturnQueue.OnReturnedPaths	pathreturnqueue.html#OnReturnedPaths	
Pathfinding.PathReturnQueue.pathReturnQueue	pathreturnqueue.html#pathReturnQueue	Holds all paths which are waiting to be flagged as completed. \n\n[more in online documentation]
Pathfinding.PathReturnQueue.pathsClaimedSilentlyBy	pathreturnqueue.html#pathsClaimedSilentlyBy	Paths are claimed silently by some object to prevent them from being recycled while still in use. \n\nThis will be set to the AstarPath object.
Pathfinding.PathState	pathfinding.html#PathState	Internal state of a path in the pipeline.
Pathfinding.PathTracer.MarkerClosest	pathtracer.html#MarkerClosest	
Pathfinding.PathTracer.MarkerContains	pathtracer.html#MarkerContains	
Pathfinding.PathTracer.MarkerGetNearest	pathtracer.html#MarkerGetNearest	
Pathfinding.PathTracer.MarkerSimplify	pathtracer.html#MarkerSimplify	
Pathfinding.PathTracer.NODES_TO_CHECK_FOR_DESTRUCTION	pathtracer.html#NODES_TO_CHECK_FOR_DESTRUCTION	
Pathfinding.PathTracer.PartGraphType	pathtracer.html#PartGraphType	Type of graph that the current path part is on.
Pathfinding.PathTracer.QueueItem.distance	queueitem.html#distance	
Pathfinding.PathTracer.QueueItem.node	queueitem.html#node	
Pathfinding.PathTracer.QueueItem.parent	queueitem.html#parent	
Pathfinding.PathTracer.RepairQuality	pathtracer.html#RepairQuality	
Pathfinding.PathTracer.SplittingCoefficients	pathtracer.html#SplittingCoefficients	
Pathfinding.PathTracer.TempConnectionLists	pathtracer.html#TempConnectionLists	
Pathfinding.PathTracer.TempQueues	pathtracer.html#TempQueues	
Pathfinding.PathTracer.desiredCornersForGoodSimplification	pathtracer.html#desiredCornersForGoodSimplification	The minimum number of corners to request from GetNextCornerIndices to ensure the path can be simplified well. \n\nThe path simplification algorithm requires at least 2 corners on navmesh graphs, but 3 corners on grid graphs.
Pathfinding.PathTracer.endIsUpToDate	pathtracer.html#endIsUpToDate	
Pathfinding.PathTracer.endPoint	pathtracer.html#endPoint	End point of the path. \n\nThis is not necessarily the same as the destination, as this point may be clamped to the graph.
Pathfinding.PathTracer.endPointOfFirstPart	pathtracer.html#endPointOfFirstPart	End point of the current path part. \n\nIf the path has multiple parts, this is typically the start of an off-mesh link. If the path has only one part, this is the same as endPoint.
Pathfinding.PathTracer.firstPartContainsDestroyedNodes	pathtracer.html#firstPartContainsDestroyedNodes	If true, the first part contains destroyed nodes. \n\nThis can happen if the graph is updated and some nodes are destroyed.\n\nIf this is true, the path is considered stale and should be recalculated.\n\nThe opposite is not necessarily true. If this is false, the path may still be stale.\n\n[more in online documentation]
Pathfinding.PathTracer.firstPartIndex	pathtracer.html#firstPartIndex	
Pathfinding.PathTracer.funnelState	pathtracer.html#funnelState	
Pathfinding.PathTracer.hasPath	pathtracer.html#hasPath	True if there is a path to follow.
Pathfinding.PathTracer.isCreated	pathtracer.html#isCreated	True until Dispose is called.
Pathfinding.PathTracer.isNextPartValidLink	pathtracer.html#isNextPartValidLink	True if the next part in the path exists, and is a valid link. \n\nThis is true if the path has at least 2 parts and the second part is an off-mesh link.\n\nIf any nodes in the second part have been destroyed, this will return false.
Pathfinding.PathTracer.isStale	pathtracer.html#isStale	True if the path is stale and should be recalculated as quickly as possible. \n\nThis is true if the path has become invalid (e.g. due to a graph update), or if the destination has changed so much that we don't have a path to the destination at all.\n\nFor performance reasons, the agent tries to avoid checking if nodes have been destroyed unless it needs to access them to calculate its movement. Therefore, if a path is invalidated further ahead, the agent may not realize this until it has moved close enough.
Pathfinding.PathTracer.nnConstraint	pathtracer.html#nnConstraint	
Pathfinding.PathTracer.nodeHashes	pathtracer.html#nodeHashes	Hashes of some important data for each node, to determine if the node has been invalidated in some way. \n\nFor e.g. the grid graph, this is done using the node's index in the grid. This ensures that the node is counted as invalid if the node is for example moved to the other side of the graph using the ProceduralGraphMover.\n\nFor all nodes, this includes if info about if the node has been destroyed, and if it is walkable.\n\nThis will always have the same length as the nodes array, and the absolute indices in this array will correspond to the absolute indices in the nodes array.
Pathfinding.PathTracer.nodes	pathtracer.html#nodes	All nodes in the path.
Pathfinding.PathTracer.partCount	pathtracer.html#partCount	Number of parts in the path. \n\nA part is either a sequence of adjacent nodes, or an off-mesh link.
Pathfinding.PathTracer.partGraphType	pathtracer.html#partGraphType	The type of graph that the current path part is on. \n\nThis is either a grid-like graph, or a navmesh-like graph.
Pathfinding.PathTracer.parts	pathtracer.html#parts	
Pathfinding.PathTracer.portalIsNotInnerCorner	pathtracer.html#portalIsNotInnerCorner	Indicates if portals are definitely not inner corners, or if they may be. \n\nFor each portal, if bit 0 is set then the left side of the portal is definitely not an inner corner. If bit 1 is set that means the same thing but for the right side of the portal.\n\nShould always have the same length as the portals in funnelState.
Pathfinding.PathTracer.scratchList	pathtracer.html#scratchList	
Pathfinding.PathTracer.startIsUpToDate	pathtracer.html#startIsUpToDate	
Pathfinding.PathTracer.startNode	pathtracer.html#startNode	Current start node of the path. \n\nSince the path is updated every time the agent moves, this will be the node which the agent is inside.\n\nIn case the path has become invalid, this will be set to the closest node to the agent, or if no such node could be found, it will be set to null.\n\n[more in online documentation]
Pathfinding.PathTracer.startNodeInternal	pathtracer.html#startNodeInternal	
Pathfinding.PathTracer.startPoint	pathtracer.html#startPoint	Start point of the path.
Pathfinding.PathTracer.unclampedEndPoint	pathtracer.html#unclampedEndPoint	
Pathfinding.PathTracer.unclampedStartPoint	pathtracer.html#unclampedStartPoint	
Pathfinding.PathTracer.version	pathtracer.html#version	Incremented whenever the path is changed.
Pathfinding.PathUtilities.BFSMap	pathutilities.html#BFSMap	
Pathfinding.PathUtilities.BFSQueue	pathutilities.html#BFSQueue	
Pathfinding.PathUtilities.ConstrainToSet.nodes	constraintoset.html#nodes	
Pathfinding.PathUtilities.FormationMode	pathutilities.html#FormationMode	
Pathfinding.PathUtilities.JobFormationPacked.DistanceComparer.positions	distancecomparer.html#positions	
Pathfinding.PathUtilities.JobFormationPacked.agentRadius	jobformationpacked.html#agentRadius	
Pathfinding.PathUtilities.JobFormationPacked.destination	jobformationpacked.html#destination	
Pathfinding.PathUtilities.JobFormationPacked.movementPlane	jobformationpacked.html#movementPlane	
Pathfinding.PathUtilities.JobFormationPacked.positions	jobformationpacked.html#positions	
Pathfinding.PathfindingEditorSettings.hasShownWelcomeScreen	pathfindingeditorsettings.html#hasShownWelcomeScreen	
Pathfinding.PathfindingTag.value	pathfindingtag.html#value	Underlaying tag value. \n\nShould always be between 0 and GraphNode.MaxTagIndex (inclusive).
Pathfinding.Patrol.agent	patrol.html#agent	
Pathfinding.Patrol.delay	patrol.html#delay	Time in seconds to wait at each target.
Pathfinding.Patrol.index	patrol.html#index	Current target index.
Pathfinding.Patrol.switchTime	patrol.html#switchTime	
Pathfinding.Patrol.targets	patrol.html#targets	Target points to move to in order.
Pathfinding.Patrol.updateDestinationEveryFrame	patrol.html#updateDestinationEveryFrame	If true, the agent's destination will be updated every frame instead of only when switching targets. \n\nThis is good if you have moving targets, but is otherwise unnecessary and slightly slower.
Pathfinding.PointGraph.NodeColor	pointgraph.html#NodeColor	
Pathfinding.PointGraph.NodeDistanceMode	pointgraph.html#NodeDistanceMode	Distance query mode. \n\n <b>[image in online documentation]</b>\n\nIn the image above there are a few red nodes. Assume the agent is the orange circle. Using the Node mode the closest point on the graph that would be found would be the node at the bottom center which may not be what you want. Using the Connection mode it will find the closest point on the connection between the two nodes in the top half of the image.\n\nWhen using the Connection option you may also want to use the Connection option for the Seeker's Start End Modifier snapping options. This is not strictly necessary, but it most cases it is what you want.\n\n[more in online documentation]
Pathfinding.PointGraph.PointGraphScanPromise.graph	pointgraphscanpromise.html#graph	
Pathfinding.PointGraph.PointGraphScanPromise.lookupTree	pointgraphscanpromise.html#lookupTree	
Pathfinding.PointGraph.PointGraphScanPromise.nodes	pointgraphscanpromise.html#nodes	
Pathfinding.PointGraph.PointGraphUpdatePromise.graph	pointgraphupdatepromise.html#graph	
Pathfinding.PointGraph.PointGraphUpdatePromise.graphUpdates	pointgraphupdatepromise.html#graphUpdates	
Pathfinding.PointGraph.isScanned	pointgraph.html#isScanned	True if the graph has been scanned and contains nodes. \n\nGraphs are typically scanned when the game starts, but they can also be scanned manually.\n\nIf a graph has not been scanned, it does not contain any nodes and it not possible to use it for pathfinding.\n\n[more in online documentation]
Pathfinding.PointGraph.limits	pointgraph.html#limits	Max distance along the axis for a connection to be valid. \n\n0 = infinity
Pathfinding.PointGraph.lookupTree	pointgraph.html#lookupTree	
Pathfinding.PointGraph.mask	pointgraph.html#mask	Layer mask to use for raycasting. \n\nAll objects included in this layer mask will be treated as obstacles.\n\n[more in online documentation]
Pathfinding.PointGraph.maxDistance	pointgraph.html#maxDistance	Max distance for a connection to be valid. \n\nThe value 0 (zero) will be read as infinity and thus all nodes not restricted by other constraints will be added as connections.\n\nA negative value will disable any neighbours to be added. It will completely stop the connection processing to be done, so it can save you processing power if you don't these connections.
Pathfinding.PointGraph.maximumConnectionLength	pointgraph.html#maximumConnectionLength	Longest known connection. \n\nIn squared Int3 units.\n\n[more in online documentation]
Pathfinding.PointGraph.nearestNodeDistanceMode	pointgraph.html#nearestNodeDistanceMode	Distance query mode. \n\n <b>[image in online documentation]</b>\n\nIn the image above there are a few red nodes. Assume the agent is the orange circle. Using the Node mode the closest point on the graph that would be found would be the node at the bottom center which may not be what you want. Using the Connection mode it will find the closest point on the connection between the two nodes in the top half of the image.\n\nWhen using the Connection option you may also want to use the Connection option for the Seeker's Start End Modifier snapping options. This is not strictly necessary, but it most cases it is what you want.\n\n[more in online documentation]\nIf you enable this during runtime, you will need to call RebuildConnectionDistanceLookup to make sure some cache data is properly recalculated. If the graph doesn't have any nodes yet or if you are going to scan the graph afterwards then you do not need to do this.
Pathfinding.PointGraph.nodeCount	pointgraph.html#nodeCount	Number of nodes in this graph.
Pathfinding.PointGraph.nodes	pointgraph.html#nodes	All nodes in this graph. \n\nNote that only the first nodeCount will be non-null.\n\nYou can also use the GetNodes method to get all nodes.\n\nThe order of the nodes is unspecified, and may change when nodes are added or removed.
Pathfinding.PointGraph.optimizeForSparseGraph	pointgraph.html#optimizeForSparseGraph	Optimizes the graph for sparse graphs. \n\nThis can reduce calculation times for both scanning and for normal path requests by huge amounts. It reduces the number of node-node checks that need to be done during scan, and can also optimize getting the nearest node from the graph (such as when querying for a path).\n\nTry enabling and disabling this option, check the scan times logged when you scan the graph to see if your graph is suited for this optimization or if it makes it slower.\n\nThe gain of using this optimization increases with larger graphs, the default scan algorithm is brute force and requires O(n^2) checks, this optimization along with a graph suited for it, requires only O(n) checks during scan (assuming the connection distance limits are reasonable).\n\n[more in online documentation]\n\n\nIf you enable this during runtime, you need to call RebuildNodeLookup to make this take effect. If you are going to scan the graph afterwards then you do not need to do this.
Pathfinding.PointGraph.raycast	pointgraph.html#raycast	Use raycasts to filter connections. \n\nIf a hit is detected between two nodes, the connection will not be created.
Pathfinding.PointGraph.recursive	pointgraph.html#recursive	Recursively search for child nodes to the root. \n\nIf false, all direct children of root will be used as nodes. If true, all children of root and their children (recursively) will be used as nodes.
Pathfinding.PointGraph.root	pointgraph.html#root	Children of this transform are treated as nodes. \n\nIf null, the searchTag will be used instead.
Pathfinding.PointGraph.searchTag	pointgraph.html#searchTag	If no root is set, all nodes with the tag is used as nodes.
Pathfinding.PointGraph.thickRaycast	pointgraph.html#thickRaycast	Use thick raycast. \n\nIf enabled, the collision check shape will not be a line segment, but a capsule with a radius of thickRaycastRadius.
Pathfinding.PointGraph.thickRaycastRadius	pointgraph.html#thickRaycastRadius	Thick raycast radius. \n\n[more in online documentation]
Pathfinding.PointGraph.use2DPhysics	pointgraph.html#use2DPhysics	Use the 2D Physics API.
Pathfinding.PointGraphEditor.nearestNodeDistanceModeLabels	pointgrapheditor.html#nearestNodeDistanceModeLabels	
Pathfinding.PointKDTree.LeafArraySize	pointkdtree.html#LeafArraySize	
Pathfinding.PointKDTree.LeafSize	pointkdtree.html#LeafSize	
Pathfinding.PointKDTree.Node.count	node.html#count	Number of non-null entries in data.
Pathfinding.PointKDTree.Node.data	node.html#data	Nodes in this leaf node (null if not a leaf node)
Pathfinding.PointKDTree.Node.split	node.html#split	Split point along the splitAxis if not a leaf node.
Pathfinding.PointKDTree.Node.splitAxis	node.html#splitAxis	Axis to split along if not a leaf node (x=0, y=1, z=2)
Pathfinding.PointKDTree.arrayCache	pointkdtree.html#arrayCache	
Pathfinding.PointKDTree.comparers	pointkdtree.html#comparers	
Pathfinding.PointKDTree.largeList	pointkdtree.html#largeList	
Pathfinding.PointKDTree.numNodes	pointkdtree.html#numNodes	
Pathfinding.PointKDTree.tree	pointkdtree.html#tree	
Pathfinding.PointNode.connections	pointnode.html#connections	All connections from this node. \n\n[more in online documentation]\n\n\nThis may be null if the node has no connections to other nodes.
Pathfinding.PointNode.gameObject	pointnode.html#gameObject	GameObject this node was created from (if any). \n\n[more in online documentation]\n<b>[code in online documentation]</b>
Pathfinding.Polygon.BarycentricTriangleInterpolator.barycentricMapping	barycentrictriangleinterpolator.html#barycentricMapping	
Pathfinding.Polygon.BarycentricTriangleInterpolator.linear1	barycentrictriangleinterpolator.html#linear1	
Pathfinding.Polygon.BarycentricTriangleInterpolator.linear2	barycentrictriangleinterpolator.html#linear2	
Pathfinding.Polygon.BarycentricTriangleInterpolator.linear3	barycentrictriangleinterpolator.html#linear3	
Pathfinding.Polygon.BarycentricTriangleInterpolator.origin	barycentrictriangleinterpolator.html#origin	
Pathfinding.Polygon.BarycentricTriangleInterpolator.thresholds	barycentrictriangleinterpolator.html#thresholds	
Pathfinding.Polygon.BarycentricTriangleInterpolator.ys	barycentrictriangleinterpolator.html#ys	
Pathfinding.Polygon.cached_Int3_int_dict	polygon.html#cached_Int3_int_dict	Cached dictionary to avoid excessive allocations.
Pathfinding.Pooling.ArrayPool.MaximumExactArrayLength	arraypool.html#MaximumExactArrayLength	Maximum length of an array pooled using ClaimWithExactLength. \n\nArrays with lengths longer than this will silently not be pooled.
Pathfinding.Pooling.ArrayPool.exactPool	arraypool.html#exactPool	
Pathfinding.Pooling.ArrayPool.inPool	arraypool.html#inPool	
Pathfinding.Pooling.ArrayPool.pool	arraypool.html#pool	Internal pool. \n\nThe arrays in each bucket have lengths of 2^i
Pathfinding.Pooling.ListPool.LargeThreshold	listpool.html#LargeThreshold	
Pathfinding.Pooling.ListPool.MaxCapacitySearchLength	listpool.html#MaxCapacitySearchLength	When requesting a list with a specified capacity, search max this many lists in the pool before giving up. \n\nMust be greater or equal to one.
Pathfinding.Pooling.ListPool.MaxLargePoolSize	listpool.html#MaxLargePoolSize	
Pathfinding.Pooling.ListPool.inPool	listpool.html#inPool	
Pathfinding.Pooling.ListPool.largePool	listpool.html#largePool	
Pathfinding.Pooling.ListPool.pool	listpool.html#pool	Internal pool.
Pathfinding.Pooling.ObjectPoolSimple.inPool	objectpoolsimple.html#inPool	
Pathfinding.Pooling.ObjectPoolSimple.pool	objectpoolsimple.html#pool	Internal pool.
Pathfinding.Pooling.PathPool.pool	pathpool.html#pool	
Pathfinding.Pooling.PathPool.totalCreated	pathpool.html#totalCreated	
Pathfinding.Pooling.StackPool.pool	stackpool.html#pool	Internal pool.
Pathfinding.ProceduralGraphMover.graph	proceduralgraphmover.html#graph	Graph to update. \n\nThis will be set at Start based on graphIndex. During runtime you may set this to any graph or to null to disable updates.
Pathfinding.ProceduralGraphMover.graphIndex	proceduralgraphmover.html#graphIndex	Index for the graph to update. \n\nThis will be used at Start to set graph.\n\nThis is an index into the AstarPath.active.data.graphs array.
Pathfinding.ProceduralGraphMover.target	proceduralgraphmover.html#target	Graph will be moved to follow this target.
Pathfinding.ProceduralGraphMover.updateDistance	proceduralgraphmover.html#updateDistance	Grid graphs will be updated if the target is more than this number of nodes from the graph center. \n\nNote that this is in nodes, not world units.\n\n[more in online documentation]
Pathfinding.ProceduralGraphMover.updatingGraph	proceduralgraphmover.html#updatingGraph	True while the graph is being updated by this script.
Pathfinding.ProceduralGridMoverEditor.graphLabels	proceduralgridmovereditor.html#graphLabels	
Pathfinding.Progress.graphCount	progress.html#graphCount	
Pathfinding.Progress.graphIndex	progress.html#graphIndex	
Pathfinding.Progress.progress	progress.html#progress	Current progress as a value between 0 and 1.
Pathfinding.Progress.stage	progress.html#stage	
Pathfinding.RVO.AgentDebugFlags	rvo.html#AgentDebugFlags	
Pathfinding.RVO.ArbitraryMovementPlane.matrix	arbitrarymovementplane.html#matrix	Maps from 2D (X, Y, 0) coordinates to world coordinates.
Pathfinding.RVO.ArbitraryMovementPlane.plane	arbitrarymovementplane.html#plane	
Pathfinding.RVO.IAgent.AgentIndex	iagent.html#AgentIndex	Internal index of the agent. \n\n[more in online documentation]
Pathfinding.RVO.IAgent.AgentTimeHorizon	iagent.html#AgentTimeHorizon	Max number of estimated seconds to look into the future for collisions with agents. \n\nAs it turns out, this variable is also very good for controling agent avoidance priorities. Agents with lower values will avoid other agents less and thus you can make 'high priority agents' by giving them a lower value.
Pathfinding.RVO.IAgent.AvoidingAnyAgents	iagent.html#AvoidingAnyAgents	True if the agent's movement is affected by any other agents or obstacles. \n\nIf the agent is all alone, and can just move in a straight line to its target, this will be false. If it has to adjust its velocity, even slightly, to avoid collisions, this will be true.
Pathfinding.RVO.IAgent.CalculatedEffectivelyReachedDestination	iagent.html#CalculatedEffectivelyReachedDestination	
Pathfinding.RVO.IAgent.CalculatedSpeed	iagent.html#CalculatedSpeed	Optimal speed of the agent to avoid collisions. \n\nThe movement script should move towards CalculatedTargetPoint with this speed.
Pathfinding.RVO.IAgent.CalculatedTargetPoint	iagent.html#CalculatedTargetPoint	Optimal point to move towards to avoid collisions. \n\nThe movement script should move towards this point with a speed of CalculatedSpeed.\n\n[more in online documentation]
Pathfinding.RVO.IAgent.CollidesWith	iagent.html#CollidesWith	Layer mask specifying which layers this agent will avoid. \n\nYou can set it as CollidesWith = RVOLayer.DefaultAgent | RVOLayer.Layer3 | RVOLayer.Layer6 ...\n\n[more in online documentation]
Pathfinding.RVO.IAgent.DebugFlags	iagent.html#DebugFlags	Draw debug information in the scene view.
Pathfinding.RVO.IAgent.DestroyedCallback	iagent.html#DestroyedCallback	Callback which will be called right the agent is removed from the simulation. \n\nThis agent should not be used anymore after this callback has been called.
Pathfinding.RVO.IAgent.FlowFollowingStrength	iagent.html#FlowFollowingStrength	Determines how strongly this agent just follows the flow instead of making other agents avoid it. \n\nThe default value is 0, if it is greater than zero (up to the maximum value of 1) other agents will not avoid this character as much. However it works in a different way to Priority.\n\nA group of agents with FlowFollowingStrength set to a high value that all try to reach the same point will end up just settling to stationary positions around that point, none will push the others away to any significant extent. This is tricky to achieve with priorities as priorities are all relative, so setting all agents to a low priority is the same thing as not changing priorities at all.\n\nShould be a value in the range [0, 1].
Pathfinding.RVO.IAgent.Height	iagent.html#Height	Height of the agent in world units. \n\nAgents are modelled as circles/cylinders.
Pathfinding.RVO.IAgent.HierarchicalNodeIndex	iagent.html#HierarchicalNodeIndex	
Pathfinding.RVO.IAgent.Layer	iagent.html#Layer	Specifies the avoidance layer for this agent. \n\nThe CollidesWith mask on other agents will determine if they will avoid this agent.
Pathfinding.RVO.IAgent.Locked	iagent.html#Locked	Locked agents will be assumed not to move.
Pathfinding.RVO.IAgent.MaxNeighbours	iagent.html#MaxNeighbours	Max number of agents to take into account. \n\nDecreasing this value can lead to better performance, increasing it can lead to better quality of the simulation.
Pathfinding.RVO.IAgent.MovementPlane	iagent.html#MovementPlane	Plane in which the agent moves. \n\nLocal avoidance calculations are always done in 2D and this plane determines how to convert from 3D to 2D.\n\nIn a typical 3D game the agents move in the XZ plane and in a 2D game they move in the XY plane. By default this is set to the XZ plane.\n\n[more in online documentation]
Pathfinding.RVO.IAgent.NeighbourCount	iagent.html#NeighbourCount	Number of neighbours that the agent took into account during the last simulation step.
Pathfinding.RVO.IAgent.ObstacleTimeHorizon	iagent.html#ObstacleTimeHorizon	Max number of estimated seconds to look into the future for collisions with obstacles.
Pathfinding.RVO.IAgent.Position	iagent.html#Position	Position of the agent. \n\nThe agent does not move by itself, a movement script has to be responsible for reading the CalculatedTargetPoint and CalculatedSpeed properties and move towards that point with that speed. This property should ideally be set every frame.
Pathfinding.RVO.IAgent.PreCalculationCallback	iagent.html#PreCalculationCallback	Callback which will be called right before avoidance calculations are started. \n\nUsed to update the other properties with the most up to date values
Pathfinding.RVO.IAgent.Priority	iagent.html#Priority	How strongly other agents will avoid this agent. \n\nUsually a value between 0 and 1. Agents with similar priorities will avoid each other with an equal strength. If an agent sees another agent with a higher priority than itself it will avoid that agent more strongly. In the extreme case (e.g this agent has a priority of 0 and the other agent has a priority of 1) it will treat the other agent as being a moving obstacle. Similarly if an agent sees another agent with a lower priority than itself it will avoid that agent less.\n\nIn general the avoidance strength for this agent is: <b>[code in online documentation]</b>
Pathfinding.RVO.IAgent.Radius	iagent.html#Radius	Radius of the agent in world units. \n\nAgents are modelled as circles/cylinders.
Pathfinding.RVO.IMovementPlaneWrapper.matrix	imovementplanewrapper.html#matrix	Maps from 2D (X, Y, 0) coordinates to world coordinates.
Pathfinding.RVO.JobDestinationReached.MarkerAlloc	jobdestinationreached.html#MarkerAlloc	
Pathfinding.RVO.JobDestinationReached.MarkerFirstPass	jobdestinationreached.html#MarkerFirstPass	
Pathfinding.RVO.JobDestinationReached.MarkerInvert	jobdestinationreached.html#MarkerInvert	
Pathfinding.RVO.JobDestinationReached.TempAgentData.blockedAndSlow	tempagentdata.html#blockedAndSlow	
Pathfinding.RVO.JobDestinationReached.TempAgentData.distToEndSq	tempagentdata.html#distToEndSq	
Pathfinding.RVO.JobDestinationReached.agentData	jobdestinationreached.html#agentData	
Pathfinding.RVO.JobDestinationReached.draw	jobdestinationreached.html#draw	
Pathfinding.RVO.JobDestinationReached.numAgents	jobdestinationreached.html#numAgents	
Pathfinding.RVO.JobDestinationReached.output	jobdestinationreached.html#output	
Pathfinding.RVO.JobDestinationReached.temporaryAgentData	jobdestinationreached.html#temporaryAgentData	
Pathfinding.RVO.JobHardCollisions.CollisionStrength	jobhardcollisions.html#CollisionStrength	How aggressively hard collisions are resolved. \n\nShould be a value between 0 and 1.
Pathfinding.RVO.JobHardCollisions.agentData	jobhardcollisions.html#agentData	
Pathfinding.RVO.JobHardCollisions.allowBoundsChecks	jobhardcollisions.html#allowBoundsChecks	
Pathfinding.RVO.JobHardCollisions.collisionVelocityOffsets	jobhardcollisions.html#collisionVelocityOffsets	
Pathfinding.RVO.JobHardCollisions.deltaTime	jobhardcollisions.html#deltaTime	
Pathfinding.RVO.JobHardCollisions.enabled	jobhardcollisions.html#enabled	
Pathfinding.RVO.JobHardCollisions.neighbours	jobhardcollisions.html#neighbours	
Pathfinding.RVO.JobHorizonAvoidancePhase1.agentData	jobhorizonavoidancephase1.html#agentData	
Pathfinding.RVO.JobHorizonAvoidancePhase1.allowBoundsChecks	jobhorizonavoidancephase1.html#allowBoundsChecks	
Pathfinding.RVO.JobHorizonAvoidancePhase1.desiredTargetPointInVelocitySpace	jobhorizonavoidancephase1.html#desiredTargetPointInVelocitySpace	
Pathfinding.RVO.JobHorizonAvoidancePhase1.draw	jobhorizonavoidancephase1.html#draw	
Pathfinding.RVO.JobHorizonAvoidancePhase1.horizonAgentData	jobhorizonavoidancephase1.html#horizonAgentData	
Pathfinding.RVO.JobHorizonAvoidancePhase1.neighbours	jobhorizonavoidancephase1.html#neighbours	
Pathfinding.RVO.JobHorizonAvoidancePhase2.allowBoundsChecks	jobhorizonavoidancephase2.html#allowBoundsChecks	
Pathfinding.RVO.JobHorizonAvoidancePhase2.desiredTargetPointInVelocitySpace	jobhorizonavoidancephase2.html#desiredTargetPointInVelocitySpace	
Pathfinding.RVO.JobHorizonAvoidancePhase2.desiredVelocity	jobhorizonavoidancephase2.html#desiredVelocity	
Pathfinding.RVO.JobHorizonAvoidancePhase2.horizonAgentData	jobhorizonavoidancephase2.html#horizonAgentData	
Pathfinding.RVO.JobHorizonAvoidancePhase2.movementPlane	jobhorizonavoidancephase2.html#movementPlane	
Pathfinding.RVO.JobHorizonAvoidancePhase2.neighbours	jobhorizonavoidancephase2.html#neighbours	
Pathfinding.RVO.JobHorizonAvoidancePhase2.versions	jobhorizonavoidancephase2.html#versions	
Pathfinding.RVO.JobRVO.LinearProgram2Output.firstFailedLineIndex	linearprogram2output.html#firstFailedLineIndex	
Pathfinding.RVO.JobRVO.LinearProgram2Output.velocity	linearprogram2output.html#velocity	
Pathfinding.RVO.JobRVO.MarkerConvertObstacles1	jobrvo.html#MarkerConvertObstacles1	
Pathfinding.RVO.JobRVO.MarkerConvertObstacles2	jobrvo.html#MarkerConvertObstacles2	
Pathfinding.RVO.JobRVO.MaxObstacleCount	jobrvo.html#MaxObstacleCount	
Pathfinding.RVO.JobRVO.ORCALine.direction	orcaline.html#direction	
Pathfinding.RVO.JobRVO.ORCALine.point	orcaline.html#point	
Pathfinding.RVO.JobRVO.SortByKey.keys	sortbykey.html#keys	
Pathfinding.RVO.JobRVO.agentData	jobrvo.html#agentData	
Pathfinding.RVO.JobRVO.allowBoundsChecks	jobrvo.html#allowBoundsChecks	
Pathfinding.RVO.JobRVO.deltaTime	jobrvo.html#deltaTime	
Pathfinding.RVO.JobRVO.draw	jobrvo.html#draw	
Pathfinding.RVO.JobRVO.navmeshEdgeData	jobrvo.html#navmeshEdgeData	
Pathfinding.RVO.JobRVO.output	jobrvo.html#output	
Pathfinding.RVO.JobRVO.priorityMultiplier	jobrvo.html#priorityMultiplier	
Pathfinding.RVO.JobRVO.symmetryBreakingBias	jobrvo.html#symmetryBreakingBias	
Pathfinding.RVO.JobRVO.temporaryAgentData	jobrvo.html#temporaryAgentData	
Pathfinding.RVO.JobRVO.useNavmeshAsObstacle	jobrvo.html#useNavmeshAsObstacle	
Pathfinding.RVO.JobRVOCalculateNeighbours.agentData	jobrvocalculateneighbours.html#agentData	
Pathfinding.RVO.JobRVOCalculateNeighbours.allowBoundsChecks	jobrvocalculateneighbours.html#allowBoundsChecks	
Pathfinding.RVO.JobRVOCalculateNeighbours.outNeighbours	jobrvocalculateneighbours.html#outNeighbours	
Pathfinding.RVO.JobRVOCalculateNeighbours.output	jobrvocalculateneighbours.html#output	
Pathfinding.RVO.JobRVOCalculateNeighbours.quadtree	jobrvocalculateneighbours.html#quadtree	
Pathfinding.RVO.JobRVOPreprocess.agentData	jobrvopreprocess.html#agentData	
Pathfinding.RVO.JobRVOPreprocess.endIndex	jobrvopreprocess.html#endIndex	
Pathfinding.RVO.JobRVOPreprocess.previousOutput	jobrvopreprocess.html#previousOutput	
Pathfinding.RVO.JobRVOPreprocess.startIndex	jobrvopreprocess.html#startIndex	
Pathfinding.RVO.JobRVOPreprocess.temporaryAgentData	jobrvopreprocess.html#temporaryAgentData	
Pathfinding.RVO.MovementPlane	rvo.html#MovementPlane	Plane which movement is primarily happening in.
Pathfinding.RVO.ObstacleType	rvo.html#ObstacleType	Type of obstacle shape. \n\n[more in online documentation]
Pathfinding.RVO.ObstacleVertexGroup.boundsMn	obstaclevertexgroup.html#boundsMn	
Pathfinding.RVO.ObstacleVertexGroup.boundsMx	obstaclevertexgroup.html#boundsMx	
Pathfinding.RVO.ObstacleVertexGroup.type	obstaclevertexgroup.html#type	Type of obstacle shape.
Pathfinding.RVO.ObstacleVertexGroup.vertexCount	obstaclevertexgroup.html#vertexCount	Number of vertices that this group consists of.
Pathfinding.RVO.RVOController.AvoidingAnyAgents	rvocontroller.html#AvoidingAnyAgents	True if the agent's movement is affected by any other agents or obstacles. \n\nIf the agent is all alone, and can just move in a straight line to its target, this will be false. If it has to adjust its velocity, even slightly, to avoid collisions, this will be true.
Pathfinding.RVO.RVOController.RVOControllerMigrations	rvocontroller.html#RVOControllerMigrations	
Pathfinding.RVO.RVOController.agentTimeHorizon	rvocontroller.html#agentTimeHorizon	How far into the future to look for collisions with other agents (in seconds)
Pathfinding.RVO.RVOController.ai	rvocontroller.html#ai	Cached reference to a movement script (if one is used)
Pathfinding.RVO.RVOController.aiBackingField	rvocontroller.html#aiBackingField	
Pathfinding.RVO.RVOController.center	rvocontroller.html#center	Center of the agent relative to the pivot point of this game object. \n\n[more in online documentation]
Pathfinding.RVO.RVOController.centerBackingField	rvocontroller.html#centerBackingField	
Pathfinding.RVO.RVOController.collidesWith	rvocontroller.html#collidesWith	Layer mask specifying which layers this agent will avoid. \n\nYou can set it as CollidesWith = RVOLayer.DefaultAgent | RVOLayer.Layer3 | RVOLayer.Layer6 ...\n\nThis can be very useful in games which have multiple teams of some sort. For example you usually want the agents in one team to avoid each other, but you do not want them to avoid the enemies.\n\nThis field only affects which other agents that this agent will avoid, it does not affect how other agents react to this agent.\n\n[more in online documentation]
Pathfinding.RVO.RVOController.debug	rvocontroller.html#debug	Enables drawing debug information in the scene view.
Pathfinding.RVO.RVOController.flowFollowingStrength	rvocontroller.html#flowFollowingStrength	Determines how strongly this agent just follows the flow instead of making other agents avoid it. \n\nThe default value is 0, if it is greater than zero (up to the maximum value of 1) other agents will not avoid this character as much. However it works in a different way to Priority.\n\nA group of agents with FlowFollowingStrength set to a high value that all try to reach the same point will end up just settling to stationary positions around that point, none will push the others away to any significant extent. This is tricky to achieve with priorities as priorities are all relative, so setting all agents to a low priority is the same thing as not changing priorities at all.\n\nShould be a value in the range [0, 1].
Pathfinding.RVO.RVOController.height	rvocontroller.html#height	Height of the agent in world units. \n\n[more in online documentation]
Pathfinding.RVO.RVOController.heightBackingField	rvocontroller.html#heightBackingField	
Pathfinding.RVO.RVOController.layer	rvocontroller.html#layer	Specifies the avoidance layer for this agent. \n\nThe collidesWith mask on other agents will determine if they will avoid this agent.
Pathfinding.RVO.RVOController.lockWhenNotMoving	rvocontroller.html#lockWhenNotMoving	Automatically set locked to true when desired velocity is approximately zero. \n\nThis prevents other units from pushing them away when they are supposed to e.g block a choke point.\n\nWhen this is true every call to SetTarget or Move will set the locked field to true if the desired velocity was non-zero or false if it was zero.
Pathfinding.RVO.RVOController.locked	rvocontroller.html#locked	A locked unit cannot move. \n\nOther units will still avoid it but avoidance quality is not the best.
Pathfinding.RVO.RVOController.maxNeighbours	rvocontroller.html#maxNeighbours	Max number of other agents to take into account. \n\nA smaller value can reduce CPU load, a higher value can lead to better local avoidance quality.
Pathfinding.RVO.RVOController.movementPlane	rvocontroller.html#movementPlane	Determines if the XY (2D) or XZ (3D) plane is used for movement.
Pathfinding.RVO.RVOController.movementPlaneBackingField	rvocontroller.html#movementPlaneBackingField	
Pathfinding.RVO.RVOController.movementPlaneMode	rvocontroller.html#movementPlaneMode	
Pathfinding.RVO.RVOController.obstacleQuery	rvocontroller.html#obstacleQuery	
Pathfinding.RVO.RVOController.obstacleTimeHorizon	rvocontroller.html#obstacleTimeHorizon	How far into the future to look for collisions with obstacles (in seconds)
Pathfinding.RVO.RVOController.position	rvocontroller.html#position	Current position of the agent. \n\nNote that this is only updated every local avoidance simulation step, not every frame.
Pathfinding.RVO.RVOController.priority	rvocontroller.html#priority	How strongly other agents will avoid this agent. \n\nUsually a value between 0 and 1. Agents with similar priorities will avoid each other with an equal strength. If an agent sees another agent with a higher priority than itself it will avoid that agent more strongly. In the extreme case (e.g this agent has a priority of 0 and the other agent has a priority of 1) it will treat the other agent as being a moving obstacle. Similarly if an agent sees another agent with a lower priority than itself it will avoid that agent less.\n\nIn general the avoidance strength for this agent is: <b>[code in online documentation]</b>
Pathfinding.RVO.RVOController.priorityMultiplier	rvocontroller.html#priorityMultiplier	Priority multiplier. \n\nThis functions identically to the priority, however it is not exposed in the Unity inspector. It is primarily used by the Pathfinding.RVO.RVODestinationCrowdedBehavior.
Pathfinding.RVO.RVOController.radius	rvocontroller.html#radius	Radius of the agent in world units. \n\n[more in online documentation]
Pathfinding.RVO.RVOController.radiusBackingField	rvocontroller.html#radiusBackingField	
Pathfinding.RVO.RVOController.rvoAgent	rvocontroller.html#rvoAgent	Reference to the internal agent.
Pathfinding.RVO.RVOController.simulator	rvocontroller.html#simulator	Reference to the rvo simulator.
Pathfinding.RVO.RVOController.tr	rvocontroller.html#tr	Cached tranform component.
Pathfinding.RVO.RVOController.velocity	rvocontroller.html#velocity	Current calculated velocity of the agent. \n\nThis is not necessarily the velocity the agent is actually moving with (that is up to the movement script to decide) but it is the velocity that the RVO system has calculated is best for avoiding obstacles and reaching the target.\n\n[more in online documentation]\nYou can also set the velocity of the agent. This will override the local avoidance input completely. It is useful if you have a player controlled character and want other agents to avoid it.\n\nSetting the velocity using this property will mark the agent as being externally controlled for 1 simulation step. Local avoidance calculations will be skipped for the next simulation step but will be resumed after that unless this property is set again.\n\nNote that if you set the velocity the value that can be read from this property will not change until the next simulation step.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RVO.RVOController.wallAvoidFalloff	rvocontroller.html#wallAvoidFalloff	How much the wallAvoidForce decreases with distance. \n\nThe strenght of avoidance is: <b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RVO.RVOController.wallAvoidForce	rvocontroller.html#wallAvoidForce	An extra force to avoid walls. \n\nThis can be good way to reduce "wall hugging" behaviour.\n\n[more in online documentation]
Pathfinding.RVO.RVODestinationCrowdedBehavior.DefaultPriority	rvodestinationcrowdedbehavior.html#DefaultPriority	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.QueryData.agentDestination	querydata.html#agentDestination	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.QueryData.agentIndex	querydata.html#agentIndex	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.QueryData.densityThreshold	querydata.html#densityThreshold	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.agentDesiredSpeed	jobdensitycheck.html#agentDesiredSpeed	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.agentOutputSpeed	jobdensitycheck.html#agentOutputSpeed	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.agentOutputTargetPoint	jobdensitycheck.html#agentOutputTargetPoint	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.agentPosition	jobdensitycheck.html#agentPosition	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.agentRadius	jobdensitycheck.html#agentRadius	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.agentTargetPoint	jobdensitycheck.html#agentTargetPoint	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.allowBoundsChecks	jobdensitycheck.html#allowBoundsChecks	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.data	jobdensitycheck.html#data	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.deltaTime	jobdensitycheck.html#deltaTime	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.outThresholdResult	jobdensitycheck.html#outThresholdResult	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.progressAverage	jobdensitycheck.html#progressAverage	
Pathfinding.RVO.RVODestinationCrowdedBehavior.JobDensityCheck.quadtree	jobdensitycheck.html#quadtree	
Pathfinding.RVO.RVODestinationCrowdedBehavior.MaximumCirclePackingDensity	rvodestinationcrowdedbehavior.html#MaximumCirclePackingDensity	See <a href="https://en.wikipedia.org/wiki/Circle_packing">https://en.wikipedia.org/wiki/Circle_packing</a>.
Pathfinding.RVO.RVODestinationCrowdedBehavior.MoveBackPriority	rvodestinationcrowdedbehavior.html#MoveBackPriority	
Pathfinding.RVO.RVODestinationCrowdedBehavior.StoppedPriority	rvodestinationcrowdedbehavior.html#StoppedPriority	
Pathfinding.RVO.RVODestinationCrowdedBehavior.densityThreshold	rvodestinationcrowdedbehavior.html#densityThreshold	The threshold for when to stop. \n\nSee the class description for more info.
Pathfinding.RVO.RVODestinationCrowdedBehavior.enabled	rvodestinationcrowdedbehavior.html#enabled	Enables or disables this module.
Pathfinding.RVO.RVODestinationCrowdedBehavior.lastJobDensityResult	rvodestinationcrowdedbehavior.html#lastJobDensityResult	
Pathfinding.RVO.RVODestinationCrowdedBehavior.lastShouldStopDestination	rvodestinationcrowdedbehavior.html#lastShouldStopDestination	
Pathfinding.RVO.RVODestinationCrowdedBehavior.lastShouldStopResult	rvodestinationcrowdedbehavior.html#lastShouldStopResult	
Pathfinding.RVO.RVODestinationCrowdedBehavior.progressAverage	rvodestinationcrowdedbehavior.html#progressAverage	
Pathfinding.RVO.RVODestinationCrowdedBehavior.reachedDestination	rvodestinationcrowdedbehavior.html#reachedDestination	True if the agent has reached its destination. \n\nIf the agents destination changes this may return false until the next frame. Note that changing the destination every frame may cause this value to never return true.\n\nTrue will be returned if the agent has stopped due to being close enough to the destination. This may be quite some distance away if there are many other agents around the destination.\n\n[more in online documentation]
Pathfinding.RVO.RVODestinationCrowdedBehavior.reachedDestinationPoint	rvodestinationcrowdedbehavior.html#reachedDestinationPoint	
Pathfinding.RVO.RVODestinationCrowdedBehavior.returnAfterBeingPushedAway	rvodestinationcrowdedbehavior.html#returnAfterBeingPushedAway	If true, the agent will start to move to the destination again if it determines that it is now less crowded. \n\nIf false and the destination becomes less crowded (or if the agent is pushed away from the destination in some way), then the agent will still stay put.
Pathfinding.RVO.RVODestinationCrowdedBehavior.shouldStopDelayTimer	rvodestinationcrowdedbehavior.html#shouldStopDelayTimer	
Pathfinding.RVO.RVODestinationCrowdedBehavior.timer1	rvodestinationcrowdedbehavior.html#timer1	
Pathfinding.RVO.RVODestinationCrowdedBehavior.wasEnabled	rvodestinationcrowdedbehavior.html#wasEnabled	
Pathfinding.RVO.RVODestinationCrowdedBehavior.wasStopped	rvodestinationcrowdedbehavior.html#wasStopped	
Pathfinding.RVO.RVOLayer	rvo.html#RVOLayer	
Pathfinding.RVO.RVONavmesh.wallHeight	rvonavmesh.html#wallHeight	Height of the walls added for each obstacle edge. \n\nIf a graph contains overlapping regions (e.g multiple floor in a building) you should set this low enough so that edges on different levels do not interfere, but high enough so that agents cannot move over them by mistake.
Pathfinding.RVO.RVOObstacle.ExecuteInEditor	rvoobstacle.html#ExecuteInEditor	Enable executing in editor to draw gizmos. \n\nIf enabled, the CreateObstacles function will be executed in the editor as well in order to draw gizmos.
Pathfinding.RVO.RVOObstacle.Height	rvoobstacle.html#Height	
Pathfinding.RVO.RVOObstacle.LocalCoordinates	rvoobstacle.html#LocalCoordinates	If enabled, all coordinates are handled as local.
Pathfinding.RVO.RVOObstacle.ObstacleVertexWinding	rvoobstacle.html#ObstacleVertexWinding	RVO Obstacle Modes. \n\nDetermines winding order of obstacle vertices
Pathfinding.RVO.RVOObstacle.StaticObstacle	rvoobstacle.html#StaticObstacle	Static or dynamic. \n\nThis determines if the obstacle can be updated by e.g moving the transform around in the scene.
Pathfinding.RVO.RVOObstacle.layer	rvoobstacle.html#layer	
Pathfinding.RVO.RVOObstacle.obstacleMode	rvoobstacle.html#obstacleMode	Mode of the obstacle. \n\nDetermines winding order of the vertices
Pathfinding.RVO.RVOObstacleCache.MarkerAllocate	rvoobstaclecache.html#MarkerAllocate	
Pathfinding.RVO.RVOObstacleCache.ObstacleSegment.vertex1	obstaclesegment.html#vertex1	
Pathfinding.RVO.RVOObstacleCache.ObstacleSegment.vertex1LinkId	obstaclesegment.html#vertex1LinkId	
Pathfinding.RVO.RVOObstacleCache.ObstacleSegment.vertex2	obstaclesegment.html#vertex2	
Pathfinding.RVO.RVOObstacleCache.ObstacleSegment.vertex2LinkId	obstaclesegment.html#vertex2LinkId	
Pathfinding.RVO.RVOQuadtreeBurst.BitPackingMask	rvoquadtreeburst.html#BitPackingMask	
Pathfinding.RVO.RVOQuadtreeBurst.BitPackingShift	rvoquadtreeburst.html#BitPackingShift	
Pathfinding.RVO.RVOQuadtreeBurst.ChildLookup	rvoquadtreeburst.html#ChildLookup	For a given number, contains the index of the first non-zero bit. \n\nOnly the values 0 through 15 are used when movementPlane is XZ or XY.\n\nUse bytes instead of ints to save some precious L1 cache memory.
Pathfinding.RVO.RVOQuadtreeBurst.DebugDrawJob.draw	debugdrawjob.html#draw	
Pathfinding.RVO.RVOQuadtreeBurst.DebugDrawJob.quadtree	debugdrawjob.html#quadtree	
Pathfinding.RVO.RVOQuadtreeBurst.DistanceInfinity	rvoquadtreeburst.html#DistanceInfinity	A very large distance. \n\nUsed as a sentinel value in the QueryKNearest method. We don't use actual infinity, because the code may be compiled using FastMath, which makes the compiler assume that infinities do not exist. This should be much larger than any distance used in practice.
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.agentPositions	jobbuild.html#agentPositions	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.agentRadii	jobbuild.html#agentRadii	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.agentSpeeds	jobbuild.html#agentSpeeds	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.agentVersions	jobbuild.html#agentVersions	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.agents	jobbuild.html#agents	Length should be greater or equal to agentPositions.Length.
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.movementPlane	jobbuild.html#movementPlane	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.numAgents	jobbuild.html#numAgents	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outAgentCount	jobbuild.html#outAgentCount	Should have size 1.
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outAgentPositions	jobbuild.html#outAgentPositions	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outAgentRadii	jobbuild.html#outAgentRadii	
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outArea	jobbuild.html#outArea	Should have size: InnerNodeCountUpperBound(numAgents)
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outBoundingBox	jobbuild.html#outBoundingBox	Should have size 2.
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outChildPointers	jobbuild.html#outChildPointers	Should have size: InnerNodeCountUpperBound(numAgents)
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outMaxRadius	jobbuild.html#outMaxRadius	Should have size: InnerNodeCountUpperBound(numAgents)
Pathfinding.RVO.RVOQuadtreeBurst.JobBuild.outMaxSpeeds	jobbuild.html#outMaxSpeeds	Should have size: InnerNodeCountUpperBound(numAgents)
Pathfinding.RVO.RVOQuadtreeBurst.LeafNodeBit	rvoquadtreeburst.html#LeafNodeBit	
Pathfinding.RVO.RVOQuadtreeBurst.LeafSize	rvoquadtreeburst.html#LeafSize	
Pathfinding.RVO.RVOQuadtreeBurst.MaxAgents	rvoquadtreeburst.html#MaxAgents	
Pathfinding.RVO.RVOQuadtreeBurst.MaxDepth	rvoquadtreeburst.html#MaxDepth	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.agentRadius	quadtreequery.html#agentRadius	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.layerMask	quadtreequery.html#layerMask	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.layers	quadtreequery.html#layers	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.maxCount	quadtreequery.html#maxCount	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.outputStartIndex	quadtreequery.html#outputStartIndex	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.position	quadtreequery.html#position	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.result	quadtreequery.html#result	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.resultDistances	quadtreequery.html#resultDistances	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.speed	quadtreequery.html#speed	
Pathfinding.RVO.RVOQuadtreeBurst.QuadtreeQuery.timeHorizon	quadtreequery.html#timeHorizon	
Pathfinding.RVO.RVOQuadtreeBurst.agentCountBuffer	rvoquadtreeburst.html#agentCountBuffer	
Pathfinding.RVO.RVOQuadtreeBurst.agentPositions	rvoquadtreeburst.html#agentPositions	
Pathfinding.RVO.RVOQuadtreeBurst.agentRadii	rvoquadtreeburst.html#agentRadii	
Pathfinding.RVO.RVOQuadtreeBurst.agents	rvoquadtreeburst.html#agents	
Pathfinding.RVO.RVOQuadtreeBurst.boundingBoxBuffer	rvoquadtreeburst.html#boundingBoxBuffer	
Pathfinding.RVO.RVOQuadtreeBurst.bounds	rvoquadtreeburst.html#bounds	
Pathfinding.RVO.RVOQuadtreeBurst.childPointers	rvoquadtreeburst.html#childPointers	
Pathfinding.RVO.RVOQuadtreeBurst.maxRadius	rvoquadtreeburst.html#maxRadius	
Pathfinding.RVO.RVOQuadtreeBurst.maxSpeeds	rvoquadtreeburst.html#maxSpeeds	
Pathfinding.RVO.RVOQuadtreeBurst.movementPlane	rvoquadtreeburst.html#movementPlane	
Pathfinding.RVO.RVOQuadtreeBurst.nodeAreas	rvoquadtreeburst.html#nodeAreas	
Pathfinding.RVO.RVOSimulator.active	rvosimulator.html#active	First RVOSimulator in the scene (usually there is only one)
Pathfinding.RVO.RVOSimulator.desiredSimulationFPS	rvosimulator.html#desiredSimulationFPS	Desired FPS for rvo simulation. \n\nIt is usually not necessary to run a crowd simulation at a very high fps. Usually 10-30 fps is enough, but it can be increased for better quality. The rvo simulation will never run at a higher fps than the game
Pathfinding.RVO.RVOSimulator.doubleBuffering	rvosimulator.html#doubleBuffering	Calculate local avoidance in between frames. \n\nIf this is enabled and multithreading is used, the local avoidance calculations will continue to run until the next frame instead of waiting for them to be done the same frame. This can increase the performance but it can make the agents seem a little less responsive.\n\nThis will only be read at Awake. \n\n[more in online documentation]
Pathfinding.RVO.RVOSimulator.drawQuadtree	rvosimulator.html#drawQuadtree	
Pathfinding.RVO.RVOSimulator.hardCollisions	rvosimulator.html#hardCollisions	Prevent agent overlap more aggressively. \n\nThis will it much harder for agents to overlap, even in crowded scenarios. It is particularly noticable when running at a low simulation fps. This does not influence agent avoidance when the agents are not overlapping.\n\nEnabling this has a small performance penalty, usually not high enough to care about.\n\nDisabling this may be beneficial if you want softer behaviour when larger groups of agents collide.
Pathfinding.RVO.RVOSimulator.movementPlane	rvosimulator.html#movementPlane	Determines if the XY (2D) or XZ (3D) plane is used for movement. \n\nFor 2D games you would set this to XY and for 3D games you would usually set it to XZ.
Pathfinding.RVO.RVOSimulator.simulatorBurst	rvosimulator.html#simulatorBurst	Reference to the internal simulator.
Pathfinding.RVO.RVOSimulator.symmetryBreakingBias	rvosimulator.html#symmetryBreakingBias	Bias agents to pass each other on the right side. \n\nIf the desired velocity of an agent puts it on a collision course with another agent or an obstacle its desired velocity will be rotated this number of radians (1 radian is approximately 57°) to the right. This helps to break up symmetries and makes it possible to resolve some situations much faster.\n\nWhen many agents have the same goal this can however have the side effect that the group clustered around the target point may as a whole start to spin around the target point.\n\nRecommended values are in the range of 0 to 0.2.\n\nIf this value is negative, the agents will be biased towards passing each other on the left side instead.
Pathfinding.RVO.RVOSimulator.useNavmeshAsObstacle	rvosimulator.html#useNavmeshAsObstacle	Allows the local avoidance system to take the edges of the navmesh into account. \n\nThis will make agents try to avoid moving into, and getting pushed into the borders of the navmesh.\n\nThis works best on navmesh/recast graphs, but can also be used on grid graphs.\n\nEnabling this has a performance impact.\n\n[more in online documentation]\nIf you are writing your own movement script, you must call RVOController.SetObstacleQuery every frame for the navmesh obstacle detection to work.
Pathfinding.RVO.RVOSimulator.workerThreads	rvosimulator.html#workerThreads	Number of RVO worker threads. \n\nIf set to None, no multithreading will be used. Using multithreading can significantly improve performance by offloading work to other CPU cores.\n\n[more in online documentation]
Pathfinding.RVO.RVOSquareObstacle.ExecuteInEditor	rvosquareobstacle.html#ExecuteInEditor	Enable executing in editor to draw gizmos. \n\nIf enabled, the CreateObstacles function will be executed in the editor as well in order to draw gizmos.
Pathfinding.RVO.RVOSquareObstacle.Height	rvosquareobstacle.html#Height	
Pathfinding.RVO.RVOSquareObstacle.LocalCoordinates	rvosquareobstacle.html#LocalCoordinates	If enabled, all coordinates are handled as local.
Pathfinding.RVO.RVOSquareObstacle.StaticObstacle	rvosquareobstacle.html#StaticObstacle	Static or dynamic. \n\nThis determines if the obstacle can be updated by e.g moving the transform around in the scene.
Pathfinding.RVO.RVOSquareObstacle.center	rvosquareobstacle.html#center	Center of the square.
Pathfinding.RVO.RVOSquareObstacle.height	rvosquareobstacle.html#height	Height of the obstacle.
Pathfinding.RVO.RVOSquareObstacle.size	rvosquareobstacle.html#size	Size of the square.
Pathfinding.RVO.ReachedEndOfPath	rvo.html#ReachedEndOfPath	Indicates if the agent has reached the end of its path, or been blocked by other agents. \n\nIn the video below, the agents will get a red ring around them for the Reached state, and a brown ring for the ReachedSoon state.\n\n <b>[video in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.Agent.AgentIndex	agent.html#AgentIndex	Internal index of the agent. \n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.Agent.AgentTimeHorizon	agent.html#AgentTimeHorizon	Max number of estimated seconds to look into the future for collisions with agents. \n\nAs it turns out, this variable is also very good for controling agent avoidance priorities. Agents with lower values will avoid other agents less and thus you can make 'high priority agents' by giving them a lower value.
Pathfinding.RVO.SimulatorBurst.Agent.AvoidingAnyAgents	agent.html#AvoidingAnyAgents	True if the agent's movement is affected by any other agents or obstacles. \n\nIf the agent is all alone, and can just move in a straight line to its target, this will be false. If it has to adjust its velocity, even slightly, to avoid collisions, this will be true.
Pathfinding.RVO.SimulatorBurst.Agent.CalculatedEffectivelyReachedDestination	agent.html#CalculatedEffectivelyReachedDestination	
Pathfinding.RVO.SimulatorBurst.Agent.CalculatedSpeed	agent.html#CalculatedSpeed	Optimal speed of the agent to avoid collisions. \n\nThe movement script should move towards CalculatedTargetPoint with this speed.
Pathfinding.RVO.SimulatorBurst.Agent.CalculatedTargetPoint	agent.html#CalculatedTargetPoint	Optimal point to move towards to avoid collisions. \n\nThe movement script should move towards this point with a speed of CalculatedSpeed.\n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.Agent.CollidesWith	agent.html#CollidesWith	Layer mask specifying which layers this agent will avoid. \n\nYou can set it as CollidesWith = RVOLayer.DefaultAgent | RVOLayer.Layer3 | RVOLayer.Layer6 ...\n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.Agent.DebugFlags	agent.html#DebugFlags	Draw debug information in the scene view.
Pathfinding.RVO.SimulatorBurst.Agent.DestroyedCallback	agent.html#DestroyedCallback	Callback which will be called right the agent is removed from the simulation. \n\nThis agent should not be used anymore after this callback has been called.
Pathfinding.RVO.SimulatorBurst.Agent.FlowFollowingStrength	agent.html#FlowFollowingStrength	Determines how strongly this agent just follows the flow instead of making other agents avoid it. \n\nThe default value is 0, if it is greater than zero (up to the maximum value of 1) other agents will not avoid this character as much. However it works in a different way to Priority.\n\nA group of agents with FlowFollowingStrength set to a high value that all try to reach the same point will end up just settling to stationary positions around that point, none will push the others away to any significant extent. This is tricky to achieve with priorities as priorities are all relative, so setting all agents to a low priority is the same thing as not changing priorities at all.\n\nShould be a value in the range [0, 1].
Pathfinding.RVO.SimulatorBurst.Agent.Height	agent.html#Height	Height of the agent in world units. \n\nAgents are modelled as circles/cylinders.
Pathfinding.RVO.SimulatorBurst.Agent.HierarchicalNodeIndex	agent.html#HierarchicalNodeIndex	
Pathfinding.RVO.SimulatorBurst.Agent.Layer	agent.html#Layer	Specifies the avoidance layer for this agent. \n\nThe CollidesWith mask on other agents will determine if they will avoid this agent.
Pathfinding.RVO.SimulatorBurst.Agent.Locked	agent.html#Locked	Locked agents will be assumed not to move.
Pathfinding.RVO.SimulatorBurst.Agent.MaxNeighbours	agent.html#MaxNeighbours	Max number of agents to take into account. \n\nDecreasing this value can lead to better performance, increasing it can lead to better quality of the simulation.
Pathfinding.RVO.SimulatorBurst.Agent.MovementPlane	agent.html#MovementPlane	Plane in which the agent moves. \n\nLocal avoidance calculations are always done in 2D and this plane determines how to convert from 3D to 2D.\n\nIn a typical 3D game the agents move in the XZ plane and in a 2D game they move in the XY plane. By default this is set to the XZ plane.\n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.Agent.NeighbourCount	agent.html#NeighbourCount	Number of neighbours that the agent took into account during the last simulation step.
Pathfinding.RVO.SimulatorBurst.Agent.ObstacleTimeHorizon	agent.html#ObstacleTimeHorizon	Max number of estimated seconds to look into the future for collisions with obstacles.
Pathfinding.RVO.SimulatorBurst.Agent.Position	agent.html#Position	Position of the agent. \n\nThe agent does not move by itself, a movement script has to be responsible for reading the CalculatedTargetPoint and CalculatedSpeed properties and move towards that point with that speed. This property should ideally be set every frame.
Pathfinding.RVO.SimulatorBurst.Agent.PreCalculationCallback	agent.html#PreCalculationCallback	Callback which will be called right before avoidance calculations are started. \n\nUsed to update the other properties with the most up to date values
Pathfinding.RVO.SimulatorBurst.Agent.Priority	agent.html#Priority	How strongly other agents will avoid this agent. \n\nUsually a value between 0 and 1. Agents with similar priorities will avoid each other with an equal strength. If an agent sees another agent with a higher priority than itself it will avoid that agent more strongly. In the extreme case (e.g this agent has a priority of 0 and the other agent has a priority of 1) it will treat the other agent as being a moving obstacle. Similarly if an agent sees another agent with a lower priority than itself it will avoid that agent less.\n\nIn general the avoidance strength for this agent is: <b>[code in online documentation]</b>
Pathfinding.RVO.SimulatorBurst.Agent.Radius	agent.html#Radius	Radius of the agent in world units. \n\nAgents are modelled as circles/cylinders.
Pathfinding.RVO.SimulatorBurst.Agent.agentIndex	agent.html#agentIndex	
Pathfinding.RVO.SimulatorBurst.Agent.simulator	agent.html#simulator	
Pathfinding.RVO.SimulatorBurst.AgentBounds	simulatorburst.html#AgentBounds	
Pathfinding.RVO.SimulatorBurst.AgentCount	simulatorburst.html#AgentCount	Number of agents in the simulation.
Pathfinding.RVO.SimulatorBurst.AgentData.agentObstacleMapping	agentdata.html#agentObstacleMapping	Which obstacle data in the ObstacleData.obstacles array the agent should use for avoidance.
Pathfinding.RVO.SimulatorBurst.AgentData.agentTimeHorizon	agentdata.html#agentTimeHorizon	
Pathfinding.RVO.SimulatorBurst.AgentData.allowedVelocityDeviationAngles	agentdata.html#allowedVelocityDeviationAngles	x = signed left angle in radians, y = signed right angle in radians (should be greater than x)
Pathfinding.RVO.SimulatorBurst.AgentData.collidesWith	agentdata.html#collidesWith	
Pathfinding.RVO.SimulatorBurst.AgentData.collisionNormal	agentdata.html#collisionNormal	
Pathfinding.RVO.SimulatorBurst.AgentData.debugFlags	agentdata.html#debugFlags	
Pathfinding.RVO.SimulatorBurst.AgentData.desiredSpeed	agentdata.html#desiredSpeed	
Pathfinding.RVO.SimulatorBurst.AgentData.endOfPath	agentdata.html#endOfPath	
Pathfinding.RVO.SimulatorBurst.AgentData.flowFollowingStrength	agentdata.html#flowFollowingStrength	
Pathfinding.RVO.SimulatorBurst.AgentData.height	agentdata.html#height	
Pathfinding.RVO.SimulatorBurst.AgentData.hierarchicalNodeIndex	agentdata.html#hierarchicalNodeIndex	
Pathfinding.RVO.SimulatorBurst.AgentData.layer	agentdata.html#layer	
Pathfinding.RVO.SimulatorBurst.AgentData.locked	agentdata.html#locked	
Pathfinding.RVO.SimulatorBurst.AgentData.manuallyControlled	agentdata.html#manuallyControlled	
Pathfinding.RVO.SimulatorBurst.AgentData.maxNeighbours	agentdata.html#maxNeighbours	
Pathfinding.RVO.SimulatorBurst.AgentData.maxSpeed	agentdata.html#maxSpeed	
Pathfinding.RVO.SimulatorBurst.AgentData.movementPlane	agentdata.html#movementPlane	
Pathfinding.RVO.SimulatorBurst.AgentData.obstacleTimeHorizon	agentdata.html#obstacleTimeHorizon	
Pathfinding.RVO.SimulatorBurst.AgentData.position	agentdata.html#position	
Pathfinding.RVO.SimulatorBurst.AgentData.priority	agentdata.html#priority	
Pathfinding.RVO.SimulatorBurst.AgentData.radius	agentdata.html#radius	
Pathfinding.RVO.SimulatorBurst.AgentData.targetPoint	agentdata.html#targetPoint	
Pathfinding.RVO.SimulatorBurst.AgentData.version	agentdata.html#version	
Pathfinding.RVO.SimulatorBurst.AgentNeighbourLookup.neighbours	agentneighbourlookup.html#neighbours	
Pathfinding.RVO.SimulatorBurst.AgentOutputData.blockedByAgents	agentoutputdata.html#blockedByAgents	
Pathfinding.RVO.SimulatorBurst.AgentOutputData.effectivelyReachedDestination	agentoutputdata.html#effectivelyReachedDestination	
Pathfinding.RVO.SimulatorBurst.AgentOutputData.forwardClearance	agentoutputdata.html#forwardClearance	
Pathfinding.RVO.SimulatorBurst.AgentOutputData.numNeighbours	agentoutputdata.html#numNeighbours	
Pathfinding.RVO.SimulatorBurst.AgentOutputData.speed	agentoutputdata.html#speed	
Pathfinding.RVO.SimulatorBurst.AgentOutputData.targetPoint	agentoutputdata.html#targetPoint	
Pathfinding.RVO.SimulatorBurst.DesiredDeltaTime	simulatorburst.html#DesiredDeltaTime	Time in seconds between each simulation step. \n\nThis is the desired delta time, the simulation will never run at a higher fps than the rate at which the Update function is called.
Pathfinding.RVO.SimulatorBurst.HardCollisions	simulatorburst.html#HardCollisions	Use hard collisions.
Pathfinding.RVO.SimulatorBurst.HorizonAgentData.horizonMaxAngle	horizonagentdata.html#horizonMaxAngle	
Pathfinding.RVO.SimulatorBurst.HorizonAgentData.horizonMinAngle	horizonagentdata.html#horizonMinAngle	
Pathfinding.RVO.SimulatorBurst.HorizonAgentData.horizonSide	horizonagentdata.html#horizonSide	
Pathfinding.RVO.SimulatorBurst.MaxBlockingAgentCount	simulatorburst.html#MaxBlockingAgentCount	
Pathfinding.RVO.SimulatorBurst.MaxNeighbourCount	simulatorburst.html#MaxNeighbourCount	
Pathfinding.RVO.SimulatorBurst.MaxObstacleVertices	simulatorburst.html#MaxObstacleVertices	
Pathfinding.RVO.SimulatorBurst.MovementPlane	simulatorburst.html#MovementPlane	
Pathfinding.RVO.SimulatorBurst.ObstacleData.obstacleVertexGroups	obstacledata.html#obstacleVertexGroups	Groups of vertices representing obstacles. \n\nAn obstacle is either a cycle or a chain of vertices
Pathfinding.RVO.SimulatorBurst.ObstacleData.obstacleVertices	obstacledata.html#obstacleVertices	Vertices of all obstacles.
Pathfinding.RVO.SimulatorBurst.ObstacleData.obstacles	obstacledata.html#obstacles	Obstacle sets, each one is represented as a set of obstacle vertex groups.
Pathfinding.RVO.SimulatorBurst.SymmetryBreakingBias	simulatorburst.html#SymmetryBreakingBias	Bias agents to pass each other on the right side. \n\nIf the desired velocity of an agent puts it on a collision course with another agent or an obstacle its desired velocity will be rotated this number of radians (1 radian is approximately 57°) to the right. This helps to break up symmetries and makes it possible to resolve some situations much faster.\n\nWhen many agents have the same goal this can however have the side effect that the group clustered around the target point may as a whole start to spin around the target point.\n\nRecommended values are in the range of 0 to 0.2.\n\nIf this value is negative, the agents will be biased towards passing each other on the left side instead.
Pathfinding.RVO.SimulatorBurst.TemporaryAgentData.collisionVelocityOffsets	temporaryagentdata.html#collisionVelocityOffsets	
Pathfinding.RVO.SimulatorBurst.TemporaryAgentData.currentVelocity	temporaryagentdata.html#currentVelocity	
Pathfinding.RVO.SimulatorBurst.TemporaryAgentData.desiredTargetPointInVelocitySpace	temporaryagentdata.html#desiredTargetPointInVelocitySpace	
Pathfinding.RVO.SimulatorBurst.TemporaryAgentData.desiredVelocity	temporaryagentdata.html#desiredVelocity	
Pathfinding.RVO.SimulatorBurst.TemporaryAgentData.neighbours	temporaryagentdata.html#neighbours	
Pathfinding.RVO.SimulatorBurst.UseNavmeshAsObstacle	simulatorburst.html#UseNavmeshAsObstacle	
Pathfinding.RVO.SimulatorBurst.agentDestroyCallbacks	simulatorburst.html#agentDestroyCallbacks	
Pathfinding.RVO.SimulatorBurst.agentPreCalculationCallbacks	simulatorburst.html#agentPreCalculationCallbacks	
Pathfinding.RVO.SimulatorBurst.anyAgentsInSimulation	simulatorburst.html#anyAgentsInSimulation	
Pathfinding.RVO.SimulatorBurst.debugDrawingScope	simulatorburst.html#debugDrawingScope	Scope for drawing gizmos even on frames during which the simulation is not running. \n\nThis is used to draw the obstacles, quadtree and agent debug lines.
Pathfinding.RVO.SimulatorBurst.desiredDeltaTime	simulatorburst.html#desiredDeltaTime	Inverse desired simulation fps. \n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.drawQuadtree	simulatorburst.html#drawQuadtree	
Pathfinding.RVO.SimulatorBurst.freeAgentIndices	simulatorburst.html#freeAgentIndices	
Pathfinding.RVO.SimulatorBurst.horizonAgentData	simulatorburst.html#horizonAgentData	
Pathfinding.RVO.SimulatorBurst.movementPlane	simulatorburst.html#movementPlane	Determines if the XY (2D) or XZ (3D) plane is used for movement.
Pathfinding.RVO.SimulatorBurst.numAgents	simulatorburst.html#numAgents	Number of agents in this simulation.
Pathfinding.RVO.SimulatorBurst.outputData	simulatorburst.html#outputData	Internal simulation data. \n\nCan be used if you need very high performance access to the agent data. Normally you would use the SimulatorBurst.Agent class instead (implements the IAgent interface).\n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.quadtree	simulatorburst.html#quadtree	Quadtree for this simulation. \n\nUsed internally by the simulation to perform fast neighbour lookups for each agent. Please only read from this tree, do not rebuild it since that can interfere with the simulation. It is rebuilt when necessary.\n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.rwLock	simulatorburst.html#rwLock	Used to synchronize access to the simulation data.
Pathfinding.RVO.SimulatorBurst.simulationData	simulatorburst.html#simulationData	Internal simulation data. \n\nCan be used if you need very high performance access to the agent data. Normally you would use the SimulatorBurst.Agent class instead (implements the IAgent interface).\n\n[more in online documentation]
Pathfinding.RVO.SimulatorBurst.temporaryAgentData	simulatorburst.html#temporaryAgentData	
Pathfinding.RVO.UnmanagedObstacle.groupsAllocation	unmanagedobstacle.html#groupsAllocation	The allocation in ObstacleData.obstacles which represents the obstacle groups.
Pathfinding.RVO.UnmanagedObstacle.verticesAllocation	unmanagedobstacle.html#verticesAllocation	The allocation in ObstacleData.obstacleVertices which represents all vertices used for these obstacles.
Pathfinding.RVO.XYMovementPlane.matrix	xymovementplane.html#matrix	Maps from 2D (X, Y, 0) coordinates to world coordinates.
Pathfinding.RVO.XZMovementPlane.matrix	xzmovementplane.html#matrix	Maps from 2D (X, Y, 0) coordinates to world coordinates.
Pathfinding.RVOSimulatorEditor.movementPlaneOptions	rvosimulatoreditor.html#movementPlaneOptions	
Pathfinding.RadiusModifier.Order	radiusmodifier.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.RadiusModifier.TangentType	radiusmodifier.html#TangentType	
Pathfinding.RadiusModifier.a1	radiusmodifier.html#a1	
Pathfinding.RadiusModifier.a2	radiusmodifier.html#a2	
Pathfinding.RadiusModifier.detail	radiusmodifier.html#detail	Detail of generated circle segments. \n\nMeasured as steps per full circle.\n\nIt is more performant to use a low value. For movement, using a high value will barely improve path quality.
Pathfinding.RadiusModifier.dir	radiusmodifier.html#dir	
Pathfinding.RadiusModifier.radi	radiusmodifier.html#radi	
Pathfinding.RadiusModifier.radius	radiusmodifier.html#radius	Radius of the circle segments generated. \n\nUsually similar to the character radius.
Pathfinding.RandomPath.aim	randompath.html#aim	An aim can be used to guide the pathfinder to not take totally random paths. \n\nFor example you might want your AI to continue in generally the same direction as before, then you can specify aim to be transform.postion + transform.forward*10 which will make it more often take paths nearer that point \n\n[more in online documentation]
Pathfinding.RandomPath.aimStrength	randompath.html#aimStrength	If an aim is set, the higher this value is, the more it will try to reach aim. \n\nRecommended values are between 0 and 10.
Pathfinding.RandomPath.chosenPathNodeGScore	randompath.html#chosenPathNodeGScore	
Pathfinding.RandomPath.chosenPathNodeIndex	randompath.html#chosenPathNodeIndex	Currently chosen end node.
Pathfinding.RandomPath.endPointKnownBeforeCalculation	randompath.html#endPointKnownBeforeCalculation	True if this path type has a well defined end point, even before calculation starts. \n\nThis is for example true for the ABPath type, but false for the RandomPath type.
Pathfinding.RandomPath.hasEndPoint	randompath.html#hasEndPoint	Determines if a search for an end node should be done. \n\nSet by different path types. \n\n[more in online documentation]
Pathfinding.RandomPath.maxGScore	randompath.html#maxGScore	The G score of maxGScorePathNodeIndex.
Pathfinding.RandomPath.maxGScorePathNodeIndex	randompath.html#maxGScorePathNodeIndex	The node with the highest G score which is still lower than searchLength. \n\nUsed as a backup if a node with a G score higher than searchLength could not be found
Pathfinding.RandomPath.nodesEvaluatedRep	randompath.html#nodesEvaluatedRep	
Pathfinding.RandomPath.rnd	randompath.html#rnd	Random number generator.
Pathfinding.RandomPath.searchLength	randompath.html#searchLength	G score to stop searching at. \n\nThe G score is rougly the distance to get from the start node to a node multiplied by 1000 (per default, see Pathfinding.Int3.Precision), plus any penalties.\n\n <b>[video in online documentation]</b>
Pathfinding.RandomPath.spread	randompath.html#spread	All G scores between searchLength and searchLength+spread are valid end points, a random one of them is chosen as the final point. \n\nOn grid graphs a low spread usually works (but keep it higher than nodeSize*1000 since that it the default cost of moving between two nodes), on NavMesh graphs I would recommend a higher spread so it can evaluate more nodes.\n\n <b>[video in online documentation]</b>
Pathfinding.RaycastModifier.DPCosts	raycastmodifier.html#DPCosts	
Pathfinding.RaycastModifier.DPParents	raycastmodifier.html#DPParents	
Pathfinding.RaycastModifier.Filter.cachedDelegate	filter.html#cachedDelegate	
Pathfinding.RaycastModifier.Filter.path	filter.html#path	
Pathfinding.RaycastModifier.Order	raycastmodifier.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.RaycastModifier.Quality	raycastmodifier.html#Quality	
Pathfinding.RaycastModifier.buffer	raycastmodifier.html#buffer	
Pathfinding.RaycastModifier.cachedFilter	raycastmodifier.html#cachedFilter	
Pathfinding.RaycastModifier.cachedNNConstraint	raycastmodifier.html#cachedNNConstraint	
Pathfinding.RaycastModifier.iterationsByQuality	raycastmodifier.html#iterationsByQuality	
Pathfinding.RaycastModifier.mask	raycastmodifier.html#mask	Layer mask used for physics raycasting. \n\nAll objects with layers that are included in this mask will be treated as obstacles. If you are using a grid graph you usually want this to be the same as the mask in the grid graph's 'Collision Testing' settings.
Pathfinding.RaycastModifier.quality	raycastmodifier.html#quality	Higher quality modes will try harder to find a shorter path. \n\nHigher qualities may be significantly slower than low quality.  <b>[image in online documentation]</b>
Pathfinding.RaycastModifier.raycastOffset	raycastmodifier.html#raycastOffset	Offset from the original positions to perform the raycast. \n\nCan be useful to avoid the raycast intersecting the ground or similar things you do not want to it intersect
Pathfinding.RaycastModifier.thickRaycast	raycastmodifier.html#thickRaycast	Checks around the line between two points, not just the exact line. \n\nMake sure the ground is either too far below or is not inside the mask since otherwise the raycast might always hit the ground.\n\n[more in online documentation]
Pathfinding.RaycastModifier.thickRaycastRadius	raycastmodifier.html#thickRaycastRadius	Distance from the ray which will be checked for colliders.
Pathfinding.RaycastModifier.use2DPhysics	raycastmodifier.html#use2DPhysics	Check for intersections with 2D colliders instead of 3D colliders. \n\nUseful for 2D games.\n\n[more in online documentation]
Pathfinding.RaycastModifier.useGraphRaycasting	raycastmodifier.html#useGraphRaycasting	Use raycasting on the graphs. \n\nOnly currently works with GridGraph and NavmeshGraph and RecastGraph.  [more in online documentation]
Pathfinding.RaycastModifier.useRaycasting	raycastmodifier.html#useRaycasting	Use Physics.Raycast to simplify the path.
Pathfinding.RecastGraph.BackgroundTraversability	recastgraph.html#BackgroundTraversability	Whether the base of the graph should default to being walkable or unwalkable. \n\n[more in online documentation]
Pathfinding.RecastGraph.CharacterRadiusInVoxels	recastgraph.html#CharacterRadiusInVoxels	Convert character radius to a number of voxels.
Pathfinding.RecastGraph.CollectionSettings.FilterMode	collectionsettings.html#FilterMode	Determines how the initial filtering of objects is done.
Pathfinding.RecastGraph.CollectionSettings.collectionMode	collectionsettings.html#collectionMode	Determines how the initial filtering of objects is done. \n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.colliderRasterizeDetail	collectionsettings.html#colliderRasterizeDetail	Controls detail on rasterization of sphere and capsule colliders. \n\nThe colliders will be approximated with polygons so that the max distance to the theoretical surface is less than 1/(this number of voxels).\n\nA higher value does not necessarily increase quality of the mesh, but a lower value will often speed it up.\n\nYou should try to keep this value as low as possible without affecting the mesh quality since that will yield the fastest scan times.\n\nThe default value is 1, which corresponds to a maximum error of 1 voxel. In most cases, increasing this to a value higher than 2 (corresponding to a maximum error of 0.5 voxels) is not useful.\n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.layerMask	collectionsettings.html#layerMask	Objects in all of these layers will be rasterized. \n\nWill only be used if collectionMode is set to Layers.\n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.onCollectMeshes	collectionsettings.html#onCollectMeshes	Callback for collecting custom scene meshes. \n\nThis callback will be called once when scanning the graph, to allow you to add custom meshes to the graph, and once every time a graph update happens. Use the RecastMeshGatherer class to add meshes that are to be rasterized.\n\n[more in online documentation]\n<b>[code in online documentation]</b>
Pathfinding.RecastGraph.CollectionSettings.physicsScene	collectionsettings.html#physicsScene	The physics scene for collecting colliders when scanning the graph. \n\nIf null (the default), the physics scene that the AstarPath component is part of will be used.\n\nYou typically don't have to set this, but it can be useful in some rare situations.\n\n[more in online documentation]\nOnly used if rasterizeColliders is enabled.\n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.physicsScene2D	collectionsettings.html#physicsScene2D	The physics scene for collecting 2D colliders when scanning the graph. \n\nIf null (the default), the physics scene that the AstarPath component is part of will be used.\n\nYou typically don't have to set this, but it can be useful in some rare situations.\n\n[more in online documentation]\nOnly used if rasterizeColliders is enabled.\n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.rasterizeColliders	collectionsettings.html#rasterizeColliders	Use colliders to calculate the navmesh. \n\nDepending on the dimensionMode, either 3D or 2D colliders will be rasterized.\n\nSphere/Capsule/Circle colliders will be approximated using polygons, with the precision specified in colliderRasterizeDetail.\n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.rasterizeMeshes	collectionsettings.html#rasterizeMeshes	Use scene meshes to calculate the navmesh. \n\nThis can get you higher precision than colliders, since colliders are typically very simplified versions of the mesh. However, it is often slower to scan, and graph updates can be particularly slow.\n\nThe reason that graph updates are slower is that there's no efficient way to find all meshes that intersect a given tile, so the graph has to iterate over all meshes in the scene just to find the ones relevant for the tiles that you want to update. Colliders, on the other hand, can be efficiently queried using the physics system.\n\nYou can disable this and attach a RecastNavmeshModifier component (with dynamic=false) to all meshes that you want to be included in the navmesh instead. That way they will be able to be efficiently queried for, without having to iterate through all meshes in the scene.\n\nIn 2D mode, this setting has no effect.
Pathfinding.RecastGraph.CollectionSettings.rasterizeTerrain	collectionsettings.html#rasterizeTerrain	Use terrains to calculate the navmesh. \n\nIn 2D mode, this setting has no effect.
Pathfinding.RecastGraph.CollectionSettings.rasterizeTrees	collectionsettings.html#rasterizeTrees	Rasterize tree colliders on terrains. \n\nIf the tree prefab has a collider, that collider will be rasterized. Otherwise a simple box collider will be used and the script will try to adjust it to the tree's scale, it might not do a very good job though so an attached collider is preferable.\n\n[more in online documentation]\nIn 2D mode, this setting has no effect.\n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.tagMask	collectionsettings.html#tagMask	Objects tagged with any of these tags will be rasterized. \n\nWill only be used if collectionMode is set to Tags.\n\n[more in online documentation]
Pathfinding.RecastGraph.CollectionSettings.terrainHeightmapDownsamplingFactor	collectionsettings.html#terrainHeightmapDownsamplingFactor	Controls how much to downsample the terrain's heightmap before generating the input mesh used for rasterization. \n\nA higher value is faster to scan but less accurate.
Pathfinding.RecastGraph.DimensionMode	recastgraph.html#DimensionMode	Whether to use 3D or 2D mode.
Pathfinding.RecastGraph.MaxTileConnectionEdgeDistance	recastgraph.html#MaxTileConnectionEdgeDistance	Maximum (vertical) distance between the sides of two nodes for them to be connected across a tile edge. \n\nWhen tiles are connected to each other, the nodes sometimes do not line up perfectly so some allowance must be made to allow tiles that do not match exactly to be connected with each other.
Pathfinding.RecastGraph.NavmeshCuttingCharacterRadius	recastgraph.html#NavmeshCuttingCharacterRadius	
Pathfinding.RecastGraph.PerLayerModification.Default	perlayermodification.html#Default	
Pathfinding.RecastGraph.PerLayerModification.layer	perlayermodification.html#layer	Unity layer that this modification applies to.
Pathfinding.RecastGraph.PerLayerModification.mode	perlayermodification.html#mode	Surface rasterization mode. \n\n[more in online documentation]
Pathfinding.RecastGraph.PerLayerModification.surfaceID	perlayermodification.html#surfaceID	Voxel area for mesh. \n\nThis area (not to be confused with pathfinding areas, this is only used when rasterizing meshes for the recast graph) field can be used to explicitly insert edges in the navmesh geometry or to make some parts of the mesh unwalkable.\n\nWhen rasterizing the world and two objects with different surface id values are adjacent to each other, a split in the navmesh geometry will be added between them, characters will still be able to walk between them, but this can be useful when working with navmesh updates.\n\nNavmesh updates which recalculate a whole tile (updatePhysics=True) are very slow So if there are special places which you know are going to be updated quite often, for example at a door opening (opened/closed door) you can use surface IDs to create splits on the navmesh for easier updating using normal graph updates (updatePhysics=False). See the below video for more information.\n\n  <b>[video in online documentation]</b>\n\nWhen mode is set to Mode.WalkableSurfaceWithTag then this value will be interpreted as a pathfinding tag. See Working with tags.\n\n[more in online documentation]
Pathfinding.RecastGraph.RecalculateNormals	recastgraph.html#RecalculateNormals	Determines how normals are calculated. \n\nDisable for spherical graphs or other complicated surfaces that allow the agents to e.g walk on walls or ceilings.\n\nBy default the normals of the mesh will be flipped so that they point as much as possible in the upwards direction. The normals are important when connecting adjacent nodes. Two adjacent nodes will only be connected if they are oriented the same way. This is particularly important if you have a navmesh on the walls or even on the ceiling of a room. Or if you are trying to make a spherical navmesh. If you do one of those things then you should set disable this setting and make sure the normals in your source mesh are properly set.\n\nIf you for example take a look at the image below. In the upper case then the nodes on the bottom half of the mesh haven't been connected with the nodes on the upper half because the normals on the lower half will have been modified to point inwards (as that is the direction that makes them face upwards the most) while the normals on the upper half point outwards. This causes the nodes to not connect properly along the seam. When this option is set to false instead the nodes are connected properly as in the original mesh all normals point outwards.  <b>[image in online documentation]</b>\n\nThe default value of this field is true to reduce the risk for errors in the common case. If a mesh is supplied that has all normals pointing downwards and this option is false, then some methods like PointOnNavmesh will not work correctly as they assume that the normals point upwards. For a more complicated surface like a spherical graph those methods make no sense anyway as there is no clear definition of what it means to be "inside" a triangle when there is no clear up direction.
Pathfinding.RecastGraph.RecastGraphScanPromise.Progress	recastgraphscanpromise.html#Progress	Returns the progress of the update. \n\nThis should be a value between 0 and 1.
Pathfinding.RecastGraph.RecastGraphScanPromise.cutSettings	recastgraphscanpromise.html#cutSettings	
Pathfinding.RecastGraph.RecastGraphScanPromise.emptyGraph	recastgraphscanpromise.html#emptyGraph	
Pathfinding.RecastGraph.RecastGraphScanPromise.graph	recastgraphscanpromise.html#graph	
Pathfinding.RecastGraph.RecastGraphScanPromise.meshesUnreadableAtRuntime	recastgraphscanpromise.html#meshesUnreadableAtRuntime	
Pathfinding.RecastGraph.RecastGraphScanPromise.progressSource	recastgraphscanpromise.html#progressSource	
Pathfinding.RecastGraph.RecastGraphScanPromise.tileLayout	recastgraphscanpromise.html#tileLayout	
Pathfinding.RecastGraph.RecastGraphScanPromise.tiles	recastgraphscanpromise.html#tiles	
Pathfinding.RecastGraph.RecastGraphUpdatePromise.graph	recastgraphupdatepromise.html#graph	
Pathfinding.RecastGraph.RecastGraphUpdatePromise.graphHash	recastgraphupdatepromise.html#graphHash	
Pathfinding.RecastGraph.RecastGraphUpdatePromise.graphUpdates	recastgraphupdatepromise.html#graphUpdates	
Pathfinding.RecastGraph.RecastGraphUpdatePromise.promises	recastgraphupdatepromise.html#promises	
Pathfinding.RecastGraph.RecastMovePromise.delta	recastmovepromise.html#delta	
Pathfinding.RecastGraph.RecastMovePromise.graph	recastmovepromise.html#graph	
Pathfinding.RecastGraph.RecastMovePromise.newTileRect	recastmovepromise.html#newTileRect	
Pathfinding.RecastGraph.RecastMovePromise.tileMeshes	recastmovepromise.html#tileMeshes	
Pathfinding.RecastGraph.RelevantGraphSurfaceMode	recastgraph.html#RelevantGraphSurfaceMode	
Pathfinding.RecastGraph.TileBorderSizeInVoxels	recastgraph.html#TileBorderSizeInVoxels	Number of extra voxels on each side of a tile to ensure accurate navmeshes near the tile border. \n\nThe width of a tile is expanded by 2 times this value (1x to the left and 1x to the right)
Pathfinding.RecastGraph.TileBorderSizeInWorldUnits	recastgraph.html#TileBorderSizeInWorldUnits	
Pathfinding.RecastGraph.TileWorldSizeX	recastgraph.html#TileWorldSizeX	Size of a tile in world units along the X axis.
Pathfinding.RecastGraph.TileWorldSizeZ	recastgraph.html#TileWorldSizeZ	Size of a tile in world units along the Z axis.
Pathfinding.RecastGraph.backgroundTraversability	recastgraph.html#backgroundTraversability	Whether the base of the graph should default to being walkable or unwalkable. \n\nThis is only used in 2D mode. In 3D mode, this setting has no effect.\n\nFor 2D games, it can be very useful to set the background to be walkable by default, and then constrain walkability using colliders.\n\nIf you don't want to use a walkable background, you can instead create colliders and attach a RecastNavmeshModifier with Surface Type set to Walkable Surface. These will then create walkable regions.\n\n[more in online documentation]
Pathfinding.RecastGraph.bounds	recastgraph.html#bounds	World bounding box for the graph. \n\nThis always contains the whole graph.\n\n[more in online documentation]\n <b>[image in online documentation]</b>
Pathfinding.RecastGraph.cellSize	recastgraph.html#cellSize	Voxel sample size (x,z). \n\nWhen generating a recast graph what happens is that the world is voxelized. You can think of this as constructing an approximation of the world out of lots of boxes. If you have played Minecraft it looks very similar (but with smaller boxes).  <b>[image in online documentation]</b>\n\nLower values will yield higher quality navmeshes, however the graph will be slower to scan.\n\n <b>[image in online documentation]</b>
Pathfinding.RecastGraph.characterRadius	recastgraph.html#characterRadius	Radius of the agent which will traverse the navmesh. \n\nThe navmesh will be eroded with this radius.\n\nThis value will be rounded up to the nearest multiple of cellSize.\n\n <b>[image in online documentation]</b>
Pathfinding.RecastGraph.collectionSettings	recastgraph.html#collectionSettings	Determines which objects are used to build the graph, when it is scanned. \n\nAlso contains some settings for how to convert objects into meshes. Spherical colliders, for example, need to be converted into a triangular mesh before they can be used in the graph.\n\n[more in online documentation]
Pathfinding.RecastGraph.colliderRasterizeDetail	recastgraph.html#colliderRasterizeDetail	Controls detail on rasterization of sphere and capsule colliders. \n\nThe colliders will be approximated with polygons so that the max distance to the theoretical surface is less than 1/(this number of voxels).\n\nA higher value does not necessarily increase quality of the mesh, but a lower value will often speed it up.\n\nYou should try to keep this value as low as possible without affecting the mesh quality since that will yield the fastest scan times.\n\nThe default value is 1, which corresponds to a maximum error of 1 voxel. In most cases, increasing this to a value higher than 2 (corresponding to a maximum error of 0.5 voxels) is not useful.\n\n[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.RecastGraph.contourMaxError	recastgraph.html#contourMaxError	Max distance from simplified edge to real edge. \n\nThis value is measured in voxels. So with the default value of 2 it means that the final navmesh contour may be at most 2 voxels (i.e 2 times cellSize) away from the border that was calculated when voxelizing the world. A higher value will yield a more simplified and cleaner navmesh while a lower value may capture more details. However a too low value will cause the individual voxels to be visible (see image below).\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RecastGraph.dimensionMode	recastgraph.html#dimensionMode	Whether to use 3D or 2D mode. \n\n[more in online documentation]
Pathfinding.RecastGraph.editorTileSize	recastgraph.html#editorTileSize	Size in voxels of a single tile. \n\nThis is the width of the tile.\n\n <b>[image in online documentation]</b>\n\nA large tile size can be faster to initially scan (but beware of out of memory issues if you try with a too large tile size in a large world) smaller tile sizes are (much) faster to update.\n\nDifferent tile sizes can affect the quality of paths. It is often good to split up huge open areas into several tiles for better quality paths, but too small tiles can also lead to effects looking like invisible obstacles. For more information about this take a look at Notes about navmesh graphs. Usually it is best to experiment and see what works best for your game.\n\nWhen scanning a recast graphs individual tiles can be calculated in parallel which can make it much faster to scan large worlds. When you want to recalculate a part of a recast graph, this can only be done on a tile-by-tile basis which means that if you often try to update a region of the recast graph much smaller than the tile size, then you will be doing a lot of unnecessary calculations. However if you on the other hand update regions of the recast graph that are much larger than the tile size then it may be slower than necessary as there is some overhead in having lots of tiles instead of a few larger ones (not that much though).\n\nRecommended values are between 64 and 256, but these are very soft limits. It is possible to use both larger and smaller values.
Pathfinding.RecastGraph.forcedBoundsCenter	recastgraph.html#forcedBoundsCenter	Center of the bounding box. \n\nScanning will only be done inside the bounding box
Pathfinding.RecastGraph.hasExtendedInX	recastgraph.html#hasExtendedInX	
Pathfinding.RecastGraph.hasExtendedInZ	recastgraph.html#hasExtendedInZ	
Pathfinding.RecastGraph.mask	recastgraph.html#mask	Layer mask which filters which objects to include. \n\n[more in online documentation]
Pathfinding.RecastGraph.maxEdgeLength	recastgraph.html#maxEdgeLength	Longer edges will be subdivided. \n\nReducing this value can sometimes improve path quality since similarly sized triangles yield better paths than really large and really triangles small next to each other. However it will also add a lot more nodes which will make pathfinding slower. For more information about this take a look at Notes about navmesh graphs.\n\n <b>[image in online documentation]</b>
Pathfinding.RecastGraph.maxSlope	recastgraph.html#maxSlope	Max slope in degrees the character can traverse. \n\n <b>[image in online documentation]</b>
Pathfinding.RecastGraph.meshesUnreadableAtRuntime	recastgraph.html#meshesUnreadableAtRuntime	Internal field used to warn users when the mesh includes meshes that are not readable at runtime.
Pathfinding.RecastGraph.minRegionSize	recastgraph.html#minRegionSize	Minumum region size. \n\nSmall regions will be removed from the navmesh. Measured in voxels.\n\n <b>[image in online documentation]</b>\n\nIf a region is adjacent to a tile border, it will not be removed even though it is small since the adjacent tile might join it to form a larger region.\n\n <b>[image in online documentation]</b><b>[image in online documentation]</b>
Pathfinding.RecastGraph.pendingGraphUpdateArena	recastgraph.html#pendingGraphUpdateArena	
Pathfinding.RecastGraph.perLayerModifications	recastgraph.html#perLayerModifications	List of rules that modify the graph based on the layer of the rasterized object. \n\n <b>[image in online documentation]</b>\n\nBy default, all layers are treated as walkable surfaces. But by adding rules to this list, one can for example make all surfaces with a specific layer get a specific pathfinding tag.\n\nEach layer should be modified at most once in this list.\n\nIf an object has a RecastNavmeshModifier component attached, the settings on that component will override the settings in this list.\n\n[more in online documentation]
Pathfinding.RecastGraph.rasterizeColliders	recastgraph.html#rasterizeColliders	Use colliders to calculate the navmesh. \n\nDepending on the dimensionMode, either 3D or 2D colliders will be rasterized.\n\nSphere/Capsule/Circle colliders will be approximated using polygons, with the precision specified in colliderRasterizeDetail. \n\n[more in online documentation]
Pathfinding.RecastGraph.rasterizeMeshes	recastgraph.html#rasterizeMeshes	Use scene meshes to calculate the navmesh. \n\nThis can get you higher precision than colliders, since colliders are typically very simplified versions of the mesh. However, it is often slower to scan, and graph updates can be particularly slow.\n\nThe reason that graph updates are slower is that there's no efficient way to find all meshes that intersect a given tile, so the graph has to iterate over all meshes in the scene just to find the ones relevant for the tiles that you want to update. Colliders, on the other hand, can be efficiently queried using the physics system.\n\nYou can disable this and attach a RecastNavmeshModifier component (with dynamic=false) to all meshes that you want to be included in the navmesh instead. That way they will be able to be efficiently queried for, without having to iterate through all meshes in the scene.\n\nIn 2D mode, this setting has no effect. \n\n[more in online documentation]
Pathfinding.RecastGraph.rasterizeTerrain	recastgraph.html#rasterizeTerrain	Use terrains to calculate the navmesh. \n\nIn 2D mode, this setting has no effect. \n\n[more in online documentation]
Pathfinding.RecastGraph.rasterizeTrees	recastgraph.html#rasterizeTrees	Rasterize tree colliders on terrains. \n\nIf the tree prefab has a collider, that collider will be rasterized. Otherwise a simple box collider will be used and the script will try to adjust it to the tree's scale, it might not do a very good job though so an attached collider is preferable.\n\n[more in online documentation]\nIn 2D mode, this setting has no effect.\n\n[more in online documentation]
Pathfinding.RecastGraph.relevantGraphSurfaceMode	recastgraph.html#relevantGraphSurfaceMode	Require every region to have a RelevantGraphSurface component inside it. \n\nA RelevantGraphSurface component placed in the scene specifies that the navmesh region it is inside should be included in the navmesh.\n\nIf this is set to OnlyForCompletelyInsideTile a navmesh region is included in the navmesh if it has a RelevantGraphSurface inside it, or if it is adjacent to a tile border. This can leave some small regions which you didn't want to have included because they are adjacent to tile borders, but it removes the need to place a component in every single tile, which can be tedious (see below).\n\nIf this is set to RequireForAll a navmesh region is included only if it has a RelevantGraphSurface inside it. Note that even though the navmesh looks continous between tiles, the tiles are computed individually and therefore you need a RelevantGraphSurface component for each region and for each tile.\n\n <b>[image in online documentation]</b>\n\n <b>[image in online documentation]</b>\n\n <b>[image in online documentation]</b>\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RecastGraph.rotation	recastgraph.html#rotation	Rotation of the graph in degrees.
Pathfinding.RecastGraph.scanEmptyGraph	recastgraph.html#scanEmptyGraph	If true, scanning the graph will yield a completely empty graph. \n\nUseful if you want to replace the graph with a custom navmesh for example\n\n[more in online documentation]
Pathfinding.RecastGraph.tagMask	recastgraph.html#tagMask	Objects tagged with any of these tags will be rasterized. \n\nNote that this extends the layer mask, so if you only want to use tags, set mask to 'Nothing'.\n\n[more in online documentation]
Pathfinding.RecastGraph.terrainSampleSize	recastgraph.html#terrainSampleSize	Controls how large the sample size for the terrain is. \n\nA higher value is faster to scan but less accurate.\n\nThe heightmap resolution is effectively divided by this value, before the terrain is rasterized.\n\n[more in online documentation]
Pathfinding.RecastGraph.tileSizeX	recastgraph.html#tileSizeX	Size of a tile along the X axis in voxels. \n\nThis is the width of the tile.\n\n <b>[image in online documentation]</b>\n\nA large tile size can be faster to initially scan (but beware of out of memory issues if you try with a too large tile size in a large world) smaller tile sizes are (much) faster to update.\n\nDifferent tile sizes can affect the quality of paths. It is often good to split up huge open areas into several tiles for better quality paths, but too small tiles can also lead to effects looking like invisible obstacles. For more information about this take a look at Notes about navmesh graphs. Usually it is best to experiment and see what works best for your game.\n\nWhen scanning a recast graphs individual tiles can be calculated in parallel which can make it much faster to scan large worlds. When you want to recalculate a part of a recast graph, this can only be done on a tile-by-tile basis which means that if you often try to update a region of the recast graph much smaller than the tile size, then you will be doing a lot of unnecessary calculations. However if you on the other hand update regions of the recast graph that are much larger than the tile size then it may be slower than necessary as there is some overhead in having lots of tiles instead of a few larger ones (not that much though).\n\nRecommended values are between 64 and 256, but these are very soft limits. It is possible to use both larger and smaller values.\n\n[more in online documentation]
Pathfinding.RecastGraph.tileSizeZ	recastgraph.html#tileSizeZ	Size of a tile along the Z axis in voxels. \n\nThis is the width of the tile.\n\n <b>[image in online documentation]</b>\n\nA large tile size can be faster to initially scan (but beware of out of memory issues if you try with a too large tile size in a large world) smaller tile sizes are (much) faster to update.\n\nDifferent tile sizes can affect the quality of paths. It is often good to split up huge open areas into several tiles for better quality paths, but too small tiles can also lead to effects looking like invisible obstacles. For more information about this take a look at Notes about navmesh graphs. Usually it is best to experiment and see what works best for your game.\n\nWhen scanning a recast graphs individual tiles can be calculated in parallel which can make it much faster to scan large worlds. When you want to recalculate a part of a recast graph, this can only be done on a tile-by-tile basis which means that if you often try to update a region of the recast graph much smaller than the tile size, then you will be doing a lot of unnecessary calculations. However if you on the other hand update regions of the recast graph that are much larger than the tile size then it may be slower than necessary as there is some overhead in having lots of tiles instead of a few larger ones (not that much though).\n\nRecommended values are between 64 and 256, but these are very soft limits. It is possible to use both larger and smaller values.\n\n[more in online documentation]
Pathfinding.RecastGraph.useTiles	recastgraph.html#useTiles	If true, divide the graph into tiles, otherwise use a single tile covering the whole graph. \n\nUsing tiles is useful for a number of things. But it also has some drawbacks.\n- Using tiles allows you to update only a part of the graph at a time. When doing graph updates on a recast graph, it will always recalculate whole tiles (or the whole graph if there are no tiles).  NavmeshCut components also work on a tile-by-tile basis.\n\n- Using tiles allows you to use NavmeshPrefabs.\n\n- Using tiles can break up very large triangles, which can improve path quality in some cases, and make the navmesh more closely follow the y-coordinates of the ground.\n\n- Using tiles can make it much faster to generate the navmesh, because each tile can be calculated in parallel. But if the tiles are made too small, then the overhead of having many tiles can make it slower than having fewer tiles.\n\n- Using small tiles can make the path quality worse in some cases, but setting the  FunnelModifiers quality setting to high (or using  RichAI.funnelSimplification) will mostly mitigate this.\n\n\n\n[more in online documentation]
Pathfinding.RecastGraph.walkableClimb	recastgraph.html#walkableClimb	Height the character can climb. \n\n <b>[image in online documentation]</b>
Pathfinding.RecastGraph.walkableHeight	recastgraph.html#walkableHeight	Character height. \n\n <b>[image in online documentation]</b>
Pathfinding.RecastGraphEditor.DimensionModeLabels	recastgrapheditor.html#DimensionModeLabels	
Pathfinding.RecastGraphEditor.UseTiles	recastgrapheditor.html#UseTiles	
Pathfinding.RecastGraphEditor.handlePoints	recastgrapheditor.html#handlePoints	
Pathfinding.RecastGraphEditor.meshesUnreadableAtRuntimeFoldout	recastgrapheditor.html#meshesUnreadableAtRuntimeFoldout	
Pathfinding.RecastGraphEditor.perLayerModificationsList	recastgrapheditor.html#perLayerModificationsList	
Pathfinding.RecastGraphEditor.tagMaskFoldout	recastgrapheditor.html#tagMaskFoldout	
Pathfinding.RecastGraphEditor.tagMaskList	recastgrapheditor.html#tagMaskList	
Pathfinding.RecastMeshObj.dynamic	recastmeshobj.html#dynamic	
Pathfinding.RecastMeshObj.enabled	recastmeshobj.html#enabled	
Pathfinding.RecastMeshObj.geometrySource	recastmeshobj.html#geometrySource	
Pathfinding.RecastMeshObj.includeInScan	recastmeshobj.html#includeInScan	
Pathfinding.RecastMeshObj.mode	recastmeshobj.html#mode	
Pathfinding.RecastMeshObj.solid	recastmeshobj.html#solid	
Pathfinding.RecastMeshObj.surfaceID	recastmeshobj.html#surfaceID	
Pathfinding.RecastNavmeshModifier.GeometrySource	recastnavmeshmodifier.html#GeometrySource	Source of geometry when voxelizing this object.
Pathfinding.RecastNavmeshModifier.Mode	recastnavmeshmodifier.html#Mode	
Pathfinding.RecastNavmeshModifier.ScanInclusion	recastnavmeshmodifier.html#ScanInclusion	
Pathfinding.RecastNavmeshModifier.area	recastnavmeshmodifier.html#area	Voxel area for mesh. \n\nThis area (not to be confused with pathfinding areas, this is only used when rasterizing meshes for the recast graph) field can be used to explicitly insert edges in the navmesh geometry or to make some parts of the mesh unwalkable.\n\nWhen rasterizing the world and two objects with different surface id values are adjacent to each other, a split in the navmesh geometry will be added between them, characters will still be able to walk between them, but this can be useful when working with navmesh updates.\n\nNavmesh updates which recalculate a whole tile (updatePhysics=True) are very slow So if there are special places which you know are going to be updated quite often, for example at a door opening (opened/closed door) you can use surface IDs to create splits on the navmesh for easier updating using normal graph updates (updatePhysics=False). See the below video for more information.\n\n  <b>[video in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RecastNavmeshModifier.dynamic	recastnavmeshmodifier.html#dynamic	Enable if the object will move during runtime. \n\nIf disabled, the object will be assumed to stay in the same position, and keep the same size, until the component is disabled or destroyed.\n\nDisabling this will provide a small performance boost when doing graph updates, as the graph no longer has to check if this RecastNavmeshModifier might have moved.\n\nEven you set dynamic=false, you can disable the component, move the object, and enable it at the new position.
Pathfinding.RecastNavmeshModifier.geometrySource	recastnavmeshmodifier.html#geometrySource	Source of geometry when voxelizing this object.
Pathfinding.RecastNavmeshModifier.includeInScan	recastnavmeshmodifier.html#includeInScan	Determines if the object should be included in scans or not. \n\n[more in online documentation]
Pathfinding.RecastNavmeshModifier.mode	recastnavmeshmodifier.html#mode	Surface rasterization mode. \n\n[more in online documentation]
Pathfinding.RecastNavmeshModifier.solid	recastnavmeshmodifier.html#solid	If true then the mesh will be treated as solid and its interior will be unwalkable. \n\nThe unwalkable region will be the minimum to maximum y coordinate in each cell.\n\nIf you enable this on a mesh that is actually hollow then the hollow region will also be treated as unwalkable.
Pathfinding.RecastNavmeshModifier.surfaceID	recastnavmeshmodifier.html#surfaceID	Voxel area for mesh. \n\nThis area (not to be confused with pathfinding areas, this is only used when rasterizing meshes for the recast graph) field can be used to explicitly insert edges in the navmesh geometry or to make some parts of the mesh unwalkable.\n\nWhen rasterizing the world and two objects with different surface id values are adjacent to each other, a split in the navmesh geometry will be added between them, characters will still be able to walk between them, but this can be useful when working with navmesh updates.\n\nNavmesh updates which recalculate a whole tile (updatePhysics=True) are very slow So if there are special places which you know are going to be updated quite often, for example at a door opening (opened/closed door) you can use surface IDs to create splits on the navmesh for easier updating using normal graph updates (updatePhysics=False). See the below video for more information.\n\n  <b>[video in online documentation]</b>\n\nWhen mode is set to Mode.WalkableSurfaceWithTag then this value will be interpreted as a pathfinding tag. See Working with tags.\n\n[more in online documentation]
Pathfinding.RecastNavmeshModifier.tree	recastnavmeshmodifier.html#tree	Components are stored in a tree for fast lookups.
Pathfinding.RecastNavmeshModifier.treeKey	recastnavmeshmodifier.html#treeKey	
Pathfinding.RecastTileUpdate.OnNeedUpdates	recasttileupdate.html#OnNeedUpdates	
Pathfinding.RecastTileUpdateHandler.anyDirtyTiles	recasttileupdatehandler.html#anyDirtyTiles	True if any elements in dirtyTiles are true.
Pathfinding.RecastTileUpdateHandler.dirtyTiles	recasttileupdatehandler.html#dirtyTiles	True for a tile if it needs updating.
Pathfinding.RecastTileUpdateHandler.earliestDirty	recasttileupdatehandler.html#earliestDirty	Earliest update request we are handling right now.
Pathfinding.RecastTileUpdateHandler.graph	recasttileupdatehandler.html#graph	Graph that handles the updates.
Pathfinding.RecastTileUpdateHandler.maxThrottlingDelay	recasttileupdatehandler.html#maxThrottlingDelay	All tile updates will be performed within (roughly) this number of seconds.
Pathfinding.RichAI.GizmoColorPath	richai.html#GizmoColorPath	
Pathfinding.RichAI.acceleration	richai.html#acceleration	Max acceleration of the agent. \n\nIn world units per second per second.
Pathfinding.RichAI.approachingPartEndpoint	richai.html#approachingPartEndpoint	True if approaching the last waypoint in the current part of the path. \n\nPath parts are separated by off-mesh links.\n\n[more in online documentation]
Pathfinding.RichAI.approachingPathEndpoint	richai.html#approachingPathEndpoint	True if approaching the last waypoint of all parts in the current path. \n\nPath parts are separated by off-mesh links.\n\n[more in online documentation]
Pathfinding.RichAI.canMove	richai.html#canMove	Enables or disables movement completely. \n\nIf you want the agent to stand still, but still react to local avoidance and use gravity: use isStopped instead.\n\nThis is also useful if you want to have full control over when the movement calculations run. Take a look at MovementUpdate\n\n[more in online documentation]
Pathfinding.RichAI.canSearch	richai.html#canSearch	Enables or disables recalculating the path at regular intervals. \n\nSetting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.\n\nNote that this only disables automatic path recalculations. If you call the SearchPath() method a path will still be calculated.\n\n[more in online documentation]
Pathfinding.RichAI.delayUpdatePath	richai.html#delayUpdatePath	
Pathfinding.RichAI.distanceToSteeringTarget	richai.html#distanceToSteeringTarget	Distance to steeringTarget in the movement plane.
Pathfinding.RichAI.endOfPath	richai.html#endOfPath	End point of path the agent is currently following. \n\nIf the agent has no path (or it might not be calculated yet), this will return the destination instead. If the agent has no destination it will return the agent's current position.\n\nThe end of the path is usually identical or very close to the destination, but it may differ if the path for example was blocked by a wall so that the agent couldn't get any closer.\n\nThis is only updated when the path is recalculated.
Pathfinding.RichAI.funnelSimplification	richai.html#funnelSimplification	Use funnel simplification. \n\nOn tiled navmesh maps, but sometimes on normal ones as well, it can be good to simplify the funnel as a post-processing step to make the paths straighter.\n\nThis has a moderate performance impact during frames when a path calculation is completed.\n\nThe RichAI script uses its own internal funnel algorithm, so you never need to attach the FunnelModifier component.\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RichAI.hasPath	richai.html#hasPath	True if this agent currently has a path that it follows.
Pathfinding.RichAI.height	richai.html#height	Height of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nThis value is currently only used if an RVOController is attached to the same GameObject, otherwise it is only used for drawing nice gizmos in the scene view. However since the height value is used for some things, the radius field is always visible for consistency and easier visualization of the character. That said, it may be used for something in a future release.\n\n[more in online documentation]
Pathfinding.RichAI.lastCorner	richai.html#lastCorner	
Pathfinding.RichAI.maxSpeed	richai.html#maxSpeed	Max speed in world units per second.
Pathfinding.RichAI.movementPlane	richai.html#movementPlane	The plane the agent is moving in. \n\nThis is typically the ground plane, which will be the XZ plane in a 3D game, and the XY plane in a 2D game. Ultimately it depends on the graph orientation.\n\nIf you are doing pathfinding on a spherical world (see Spherical Worlds), the the movement plane will be the tangent plane of the sphere at the agent's position.
Pathfinding.RichAI.nextCorners	richai.html#nextCorners	
Pathfinding.RichAI.onTraverseOffMeshLink	richai.html#onTraverseOffMeshLink	Called when the agent starts to traverse an off-mesh link. \n\nRegister to this callback to handle off-mesh links in a custom way.\n\nIf this event is set to null then the agent will fall back to traversing off-mesh links using a very simple linear interpolation.\n\n<b>[code in online documentation]</b>
Pathfinding.RichAI.pathPending	richai.html#pathPending	True if a path is currently being calculated.
Pathfinding.RichAI.preventMovingBackwards	richai.html#preventMovingBackwards	Prevent the velocity from being too far away from the forward direction of the character. \n\nIf the character is ordered to move in the opposite direction from where it is facing then enabling this will cause it to make a small loop instead of turning on the spot.\n\nThis setting only has an effect if slowWhenNotFacingTarget is enabled.
Pathfinding.RichAI.radius	richai.html#radius	Radius of the agent in world units. \n\nThis is visualized in the scene view as a yellow cylinder around the character.\n\nNote that this does not affect pathfinding in any way. The graph used completely determines where the agent can move.\n\n[more in online documentation]
Pathfinding.RichAI.reachedDestination	richai.html#reachedDestination	True if the ai has reached the destination. \n\nThis is a best effort calculation to see if the destination has been reached. For the AIPath/RichAI scripts, this is when the character is within AIPath.endReachedDistance world units from the destination. For the AILerp script it is when the character is at the destination (±a very small margin).\n\nThis value will be updated immediately when the destination is changed (in contrast to reachedEndOfPath), however since path requests are asynchronous it will use an approximation until it sees the real path result. What this property does is to check the distance to the end of the current path, and add to that the distance from the end of the path to the destination (i.e. is assumes it is possible to move in a straight line between the end of the current path to the destination) and then checks if that total distance is less than AIPath.endReachedDistance. This property is therefore only a best effort, but it will work well for almost all use cases.\n\nFurthermore it will not report that the destination is reached if the destination is above the head of the character or more than half the height of the character below its feet (so if you have a multilevel building, it is important that you configure the height of the character correctly).\n\nThe cases which could be problematic are if an agent is standing next to a very thin wall and the destination suddenly changes to the other side of that thin wall. During the time that it takes for the path to be calculated the agent may see itself as alredy having reached the destination because the destination only moved a very small distance (the wall was thin), even though it may actually be quite a long way around the wall to the other side.\n\nIn contrast to reachedEndOfPath, this property is immediately updated when the destination is changed.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.RichAI.reachedEndOfPath	richai.html#reachedEndOfPath	True if the agent has reached the end of the current path. \n\nNote that setting the destination does not immediately update the path, nor is there any guarantee that the AI will actually be able to reach the destination that you set. The AI will try to get as close as possible. Often you want to use reachedDestination instead which is easier to work with.\n\nIt is very hard to provide a method for detecting if the AI has reached the destination that works across all different games because the destination may not even lie on the navmesh and how that is handled differs from game to game (see also the code snippet in the docs for destination).\n\n[more in online documentation]
Pathfinding.RichAI.remainingDistance	richai.html#remainingDistance	Approximate remaining distance along the current path to the end of the path. \n\nThe RichAI movement script approximates this distance since it is quite expensive to calculate the real distance. However it will be accurate when the agent is within 1 corner of the destination. You can use GetRemainingPath to calculate the actual remaining path more precisely.\n\nThe AIPath and AILerp scripts use a more accurate distance calculation at all times.\n\nIf the agent does not currently have a path, then positive infinity will be returned.\n\n[more in online documentation]\n\n\n\n[more in online documentation]
Pathfinding.RichAI.richPath	richai.html#richPath	Holds the current path that this agent is following.
Pathfinding.RichAI.rotation	richai.html#rotation	Rotation of the agent. \n\nIf updateRotation is true then this value is identical to transform.rotation.
Pathfinding.RichAI.rotationFilterState	richai.html#rotationFilterState	Internal state used for filtering out noise in the agent's rotation.
Pathfinding.RichAI.rotationFilterState2	richai.html#rotationFilterState2	
Pathfinding.RichAI.rotationSpeed	richai.html#rotationSpeed	Max rotation speed of the agent. \n\nIn degrees per second.
Pathfinding.RichAI.shouldRecalculatePath	richai.html#shouldRecalculatePath	True if the path should be automatically recalculated as soon as possible.
Pathfinding.RichAI.slowWhenNotFacingTarget	richai.html#slowWhenNotFacingTarget	Slow down when not facing the target direction. \n\nIncurs at a small performance overhead.\n\nThis setting only has an effect if enableRotation is enabled.
Pathfinding.RichAI.slowdownTime	richai.html#slowdownTime	How long before reaching the end of the path to start to slow down. \n\nA lower value will make the agent stop more abruptly.\n\n[more in online documentation]\nIf set to zero the agent will not even attempt to slow down. This can be useful if the target point is not a point you want the agent to stop at but it might for example be the player and you want the AI to slam into the player.\n\n[more in online documentation]\n <b>[video in online documentation]</b>
Pathfinding.RichAI.steeringTarget	richai.html#steeringTarget	Point on the path which the agent is currently moving towards. \n\nThis is usually a point a small distance ahead of the agent or the end of the path.\n\nIf the agent does not have a path at the moment, then the agent's current position will be returned.
Pathfinding.RichAI.traversingOffMeshLink	richai.html#traversingOffMeshLink	
Pathfinding.RichAI.wallBuffer	richai.html#wallBuffer	
Pathfinding.RichAI.wallDist	richai.html#wallDist	Walls within this range will be used for avoidance. \n\nSetting this to zero disables wall avoidance and may improve performance slightly\n\n[more in online documentation]
Pathfinding.RichAI.wallForce	richai.html#wallForce	Force to avoid walls with. \n\nThe agent will try to steer away from walls slightly.\n\n[more in online documentation]
Pathfinding.RichFunnel.CurrentNode	richfunnel.html#CurrentNode	
Pathfinding.RichFunnel.DistanceToEndOfPath	richfunnel.html#DistanceToEndOfPath	Approximate distance (as the crow flies) to the endpoint of this path part. \n\n[more in online documentation]
Pathfinding.RichFunnel.checkForDestroyedNodesCounter	richfunnel.html#checkForDestroyedNodesCounter	
Pathfinding.RichFunnel.currentNode	richfunnel.html#currentNode	
Pathfinding.RichFunnel.currentPosition	richfunnel.html#currentPosition	
Pathfinding.RichFunnel.exactEnd	richfunnel.html#exactEnd	
Pathfinding.RichFunnel.exactStart	richfunnel.html#exactStart	
Pathfinding.RichFunnel.funnelSimplification	richfunnel.html#funnelSimplification	Post process the funnel corridor or not.
Pathfinding.RichFunnel.graph	richfunnel.html#graph	
Pathfinding.RichFunnel.left	richfunnel.html#left	
Pathfinding.RichFunnel.navmeshClampDict	richfunnel.html#navmeshClampDict	Cached object to avoid unnecessary allocations.
Pathfinding.RichFunnel.navmeshClampList	richfunnel.html#navmeshClampList	Cached object to avoid unnecessary allocations.
Pathfinding.RichFunnel.navmeshClampQueue	richfunnel.html#navmeshClampQueue	Cached object to avoid unnecessary allocations.
Pathfinding.RichFunnel.nodes	richfunnel.html#nodes	
Pathfinding.RichFunnel.path	richfunnel.html#path	
Pathfinding.RichFunnel.right	richfunnel.html#right	
Pathfinding.RichFunnel.triBuffer	richfunnel.html#triBuffer	
Pathfinding.RichPath.CompletedAllParts	richpath.html#CompletedAllParts	True if we have completed (called NextPart for) the last part in the path.
Pathfinding.RichPath.Endpoint	richpath.html#Endpoint	
Pathfinding.RichPath.IsLastPart	richpath.html#IsLastPart	True if we are traversing the last part of the path.
Pathfinding.RichPath.currentPart	richpath.html#currentPart	
Pathfinding.RichPath.parts	richpath.html#parts	
Pathfinding.RichPath.seeker	richpath.html#seeker	
Pathfinding.RichPath.transform	richpath.html#transform	Transforms points from path space to world space. \n\nIf null the identity transform will be used.\n\nThis is used when the world position of the agent does not match the corresponding position on the graph. This is the case in the example scene called 'Moving'.\n\n[more in online documentation]
Pathfinding.RichSpecial.first	richspecial.html#first	
Pathfinding.RichSpecial.nodeLink	richspecial.html#nodeLink	
Pathfinding.RichSpecial.reverse	richspecial.html#reverse	
Pathfinding.RichSpecial.second	richspecial.html#second	
Pathfinding.RuleElevationPenaltyEditor.GizmoColorMax	ruleelevationpenaltyeditor.html#GizmoColorMax	
Pathfinding.RuleElevationPenaltyEditor.GizmoColorMin	ruleelevationpenaltyeditor.html#GizmoColorMin	
Pathfinding.RuleElevationPenaltyEditor.lastChangedTime	ruleelevationpenaltyeditor.html#lastChangedTime	
Pathfinding.RuleTextureEditor.ChannelUseNames	ruletextureeditor.html#ChannelUseNames	
Pathfinding.ScanningStage	pathfinding.html#ScanningStage	Info about where in the scanning process a graph is.
Pathfinding.Seeker.ModifierPass	seeker.html#ModifierPass	
Pathfinding.Seeker.detailedGizmos	seeker.html#detailedGizmos	Enables drawing of the non-postprocessed path using Gizmos. \n\nThe path will show up in orange.\n\nRequires that drawGizmos is true.\n\nThis will show the path before any post processing such as smoothing is applied.\n\n[more in online documentation]
Pathfinding.Seeker.drawGizmos	seeker.html#drawGizmos	Enables drawing of the last calculated path using Gizmos. \n\nThe path will show up in green.\n\n[more in online documentation]
Pathfinding.Seeker.graphMask	seeker.html#graphMask	Graphs that this Seeker can use. \n\nThis field determines which graphs will be considered when searching for the start and end nodes of a path. It is useful in numerous situations, for example if you want to make one graph for small units and one graph for large units.\n\nThis is a bitmask so if you for example want to make the agent only use graph index 3 then you can set this to: <b>[code in online documentation]</b>\n\n[more in online documentation]\nNote that this field only stores which graph indices that are allowed. This means that if the graphs change their ordering then this mask may no longer be correct.\n\nIf you know the name of the graph you can use the Pathfinding.GraphMask.FromGraphName method: <b>[code in online documentation]</b>\n\n <b>[image in online documentation]</b>\n\n[more in online documentation]
Pathfinding.Seeker.graphMaskCompatibility	seeker.html#graphMaskCompatibility	Used for serialization backwards compatibility.
Pathfinding.Seeker.lastCompletedNodePath	seeker.html#lastCompletedNodePath	Used for drawing gizmos.
Pathfinding.Seeker.lastCompletedVectorPath	seeker.html#lastCompletedVectorPath	Used for drawing gizmos.
Pathfinding.Seeker.lastPathID	seeker.html#lastPathID	The path ID of the last path queried.
Pathfinding.Seeker.modifiers	seeker.html#modifiers	Internal list of all modifiers.
Pathfinding.Seeker.onPartialPathDelegate	seeker.html#onPartialPathDelegate	Cached delegate to avoid allocating one every time a path is started.
Pathfinding.Seeker.onPathDelegate	seeker.html#onPathDelegate	Cached delegate to avoid allocating one every time a path is started.
Pathfinding.Seeker.path	seeker.html#path	The current path.
Pathfinding.Seeker.pathCallback	seeker.html#pathCallback	Callback for when a path is completed. \n\nMovement scripts should register to this delegate.\n\nA temporary callback can also be set when calling StartPath, but that delegate will only be called for that path\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.Seeker.postProcessPath	seeker.html#postProcessPath	Called after a path has been calculated, right before modifiers are executed.
Pathfinding.Seeker.preProcessPath	seeker.html#preProcessPath	Called before pathfinding is started.
Pathfinding.Seeker.prevPath	seeker.html#prevPath	Previous path. \n\nUsed to draw gizmos
Pathfinding.Seeker.startEndModifier	seeker.html#startEndModifier	Path modifier which tweaks the start and end points of a path.
Pathfinding.Seeker.tagPenalties	seeker.html#tagPenalties	Penalties for each tag. \n\nTag 0 which is the default tag, will have added a penalty of tagPenalties[0]. These should only be positive values since the A* algorithm cannot handle negative penalties.\n\nThe length of this array should be exactly 32, one for each tag.\n\n[more in online documentation]
Pathfinding.Seeker.tmpPathCallback	seeker.html#tmpPathCallback	Temporary callback only called for the current path. \n\nThis value is set by the StartPath functions
Pathfinding.Seeker.traversableTags	seeker.html#traversableTags	The tags which the Seeker can traverse. \n\n[more in online documentation]
Pathfinding.Seeker.traversalProvider	seeker.html#traversalProvider	Custom traversal provider to calculate which nodes are traversable and their penalties. \n\nThis can be used to override the built-in pathfinding logic.\n\n<b>[code in online documentation]</b>\n\n[more in online documentation]
Pathfinding.SeekerEditor.exactnessLabels	seekereditor.html#exactnessLabels	
Pathfinding.SeekerEditor.scripts	seekereditor.html#scripts	
Pathfinding.SeekerEditor.tagPenaltiesOpen	seekereditor.html#tagPenaltiesOpen	
Pathfinding.Serialization.AstarSerializer.V3_8_3	astarserializer.html#V3_8_3	Cached version object for 3.8.3.
Pathfinding.Serialization.AstarSerializer.V3_9_0	astarserializer.html#V3_9_0	Cached version object for 3.9.0.
Pathfinding.Serialization.AstarSerializer.V4_1_0	astarserializer.html#V4_1_0	Cached version object for 4.1.0.
Pathfinding.Serialization.AstarSerializer.V4_3_12	astarserializer.html#V4_3_12	Cached version object for 4.3.12.
Pathfinding.Serialization.AstarSerializer.V4_3_2	astarserializer.html#V4_3_2	Cached version object for 4.3.2.
Pathfinding.Serialization.AstarSerializer.V4_3_37	astarserializer.html#V4_3_37	Cached version object for 4.3.37.
Pathfinding.Serialization.AstarSerializer.V4_3_6	astarserializer.html#V4_3_6	Cached version object for 4.3.6.
Pathfinding.Serialization.AstarSerializer.V4_3_68	astarserializer.html#V4_3_68	Cached version object for 4.3.68.
Pathfinding.Serialization.AstarSerializer.V4_3_74	astarserializer.html#V4_3_74	Cached version object for 4.3.74.
Pathfinding.Serialization.AstarSerializer.V4_3_80	astarserializer.html#V4_3_80	Cached version object for 4.3.80.
Pathfinding.Serialization.AstarSerializer.V4_3_83	astarserializer.html#V4_3_83	Cached version object for 4.3.83.
Pathfinding.Serialization.AstarSerializer.V4_3_85	astarserializer.html#V4_3_85	Cached version object for 4.3.85.
Pathfinding.Serialization.AstarSerializer.V4_3_87	astarserializer.html#V4_3_87	Cached version object for 4.3.87.
Pathfinding.Serialization.AstarSerializer.V5_1_0	astarserializer.html#V5_1_0	Cached version object for 5.1.0.
Pathfinding.Serialization.AstarSerializer.V5_2_0	astarserializer.html#V5_2_0	Cached version object for 5.2.0.
Pathfinding.Serialization.AstarSerializer._stringBuilder	astarserializer.html#_stringBuilder	Cached StringBuilder to avoid excessive allocations.
Pathfinding.Serialization.AstarSerializer.binaryExt	astarserializer.html#binaryExt	Extension to use for binary files.
Pathfinding.Serialization.AstarSerializer.checksum	astarserializer.html#checksum	Checksum for the serialized data. \n\nUsed to provide a quick equality check in editor code
Pathfinding.Serialization.AstarSerializer.contextRoot	astarserializer.html#contextRoot	Root GameObject used for deserialization. \n\nThis should be the GameObject which holds the AstarPath component. Important when deserializing when the component is on a prefab.
Pathfinding.Serialization.AstarSerializer.data	astarserializer.html#data	
Pathfinding.Serialization.AstarSerializer.encoding	astarserializer.html#encoding	
Pathfinding.Serialization.AstarSerializer.graphIndexInZip	astarserializer.html#graphIndexInZip	Index used for the graph in the file. \n\nIf some graphs were null in the file then graphIndexInZip[graphs[i]] may not equal i. Used for deserialization.
Pathfinding.Serialization.AstarSerializer.graphs	astarserializer.html#graphs	Graphs that are being serialized or deserialized.
Pathfinding.Serialization.AstarSerializer.jsonExt	astarserializer.html#jsonExt	Extension to use for json files.
Pathfinding.Serialization.AstarSerializer.meta	astarserializer.html#meta	Graph metadata.
Pathfinding.Serialization.AstarSerializer.persistentGraphs	astarserializer.html#persistentGraphs	
Pathfinding.Serialization.AstarSerializer.settings	astarserializer.html#settings	Settings for serialization.
Pathfinding.Serialization.AstarSerializer.zip	astarserializer.html#zip	Zip which the data is loaded from.
Pathfinding.Serialization.AstarSerializer.zipStream	astarserializer.html#zipStream	Memory stream with the zip data.
Pathfinding.Serialization.GraphMeta.graphs	graphmeta.html#graphs	Number of graphs serialized.
Pathfinding.Serialization.GraphMeta.guids	graphmeta.html#guids	Guids for all graphs.
Pathfinding.Serialization.GraphMeta.typeNames	graphmeta.html#typeNames	Type names for all graphs.
Pathfinding.Serialization.GraphMeta.version	graphmeta.html#version	Project version it was saved with.
Pathfinding.Serialization.GraphSerializationContext.graphIndex	graphserializationcontext.html#graphIndex	Index of the graph which is currently being processed. \n\n[more in online documentation]
Pathfinding.Serialization.GraphSerializationContext.id2NodeMapping	graphserializationcontext.html#id2NodeMapping	
Pathfinding.Serialization.GraphSerializationContext.meta	graphserializationcontext.html#meta	Metadata about graphs being deserialized.
Pathfinding.Serialization.GraphSerializationContext.persistentGraphs	graphserializationcontext.html#persistentGraphs	
Pathfinding.Serialization.GraphSerializationContext.reader	graphserializationcontext.html#reader	Deserialization stream. \n\nWill only be set when deserializing
Pathfinding.Serialization.GraphSerializationContext.writer	graphserializationcontext.html#writer	Serialization stream. \n\nWill only be set when serializing
Pathfinding.Serialization.JsonDynamicTypeAliasAttribute.alias	jsondynamictypealiasattribute.html#alias	
Pathfinding.Serialization.JsonDynamicTypeAliasAttribute.type	jsondynamictypealiasattribute.html#type	
Pathfinding.Serialization.Migrations.IsLegacyFormat	migrations.html#IsLegacyFormat	
Pathfinding.Serialization.Migrations.LegacyVersion	migrations.html#LegacyVersion	
Pathfinding.Serialization.Migrations.MIGRATE_TO_BITFIELD	migrations.html#MIGRATE_TO_BITFIELD	A special migration flag which is used to mark that the version has been migrated to the bitfield format, from the legacy linear version format.
Pathfinding.Serialization.Migrations.allMigrations	migrations.html#allMigrations	Bitfield of all migrations that the component supports. \n\nA newly created component will be initialized with this value.
Pathfinding.Serialization.Migrations.finishedMigrations	migrations.html#finishedMigrations	Bitfield of all migrations that have been run.
Pathfinding.Serialization.Migrations.ignore	migrations.html#ignore	
Pathfinding.Serialization.SerializableAnimationCurve.keys	serializableanimationcurve.html#keys	
Pathfinding.Serialization.SerializableAnimationCurve.postWrapMode	serializableanimationcurve.html#postWrapMode	
Pathfinding.Serialization.SerializableAnimationCurve.preWrapMode	serializableanimationcurve.html#preWrapMode	
Pathfinding.Serialization.SerializeSettings.NodesAndSettings	serializesettings.html#NodesAndSettings	Serialization settings for serializing nodes and settings.
Pathfinding.Serialization.SerializeSettings.Settings	serializesettings.html#Settings	Serialization settings for only saving graph settings.
Pathfinding.Serialization.SerializeSettings.nodes	serializesettings.html#nodes	Enable to include node data. \n\nIf false, only settings will be saved
Pathfinding.Serialization.TinyJsonDeserializer.builder	tinyjsondeserializer.html#builder	
Pathfinding.Serialization.TinyJsonDeserializer.contextRoot	tinyjsondeserializer.html#contextRoot	
Pathfinding.Serialization.TinyJsonDeserializer.fullTextDebug	tinyjsondeserializer.html#fullTextDebug	
Pathfinding.Serialization.TinyJsonDeserializer.numberFormat	tinyjsondeserializer.html#numberFormat	
Pathfinding.Serialization.TinyJsonDeserializer.reader	tinyjsondeserializer.html#reader	
Pathfinding.Serialization.TinyJsonSerializer.invariantCulture	tinyjsonserializer.html#invariantCulture	
Pathfinding.Serialization.TinyJsonSerializer.output	tinyjsonserializer.html#output	
Pathfinding.Serialization.TinyJsonSerializer.serializers	tinyjsonserializer.html#serializers	
Pathfinding.Side	pathfinding.html#Side	Indicates the side of a line that a point lies on.
Pathfinding.SimpleSmoothModifier.Order	simplesmoothmodifier.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.SimpleSmoothModifier.SmoothType	simplesmoothmodifier.html#SmoothType	
Pathfinding.SimpleSmoothModifier.bezierTangentLength	simplesmoothmodifier.html#bezierTangentLength	Length factor of the bezier curves' tangents'.
Pathfinding.SimpleSmoothModifier.factor	simplesmoothmodifier.html#factor	Roundness factor used for CurvedNonuniform.
Pathfinding.SimpleSmoothModifier.iterations	simplesmoothmodifier.html#iterations	Number of times to apply smoothing.
Pathfinding.SimpleSmoothModifier.maxSegmentLength	simplesmoothmodifier.html#maxSegmentLength	The length of the segments in the smoothed path when using uniformLength. \n\nA high value yields rough paths and low value yields very smooth paths, but is slower
Pathfinding.SimpleSmoothModifier.offset	simplesmoothmodifier.html#offset	Offset to apply in each smoothing iteration when using Offset Simple. \n\n[more in online documentation]
Pathfinding.SimpleSmoothModifier.smoothType	simplesmoothmodifier.html#smoothType	Type of smoothing to use.
Pathfinding.SimpleSmoothModifier.strength	simplesmoothmodifier.html#strength	Determines how much smoothing to apply in each smooth iteration. \n\n0.5 usually produces the nicest looking curves.
Pathfinding.SimpleSmoothModifier.subdivisions	simplesmoothmodifier.html#subdivisions	Number of times to subdivide when not using a uniform length.
Pathfinding.SimpleSmoothModifier.uniformLength	simplesmoothmodifier.html#uniformLength	Toggle to divide all lines in equal length segments. \n\n[more in online documentation]
Pathfinding.SingleNodeBlocker.lastBlocked	singlenodeblocker.html#lastBlocked	
Pathfinding.SingleNodeBlocker.manager	singlenodeblocker.html#manager	
Pathfinding.StartEndModifier.Exactness	startendmodifier.html#Exactness	Sets where the start and end points of a path should be placed. \n\nHere is a legend showing what the different items in the above images represent. The images above show a path coming in from the top left corner and ending at a node next to an obstacle as well as 2 different possible end points of the path and how they would be modified.  <b>[image in online documentation]</b>
Pathfinding.StartEndModifier.Order	startendmodifier.html#Order	Modifiers will be executed from lower order to higher order. \n\nThis value is assumed to stay constant.
Pathfinding.StartEndModifier.addPoints	startendmodifier.html#addPoints	Add points to the path instead of replacing them. \n\nIf for example exactEndPoint is set to ClosestOnNode then the path will be modified so that the path goes first to the center of the last node in the path and then goes to the closest point on the node to the end point in the path request.\n\nIf this is false however then the relevant points in the path will simply be replaced. In the above example the path would go directly to the closest point on the node without passing through the center of the node.
Pathfinding.StartEndModifier.adjustStartPoint	startendmodifier.html#adjustStartPoint	Will be called when a path is processed. \n\nThe value which is returned will be used as the start point of the path and potentially clamped depending on the value of the exactStartPoint field. Only used for the Original, Interpolate and NodeConnection modes.
Pathfinding.StartEndModifier.connectionBuffer	startendmodifier.html#connectionBuffer	
Pathfinding.StartEndModifier.connectionBufferAddDelegate	startendmodifier.html#connectionBufferAddDelegate	
Pathfinding.StartEndModifier.exactEndPoint	startendmodifier.html#exactEndPoint	How the end point of the path will be determined. \n\n[more in online documentation]
Pathfinding.StartEndModifier.exactStartPoint	startendmodifier.html#exactStartPoint	How the start point of the path will be determined. \n\n[more in online documentation]
Pathfinding.StartEndModifier.mask	startendmodifier.html#mask	
Pathfinding.StartEndModifier.useGraphRaycasting	startendmodifier.html#useGraphRaycasting	Do a straight line check from the node's center to the point determined by the Exactness. \n\n[more in online documentation]
Pathfinding.StartEndModifier.useRaycasting	startendmodifier.html#useRaycasting	Do a straight line check from the node's center to the point determined by the Exactness. \n\nThere are very few cases where you will want to use this. It is mostly here for backwards compatibility reasons.\n\n[more in online documentation]
Pathfinding.Sync.BlockableChannel.Receiver.channel	receiver.html#channel	
Pathfinding.Sync.BlockableChannel.allReceiversBlocked	blockablechannel.html#allReceiversBlocked	True if blocking and all receivers are waiting for unblocking.
Pathfinding.Sync.BlockableChannel.blocked	blockablechannel.html#blocked	
Pathfinding.Sync.BlockableChannel.isBlocked	blockablechannel.html#isBlocked	If true, all calls to Receive will block until this property is set to false.
Pathfinding.Sync.BlockableChannel.isClosed	blockablechannel.html#isClosed	True if Close has been called.
Pathfinding.Sync.BlockableChannel.isEmpty	blockablechannel.html#isEmpty	True if the queue is empty.
Pathfinding.Sync.BlockableChannel.isStarving	blockablechannel.html#isStarving	
Pathfinding.Sync.BlockableChannel.lockObj	blockablechannel.html#lockObj	
Pathfinding.Sync.BlockableChannel.numReceivers	blockablechannel.html#numReceivers	
Pathfinding.Sync.BlockableChannel.queue	blockablechannel.html#queue	
Pathfinding.Sync.BlockableChannel.starving	blockablechannel.html#starving	
Pathfinding.Sync.BlockableChannel.waitingReceivers	blockablechannel.html#waitingReceivers	
Pathfinding.Sync.IProgress.Progress	iprogress.html#Progress	
Pathfinding.Sync.Promise.IsCompleted	promise.html#IsCompleted	
Pathfinding.Sync.Promise.Progress	promise.html#Progress	
Pathfinding.Sync.Promise.handle	promise.html#handle	
Pathfinding.Sync.Promise.result	promise.html#result	
Pathfinding.Sync.RWLock.CombinedReadLockAsync.dependency	combinedreadlockasync.html#dependency	
Pathfinding.Sync.RWLock.CombinedReadLockAsync.lock1	combinedreadlockasync.html#lock1	
Pathfinding.Sync.RWLock.CombinedReadLockAsync.lock2	combinedreadlockasync.html#lock2	
Pathfinding.Sync.RWLock.LockSync.inner	locksync.html#inner	
Pathfinding.Sync.RWLock.ReadLockAsync.dependency	readlockasync.html#dependency	
Pathfinding.Sync.RWLock.ReadLockAsync.inner	readlockasync.html#inner	
Pathfinding.Sync.RWLock.WriteLockAsync.dependency	writelockasync.html#dependency	
Pathfinding.Sync.RWLock.WriteLockAsync.inner	writelockasync.html#inner	
Pathfinding.Sync.RWLock.lastRead	rwlock.html#lastRead	
Pathfinding.Sync.RWLock.lastWrite	rwlock.html#lastWrite	
Pathfinding.Sync.SpinLock.locked	spinlock.html#locked	
Pathfinding.TargetMover.Trigger	targetmover.html#Trigger	
Pathfinding.TargetMover.cam	targetmover.html#cam	
Pathfinding.TargetMover.clickEffect	targetmover.html#clickEffect	
Pathfinding.TargetMover.formationMode	targetmover.html#formationMode	
Pathfinding.TargetMover.mask	targetmover.html#mask	Mask for the raycast placement.
Pathfinding.TargetMover.onlyOnDoubleClick	targetmover.html#onlyOnDoubleClick	Determines if the target position should be updated every frame or only on double-click.
Pathfinding.TargetMover.target	targetmover.html#target	
Pathfinding.TargetMover.trigger	targetmover.html#trigger	
Pathfinding.TargetMover.use2D	targetmover.html#use2D	
Pathfinding.TemporaryNode.associatedNode	temporarynode.html#associatedNode	
Pathfinding.TemporaryNode.position	temporarynode.html#position	
Pathfinding.TemporaryNode.targetIndex	temporarynode.html#targetIndex	
Pathfinding.TemporaryNode.type	temporarynode.html#type	
Pathfinding.TemporaryNodeType	pathfinding.html#TemporaryNodeType	
Pathfinding.ThreadCount	pathfinding.html#ThreadCount	Number of threads to use.
Pathfinding.TriangleMeshNode.InaccuratePathSearch	trianglemeshnode.html#InaccuratePathSearch	Legacy compatibility. \n\nEnabling this will make pathfinding use node centers, which leads to less accurate paths (but it's faster).
Pathfinding.TriangleMeshNode.MarkerClosest	trianglemeshnode.html#MarkerClosest	
Pathfinding.TriangleMeshNode.MarkerDecode	trianglemeshnode.html#MarkerDecode	
Pathfinding.TriangleMeshNode.MarkerGetVertices	trianglemeshnode.html#MarkerGetVertices	
Pathfinding.TriangleMeshNode.PathNodeVariants	trianglemeshnode.html#PathNodeVariants	
Pathfinding.TriangleMeshNode.TileIndex	trianglemeshnode.html#TileIndex	Tile index in the recast or navmesh graph that this node is part of. \n\n[more in online documentation]
Pathfinding.TriangleMeshNode._navmeshHolders	trianglemeshnode.html#_navmeshHolders	Holds INavmeshHolder references for all graph indices to be able to access them in a performant manner.
Pathfinding.TriangleMeshNode.lockObject	trianglemeshnode.html#lockObject	Used for synchronised access to the _navmeshHolders array.
Pathfinding.TriangleMeshNode.v0	trianglemeshnode.html#v0	Internal vertex index for the first vertex.
Pathfinding.TriangleMeshNode.v1	trianglemeshnode.html#v1	Internal vertex index for the second vertex.
Pathfinding.TriangleMeshNode.v2	trianglemeshnode.html#v2	Internal vertex index for the third vertex.
Pathfinding.UniqueComponentAttribute.tag	uniquecomponentattribute.html#tag	
Pathfinding.UnityReferenceHelper.guid	unityreferencehelper.html#guid	
Pathfinding.Util.BatchedEvents.Archetype.action	archetype.html#action	
Pathfinding.Util.BatchedEvents.Archetype.archetypeIndex	archetype.html#archetypeIndex	
Pathfinding.Util.BatchedEvents.Archetype.events	archetype.html#events	
Pathfinding.Util.BatchedEvents.Archetype.objectCount	archetype.html#objectCount	
Pathfinding.Util.BatchedEvents.Archetype.objects	archetype.html#objects	
Pathfinding.Util.BatchedEvents.Archetype.sampler	archetype.html#sampler	
Pathfinding.Util.BatchedEvents.Archetype.transforms	archetype.html#transforms	
Pathfinding.Util.BatchedEvents.Archetype.type	archetype.html#type	
Pathfinding.Util.BatchedEvents.Archetype.variant	archetype.html#variant	
Pathfinding.Util.BatchedEvents.ArchetypeMask	batchedevents.html#ArchetypeMask	
Pathfinding.Util.BatchedEvents.ArchetypeOffset	batchedevents.html#ArchetypeOffset	
Pathfinding.Util.BatchedEvents.Event	batchedevents.html#Event	
Pathfinding.Util.BatchedEvents.data	batchedevents.html#data	
Pathfinding.Util.BatchedEvents.instance	batchedevents.html#instance	
Pathfinding.Util.BatchedEvents.isIterating	batchedevents.html#isIterating	
Pathfinding.Util.BatchedEvents.isIteratingOverTypeIndex	batchedevents.html#isIteratingOverTypeIndex	
Pathfinding.Util.DependencyCheck.Dependency.name	dependency.html#name	
Pathfinding.Util.DependencyCheck.Dependency.version	dependency.html#version	
Pathfinding.Util.EditorGUILayoutHelper.tagNamesAndEditTagsButton	editorguilayouthelper.html#tagNamesAndEditTagsButton	Tag names and an additional 'Edit Tags...' entry. \n\nUsed for SingleTagField
Pathfinding.Util.EditorGUILayoutHelper.tagValues	editorguilayouthelper.html#tagValues	
Pathfinding.Util.EditorGUILayoutHelper.timeLastUpdatedTagNames	editorguilayouthelper.html#timeLastUpdatedTagNames	Last time tagNamesAndEditTagsButton was updated. \n\nUses EditorApplication.timeSinceStartup
Pathfinding.Util.GraphGizmoHelper.builder	graphgizmohelper.html#builder	
Pathfinding.Util.GraphGizmoHelper.debugData	graphgizmohelper.html#debugData	
Pathfinding.Util.GraphGizmoHelper.debugFloor	graphgizmohelper.html#debugFloor	
Pathfinding.Util.GraphGizmoHelper.debugMode	graphgizmohelper.html#debugMode	
Pathfinding.Util.GraphGizmoHelper.debugPathID	graphgizmohelper.html#debugPathID	
Pathfinding.Util.GraphGizmoHelper.debugPathNodes	graphgizmohelper.html#debugPathNodes	
Pathfinding.Util.GraphGizmoHelper.debugRoof	graphgizmohelper.html#debugRoof	
Pathfinding.Util.GraphGizmoHelper.drawConnection	graphgizmohelper.html#drawConnection	
Pathfinding.Util.GraphGizmoHelper.drawConnectionColor	graphgizmohelper.html#drawConnectionColor	
Pathfinding.Util.GraphGizmoHelper.drawConnectionStart	graphgizmohelper.html#drawConnectionStart	
Pathfinding.Util.GraphGizmoHelper.hasher	graphgizmohelper.html#hasher	
Pathfinding.Util.GraphGizmoHelper.nodeStorage	graphgizmohelper.html#nodeStorage	
Pathfinding.Util.GraphGizmoHelper.showSearchTree	graphgizmohelper.html#showSearchTree	
Pathfinding.Util.GraphSnapshot.inner	graphsnapshot.html#inner	
Pathfinding.Util.GraphTransform.i3translation	graphtransform.html#i3translation	
Pathfinding.Util.GraphTransform.identity	graphtransform.html#identity	True if this transform is the identity transform (i.e it does not do anything)
Pathfinding.Util.GraphTransform.identityTransform	graphtransform.html#identityTransform	
Pathfinding.Util.GraphTransform.inverseMatrix	graphtransform.html#inverseMatrix	
Pathfinding.Util.GraphTransform.inverseRotation	graphtransform.html#inverseRotation	
Pathfinding.Util.GraphTransform.isIdentity	graphtransform.html#isIdentity	
Pathfinding.Util.GraphTransform.isOnlyTranslational	graphtransform.html#isOnlyTranslational	
Pathfinding.Util.GraphTransform.isXY	graphtransform.html#isXY	
Pathfinding.Util.GraphTransform.isXZ	graphtransform.html#isXZ	
Pathfinding.Util.GraphTransform.matrix	graphtransform.html#matrix	
Pathfinding.Util.GraphTransform.onlyTranslational	graphtransform.html#onlyTranslational	True if this transform is a pure translation without any scaling or rotation.
Pathfinding.Util.GraphTransform.rotation	graphtransform.html#rotation	
Pathfinding.Util.GraphTransform.translation	graphtransform.html#translation	
Pathfinding.Util.GraphTransform.up	graphtransform.html#up	
Pathfinding.Util.GraphTransform.xyPlane	graphtransform.html#xyPlane	Transforms from the XZ plane to the XY plane.
Pathfinding.Util.GraphTransform.xzPlane	graphtransform.html#xzPlane	Transforms from the XZ plane to the XZ plane (i.e. \n\nan identity transformation)
Pathfinding.Util.Guid._a	guid.html#_a	
Pathfinding.Util.Guid._b	guid.html#_b	
Pathfinding.Util.Guid.hex	guid.html#hex	
Pathfinding.Util.Guid.random	guid.html#random	
Pathfinding.Util.Guid.text	guid.html#text	
Pathfinding.Util.Guid.zero	guid.html#zero	
Pathfinding.Util.Guid.zeroString	guid.html#zeroString	
Pathfinding.Util.IEntityIndex.EntityIndex	ientityindex.html#EntityIndex	
Pathfinding.Util.MeshUtility.JobMergeNearbyVertices.CoordinateSorter.vertices	coordinatesorter.html#vertices	
Pathfinding.Util.MeshUtility.JobMergeNearbyVertices.mergeRadiusSq	jobmergenearbyvertices.html#mergeRadiusSq	
Pathfinding.Util.MeshUtility.JobMergeNearbyVertices.triangles	jobmergenearbyvertices.html#triangles	
Pathfinding.Util.MeshUtility.JobMergeNearbyVertices.vertices	jobmergenearbyvertices.html#vertices	
Pathfinding.Util.MeshUtility.JobRemoveDegenerateTriangles.tags	jobremovedegeneratetriangles.html#tags	
Pathfinding.Util.MeshUtility.JobRemoveDegenerateTriangles.triangles	jobremovedegeneratetriangles.html#triangles	
Pathfinding.Util.MeshUtility.JobRemoveDegenerateTriangles.verbose	jobremovedegeneratetriangles.html#verbose	
Pathfinding.Util.MeshUtility.JobRemoveDegenerateTriangles.vertices	jobremovedegeneratetriangles.html#vertices	
Pathfinding.Util.NativeMovementPlane.rotation	nativemovementplane.html#rotation	The rotation of the plane. \n\nThe plane is defined by the XZ-plane rotated by this quaternion.\n\nShould always be normalized.
Pathfinding.Util.NativeMovementPlane.up	nativemovementplane.html#up	Normal of the plane.
Pathfinding.Util.NodeHasher.debugData	nodehasher.html#debugData	
Pathfinding.Util.NodeHasher.hasher	nodehasher.html#hasher	
Pathfinding.Util.NodeHasher.includeAreaInfo	nodehasher.html#includeAreaInfo	
Pathfinding.Util.NodeHasher.includeHierarchicalNodeInfo	nodehasher.html#includeHierarchicalNodeInfo	
Pathfinding.Util.NodeHasher.includePathSearchInfo	nodehasher.html#includePathSearchInfo	
Pathfinding.Util.PathInterpolator.Cursor.currentDistance	cursor.html#currentDistance	
Pathfinding.Util.PathInterpolator.Cursor.currentSegmentLength	cursor.html#currentSegmentLength	
Pathfinding.Util.PathInterpolator.Cursor.curvatureDirection	cursor.html#curvatureDirection	A vector parallel to the local curvature. \n\nThis will be zero on straight line segments, and in the same direction as the rotation axis when on a corner.\n\nSince this interpolator follows a polyline, the curvature is always either 0 or infinite. Therefore the magnitude of this vector has no meaning when non-zero. Only the direction matters.
Pathfinding.Util.PathInterpolator.Cursor.distance	cursor.html#distance	Traversed distance from the start of the path.
Pathfinding.Util.PathInterpolator.Cursor.distanceToSegmentStart	cursor.html#distanceToSegmentStart	
Pathfinding.Util.PathInterpolator.Cursor.endPoint	cursor.html#endPoint	Last point in the path.
Pathfinding.Util.PathInterpolator.Cursor.fractionAlongCurrentSegment	cursor.html#fractionAlongCurrentSegment	Fraction of the way along the current segment. \n\n0 is at the start of the segment, 1 is at the end of the segment.
Pathfinding.Util.PathInterpolator.Cursor.interpolator	cursor.html#interpolator	
Pathfinding.Util.PathInterpolator.Cursor.position	cursor.html#position	Current position.
Pathfinding.Util.PathInterpolator.Cursor.remainingDistance	cursor.html#remainingDistance	Remaining distance until the end of the path.
Pathfinding.Util.PathInterpolator.Cursor.segmentCount	cursor.html#segmentCount	
Pathfinding.Util.PathInterpolator.Cursor.segmentIndex	cursor.html#segmentIndex	Current segment. \n\nThe start and end points of the segment are path[value] and path[value+1].
Pathfinding.Util.PathInterpolator.Cursor.tangent	cursor.html#tangent	Tangent of the curve at the current position. \n\nNot necessarily normalized.
Pathfinding.Util.PathInterpolator.Cursor.valid	cursor.html#valid	True if this instance has a path set. \n\n[more in online documentation]
Pathfinding.Util.PathInterpolator.Cursor.version	cursor.html#version	
Pathfinding.Util.PathInterpolator.path	pathinterpolator.html#path	
Pathfinding.Util.PathInterpolator.start	pathinterpolator.html#start	
Pathfinding.Util.PathInterpolator.totalDistance	pathinterpolator.html#totalDistance	
Pathfinding.Util.PathInterpolator.valid	pathinterpolator.html#valid	True if this instance has a path set. \n\n[more in online documentation]
Pathfinding.Util.PathInterpolator.version	pathinterpolator.html#version	
Pathfinding.Util.PathPartWithLinkInfo.endIndex	pathpartwithlinkinfo.html#endIndex	Index of the last point in the path that this part represents. \n\nFor off-mesh links, this will refer to the first point in the part after the off-mesh link.
Pathfinding.Util.PathPartWithLinkInfo.linkInfo	pathpartwithlinkinfo.html#linkInfo	The off-mesh link that this part represents. \n\nWill contain a null link if this part is not an off-mesh link
Pathfinding.Util.PathPartWithLinkInfo.startIndex	pathpartwithlinkinfo.html#startIndex	Index of the first point in the path that this part represents. \n\nFor off-mesh links, this will refer to the last point in the part before the off-mesh link.
Pathfinding.Util.PathPartWithLinkInfo.type	pathpartwithlinkinfo.html#type	Specifies if this is a sequence of nodes, or an off-mesh link.
Pathfinding.Util.SimpleMovementPlane.XYPlane	simplemovementplane.html#XYPlane	A plane that spans the X and Y axes.
Pathfinding.Util.SimpleMovementPlane.XZPlane	simplemovementplane.html#XZPlane	A plane that spans the X and Z axes.
Pathfinding.Util.SimpleMovementPlane.inverseRotation	simplemovementplane.html#inverseRotation	
Pathfinding.Util.SimpleMovementPlane.isXY	simplemovementplane.html#isXY	
Pathfinding.Util.SimpleMovementPlane.isXZ	simplemovementplane.html#isXZ	
Pathfinding.Util.SimpleMovementPlane.plane	simplemovementplane.html#plane	
Pathfinding.Util.SimpleMovementPlane.rotation	simplemovementplane.html#rotation	
Pathfinding.Util.ToPlaneMatrix.matrix	toplanematrix.html#matrix	
Pathfinding.Util.ToWorldMatrix.matrix	toworldmatrix.html#matrix	
Pathfinding.VersionedMonoBehaviour.EntityIndex	versionedmonobehaviour.html#EntityIndex	Internal entity index used by BatchedEvents. \n\nShould never be modified by other scripts.
Pathfinding.VersionedMonoBehaviour.version	versionedmonobehaviour.html#version	Version of the serialized data. \n\nUsed for script upgrades.
Pathfinding.WelcomeScreen.FirstSceneToLoad	welcomescreen.html#FirstSceneToLoad	
Pathfinding.WelcomeScreen.askedAboutQuitting	welcomescreen.html#askedAboutQuitting	
Pathfinding.WelcomeScreen.isImportingSamples	welcomescreen.html#isImportingSamples	
Pathfinding.WelcomeScreen.m_VisualTreeAsset	welcomescreen.html#m_VisualTreeAsset	
Pathfinding.WorkItemProcessor.IndexedQueue.Count	indexedqueue.html#Count	
Pathfinding.WorkItemProcessor.IndexedQueue.buffer	indexedqueue.html#buffer	
Pathfinding.WorkItemProcessor.IndexedQueue.start	indexedqueue.html#start	
Pathfinding.WorkItemProcessor.IndexedQueue.this[int index]	indexedqueue.html#thisintindex	
Pathfinding.WorkItemProcessor.OnGraphsUpdated	workitemprocessor.html#OnGraphsUpdated	
Pathfinding.WorkItemProcessor.anyGraphsDirty	workitemprocessor.html#anyGraphsDirty	
Pathfinding.WorkItemProcessor.anyQueued	workitemprocessor.html#anyQueued	True if any work items are queued right now.
Pathfinding.WorkItemProcessor.astar	workitemprocessor.html#astar	
Pathfinding.WorkItemProcessor.preUpdateEventSent	workitemprocessor.html#preUpdateEventSent	
Pathfinding.WorkItemProcessor.workItems	workitemprocessor.html#workItems	
Pathfinding.WorkItemProcessor.workItemsInProgress	workitemprocessor.html#workItemsInProgress	True while a batch of work items are being processed. \n\nSet to true when a work item is started to be processed, reset to false when all work items are complete.\n\nWork item updates are often spread out over several frames, this flag will be true during the whole time the updates are in progress.
Pathfinding.WorkItemProcessor.workItemsInProgressRightNow	workitemprocessor.html#workItemsInProgressRightNow	Used to prevent waiting for work items to complete inside other work items as that will cause the program to hang.